// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

init()
{
    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sentry_gun", "init" ) )
        [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sentry_gun", "init" ) ]]();

    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sentry_gun", "initSentrySettings" ) )
        [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sentry_gun", "initSentrySettings" ) ]]();
}

weaponcleanupsentryturret( var_0, var_1, var_2 )
{
    if ( !istrue( var_1 ) )
        scripts\cp_mp\killstreaks\killstreakdeploy::minigamefinishcount( var_2 );
}

tryusesentryturret( var_0 )
{
    var_1 = scripts\cp_mp\utility\killstreak_utility::createstreakinfo( var_0, self );
    return tryusesentryturretfromstruct( var_1 );
}

tryusesentryturretfromstruct( var_0 )
{
    level endon( "game_ended" );
    self endon( "disconnect" );

    if ( isdefined( level.killstreaktriggeredfunc ) )
    {
        if ( !level [[ level.killstreaktriggeredfunc ]]( var_0 ) )
        {
            self.bgivensentry = 0;
            return 0;
        }
    }

    scripts\cp_mp\utility\weapon_utility::_id_11C5C();
    var_1 = scripts\cp_mp\killstreaks\killstreakdeploy::streakdeploy_doweaponswitchdeploy( var_0, getcompleteweaponname( "deploy_sentry_mp" ), 1, undefined, undefined, ::weaponcleanupsentryturret );

    if ( !istrue( var_1 ) )
    {
        self.bgivensentry = 0;
        return 0;
    }

    if ( isdefined( level.killstreakbeginusefunc ) )
    {
        if ( !level [[ level.killstreakbeginusefunc ]]( var_0 ) )
        {
            self.bgivensentry = 0;
            return 0;
        }
    }

    scripts\cp_mp\killstreaks\manual_turret::set_relic_amped( 0 );
    var_2 = sentryturret_create( "sentry_turret", var_0 );

    if ( !isdefined( var_2 ) )
    {
        scripts\cp_mp\killstreaks\manual_turret::set_relic_amped( 1 );
        self.bgivensentry = 0;
        return 0;
    }

    var_3 = sentryturret_watchplacement( var_2, var_0, 0, 1.25 );

    if ( !isdefined( var_3 ) )
    {
        scripts\cp_mp\killstreaks\manual_turret::set_relic_amped( 1 );
        var_2 delete();
        self.bgivensentry = 0;
        return 0;
    }

    var_2 scripts\cp_mp\emp_debuff::set_start_emp_callback( ::sentryturret_empstarted );
    var_2 scripts\cp_mp\emp_debuff::set_clear_emp_callback( ::sentryturret_empcleared );
    scripts\cp_mp\killstreaks\manual_turret::set_relic_amped( 1 );
    sentryturret_setplaced( var_2, var_3 );

    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sentry_gun", "munitionUsed" ) )
        self [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sentry_gun", "munitionUsed" ) ]]();

    return 1;
}

sentryturret_watchplacement( var_0, var_1, var_2, var_3 )
{
    self.bgivensentry = 1;
    var_0 laseroff();
    thread sentryturret_delayplacementinstructions( var_3 );
    var_4 = undefined;

    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sentry_gun", "watchForPlayerEnteringLastStand" ) )
        self thread [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sentry_gun", "watchForPlayerEnteringLastStand" ) ]]();

    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sentry_gun", "getTargetMarker" ) )
        var_4 = self [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sentry_gun", "getTargetMarker" ) ]]( var_1, var_2 );

    self notify( "turret_placement_finished" );

    if ( !isdefined( var_4 ) || !isdefined( var_4.location ) )
    {
        if ( scripts\cp_mp\utility\player_utility::_isalive() )
            scripts\cp_mp\killstreaks\manual_turret::manualturret_switchbacklastweapon( "deploy_sentry_mp" );

        return undefined;
    }

    var_0 thread scripts\cp_mp\killstreaks\manual_turret::manualturret_disablefire( self, 1, 1 );

    if ( self hasweapon( "deploy_sentry_mp" ) )
        thread scripts\cp_mp\killstreaks\manual_turret::manualturret_switchbacklastweapon( "deploy_sentry_mp", 1, 1 );

    var_5 = 0.85;
    scripts\cp_mp\hostmigration::hostmigration_waitlongdurationwithpause( var_5 );
    return var_4;
}

sentryturret_delayplacementinstructions( var_0 )
{
    self endon( "death_or_disconnect" );
    self endon( "turret_placement_finished" );
    level endon( "game_ended" );
    scripts\cp_mp\hostmigration::hostmigration_waitlongdurationwithpause( var_0 );
    self setclientomnvar( "ui_turret_placement", 1 );
    thread scripts\cp_mp\killstreaks\manual_turret::set_player_munition_currency( "death" );
    thread scripts\cp_mp\killstreaks\manual_turret::set_player_munition_currency( "turret_placement_finished" );
}

sentryturret_create( var_0, var_1 )
{
    var_2 = level.sentrysettings[var_0];
    var_3 = spawnturret( "misc_turret", self.origin, level.sentrysettings[var_0].weaponinfo );
    var_3.owner = self;
    var_3.team = self.team;
    var_3.angles = self.angles;
    var_3.health = 9999;
    var_3.maxhealth = var_2.maxhealth;
    var_3.streakinfo = var_1;
    var_3.turrettype = var_0;
    var_3.shouldsplash = 1;
    var_3.ammocount = var_2.ammo;
    var_3.timeout = var_2.timeout;
    var_3.carriedby = self;
    var_3 sentryturret_setturretmodel( "placed" );
    var_3 setturretowner( var_3.owner );
    var_3 setturretteam( var_3.team );
    var_3 makeunusable();
    var_3 setnodeploy( 1 );
    var_3 setdefaultdroppitch( 0 );
    var_3 hide();
    var_3 setautorotationdelay( 0.2 );
    var_3.momentum = 0;
    var_3.heatlevel = 0;
    var_3.overheated = 0;
    var_3.cooldownwaittime = 0.1;

    switch ( var_0 )
    {
        case "sentry_turret":
        default:
            var_3 maketurretinoperable();
            var_3 setleftarc( 80 );
            var_3 setrightarc( 80 );
            var_3 setbottomarc( 50 );
            var_3 settoparc( 60 );
            var_3 setconvergencetime( 0.6, "pitch" );
            var_3 setconvergencetime( 0.6, "yaw" );
            var_3 setconvergenceheightpercent( 0.65 );
            var_3 setdefaultdroppitch( -89.0 );
            break;
    }

    var_3 setturretmodechangewait( 1 );
    var_3 scripts\cp_mp\emp_debuff::allow_emp( 0 );
    var_5 = anglestoforward( var_3.angles );
    var_6 = var_3 gettagorigin( "tag_laser" ) + ( 0, 0, 10 );
    var_6 = var_6 - var_5 * 20;
    var_7 = spawn( "script_model", var_6 );
    var_7 linkto( var_3 );
    var_3.killcament = var_7;
    var_3.escape_if_player_is_in_hangar = spawn( "script_model", var_3.origin );
    var_3.escape_if_player_is_in_hangar.team = var_3.team;
    var_3.escape_if_player_is_in_hangar.owner = var_3.owner;
    var_3.escape_if_player_is_in_hangar setmodel( "weapon_vm_mg_sentry_turret_invis_base" );
    var_3.escape_if_player_is_in_hangar dontinterpolate();
    var_3.escape_if_player_is_in_hangar hide();
    return var_3;
}

sentryturret_setplaced( var_0, var_1 )
{
    var_2 = level.sentrysettings[var_0.turrettype];
    var_0 sentryturret_setturretmodel( "placed" );

    if ( !isdefined( self.placedsentries ) )
        self.placedsentries = [];

    if ( !isdefined( self.placedsentries[var_0.turrettype] ) )
        self.placedsentries[var_0.turrettype] = [];

    if ( istrue( var_0.shouldsplash ) )
    {
        if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sound", "playKillstreakDeployDialog" ) )
            [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sound", "playKillstreakDeployDialog" ) ]]( self, var_0.streakinfo.streakname );

        var_3 = var_2.teamsplash;

        if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "hud", "teamPlayerCardSplash" ) )
            level thread [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "hud", "teamPlayerCardSplash" ) ]]( var_3, self );

        var_0.shouldsplash = 0;
    }

    var_0 show();
    var_0 dontinterpolate();
    var_0.angles = var_1.angles;
    var_0.carriedby = undefined;

    if ( isdefined( var_1.moving_platform ) )
    {
        var_0.moving_platform = var_1.moving_platform;
        var_0.spawn_fake_digit_pool = var_1.spawn_fake_digit_pool;
        var_0.spawn_exfil_techo = var_1.spawn_exfil_techo;
    }

    self.bgivensentry = 0;
    var_0.origin = var_1.location;
    var_0 playsound( "sentry_gun_plant" );
    var_0.escape_if_player_is_in_hangar show();
    var_0.escape_if_player_is_in_hangar.angles = var_0.angles;
    var_0.escape_if_player_is_in_hangar.origin = var_0.origin;
    var_0.escape_if_player_is_in_hangar linkto( var_0, "tag_aim_pivot" );
    var_4 = "icon_minimap_sentry";

    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "game", "createObjective" ) )
        var_0.minimapid = var_0.escape_if_player_is_in_hangar [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "game", "createObjective" ) ]]( var_4, var_0.team, undefined, 1, 1 );

    var_5 = self.placedsentries[var_0.turrettype].size;
    self.placedsentries[var_0.turrettype][var_5] = var_0;

    if ( var_5 + 1 > 2 )
        self.placedsentries[var_0.turrettype][0] notify( "kill_turret", 0, 0 );

    var_6 = 70;

    if ( var_0.model == level.sentrysettings[var_0.turrettype].modelbasecover )
        var_6 = 35;

    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "killstreak", "addToActiveKillstreakList" ) )
        var_0 [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "killstreak", "addToActiveKillstreakList" ) ]]( var_0.turrettype, "Killstreak_Ground", self, 0, 1, var_6, "carried" );

    var_0 setmode( level.sentrysettings[var_0.turrettype].sentrymodeon );
    var_7 = "bi_base";

    if ( !isdefined( var_0.useownerobj ) )
    {
        var_8 = var_0 gettagorigin( var_7 );

        if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sentry_gun", "createHintObject" ) )
            var_0.useownerobj = [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sentry_gun", "createHintObject" ) ]]( var_8, "HINT_BUTTON", undefined, var_2.ownerusehintstring );
    }
    else
    {
        var_8 = var_0 gettagorigin( var_7 );
        var_0.useownerobj makeusable();
        var_0.useownerobj dontinterpolate();
        var_0.useownerobj.origin = var_8;
    }

    var_0.useownerobj linkto( var_0, var_7 );

    foreach ( var_10 in level.players )
    {
        if ( var_10 != var_0.owner )
            var_0.useownerobj disableplayeruse( var_10 );
    }

    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sentry_gun", "handleMovingPlatform" ) )
        [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sentry_gun", "handleMovingPlatform" ) ]]( var_0 );

    var_0 scripts\cp_mp\emp_debuff::allow_emp( 1 );
    var_0 scripts\mp\sentientpoolmanager::registersentient( "Killstreak_Static", self );
    var_0 sentryturret_empupdate();
    var_0 thread sentry_attacktargets();
    var_0 thread sentry_beepsounds();
    thread sentryturret_delaydeletemarker( var_0, var_1 );
    thread sentryturret_watchpickup( var_0 );
    thread sentryturret_watchdamage( var_0 );
    thread sentryturret_watchdeath( var_0 );
    thread sentryturret_watchtimeout( var_0 );
    thread sentryturret_watchdisown( var_0 );
    thread _id_11D9B( var_0 );
    var_0 notify( "turret_place_successful" );
}

sentryturret_setcarried( var_0 )
{
    var_0 endon( "kill_turret" );
    self endon( "death_or_disconnect" );
    level endon( "game_ended" );

    if ( createheadicon( self getcurrentweapon() ) == "iw8_lm_dblmg_mp" )
    {
        self notify( "switched_from_minigun" );

        while ( createheadicon( self getcurrentweapon() ) == "iw8_lm_dblmg_mp" )
            waitframe();
    }

    if ( isdefined( var_0.moving_platform ) )
    {
        var_0.moving_platform = undefined;
        var_0.spawn_fake_digit_pool = undefined;
        var_0.spawn_exfil_techo = undefined;
        var_0 unlink();
    }

    var_0 scripts\cp_mp\emp_debuff::allow_emp( 0 );
    var_0 scripts\mp\sentientpoolmanager::unregistersentient( var_0.sentientpool, var_0.sentientpoolindex );
    var_1 = var_0 getlinkedchildren();

    foreach ( var_3 in var_1 )
    {
        if ( isdefined( var_3 ) )
            var_3 unlink();
    }

    if ( isdefined( var_0.minimapid ) )
    {
        if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "game", "returnObjectiveID" ) )
            [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "game", "returnObjectiveID" ) ]]( var_0.minimapid );

        var_0.minimapid = undefined;
    }

    var_0.escape_if_player_is_in_hangar unlink();
    var_0.escape_if_player_is_in_hangar hide();
    sentryturret_setinactive( var_0 );
    var_0 hide();
    var_0.carriedby = self;
    var_0 notify( "carried" );
    var_0 playsound( "sentry_pickup" );
    scripts\cp_mp\utility\weapon_utility::_id_11C5C();
    scripts\cp_mp\utility\inventory_utility::_giveweapon( "deploy_sentry_mp" );
    scripts\cp_mp\utility\inventory_utility::_switchtoweapon( "deploy_sentry_mp" );
    scripts\cp_mp\killstreaks\manual_turret::set_relic_amped( 0 );
    var_5 = sentryturret_watchplacement( var_0, var_0.streakinfo, 1, 2 );

    if ( !isdefined( var_5 ) )
    {
        scripts\cp_mp\killstreaks\manual_turret::set_relic_amped( 1 );
        return 0;
    }

    scripts\cp_mp\killstreaks\manual_turret::set_relic_amped( 1 );
    sentryturret_setplaced( var_0, var_5 );
}

sentryturret_switchbacklastweapon( var_0 )
{
    if ( istrue( var_0 ) )
        scripts\cp_mp\utility\inventory_utility::_switchtoweaponimmediate( self.lastdroppableweaponobj );
    else
        scripts\cp_mp\utility\inventory_utility::_switchtoweapon( self.lastdroppableweaponobj );

    scripts\cp_mp\utility\inventory_utility::_takeweapon( "deploy_sentry_mp" );
}

sentryturret_setinactive( var_0 )
{
    var_0 setdefaultdroppitch( 30 );
    var_0 setmode( level.sentrysettings[var_0.turrettype].sentrymodeoff );
    var_0.useownerobj makeunusable();
    var_0.useownerobj unlink();
}

sentryturret_delaydeletemarker( var_0, var_1 )
{
    var_0 endon( "kill_turret" );
    level endon( "game_ended" );
    wait 0.25;

    if ( isdefined( var_1.visual ) )
        var_1.visual delete();
}

sentryturret_disableplayeruseonconnect( var_0, var_1 )
{
    if ( isdefined( var_0 ) )
    {
        var_0 endon( "kill_turret" );
        var_0 endon( "carried" );
    }

    self endon( "disconnect" );
    level endon( "game_ended" );

    for (;;)
    {
        level waittill( "connected", var_2 );
        var_1 disableplayeruse( var_2 );
    }
}

sentryturret_watchpickup( var_0 )
{
    var_0 endon( "kill_turret" );
    var_0 endon( "carried" );
    self endon( "disconnect" );
    level endon( "game_ended" );

    for (;;)
    {
        var_0.useownerobj waittill( "trigger", var_1 );

        if ( var_1 != self )
            continue;

        if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sentry_gun", "allowPickupOfTurret" ) )
        {
            if ( !var_1 [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sentry_gun", "allowPickupOfTurret" ) ]]() )
                continue;
        }

        if ( istrue( var_1.isjuggernaut ) )
        {
            if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "hud", "showErrorMessage" ) )
                var_1 [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "hud", "showErrorMessage" ) ]]( "KILLSTREAKS/JUGG_CANNOT_BE_PICKED_UP" );

            continue;
        }

        var_0.useownerobj makeunusable();
        var_0 setmode( level.sentrysettings[var_0.turrettype].sentrymodeoff );
        self.placedsentries[var_0.turrettype] = scripts\engine\utility::array_remove( self.placedsentries[var_0.turrettype], var_0 );
        thread sentryturret_setcarried( var_0 );
    }
}

sentryturret_disableplayerpickuponconnect( var_0 )
{
    var_0 endon( "kill_turret" );
    var_0 endon( "carried" );
    self endon( "disconnect" );
    level endon( "game_ended" );

    for (;;)
    {
        level waittill( "connected", var_1 );
        var_1 waittill( "spawned_player" );
        var_0.useownerobj disableplayeruse( var_1 );
    }
}

sentryturret_watchdismantle( var_0 )
{
    var_0 endon( "kill_turret" );
    var_0 endon( "carried" );
    self endon( "disconnect" );
    level endon( "game_ended" );

    foreach ( var_2 in level.players )
    {
        if ( level.teambased )
        {
            if ( var_2.team != self.team )
                continue;
        }
        else if ( var_2 != self )
            continue;
    }

    thread sentryturret_disableplayerdismantleonconnect( var_0 );

    for (;;)
    {
        var_0.dismantleobj waittill( "trigger", var_2 );
        var_0 notify( "kill_turret", 0, 1 );
        break;
    }
}

sentryturret_watchdamage( var_0 )
{
    var_0 endon( "kill_turret" );
    var_0 endon( "carried" );
    self endon( "disconnect" );
    level endon( "game_ended" );

    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sentry_gun", "monitorDamage" ) )
        self [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sentry_gun", "monitorDamage" ) ]]( var_0 );
}

sentryturret_disableplayerdismantleonconnect( var_0 )
{
    var_0 endon( "kill_turret" );
    var_0 endon( "carried" );
    self endon( "disconnect" );
    level endon( "game_ended" );

    for (;;)
    {
        level waittill( "connected", var_1 );
        var_1 waittill( "spawned_player" );

        if ( level.teambased )
        {
            if ( var_1.team != self.team )
                continue;
        }
    }
}

sentryturret_empstarted( var_0 )
{
    sentryturret_empupdate();
}

sentryturret_empcleared( var_0 )
{
    if ( var_0 )
        return;

    sentryturret_empupdate();
}

sentryturret_empupdate()
{
    if ( scripts\cp_mp\emp_debuff::is_empd() )
    {
        self turretfiredisable();
        self setmode( level.sentrysettings[self.turrettype].sentrymodeoff );
        self laseroff();
    }
    else
    {
        self turretfireenable();
        self setmode( level.sentrysettings[self.turrettype].sentrymodeon );
    }
}

sentryturret_watchdeath( var_0 )
{
    var_0 endon( "carried" );
    var_0 waittill( "kill_turret", var_1, var_2 );

    if ( isdefined( self ) )
    {
        self.placedsentries[var_0.turrettype] = scripts\engine\utility::array_remove( self.placedsentries[var_0.turrettype], var_0 );
        sentryturret_setinactive( var_0 );

        if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "player", "printGameAction" ) )
            self [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "player", "printGameAction" ) ]]( "killstreak ended - manual_turret", self );

        var_0.streakinfo.init_swivelroom_currsolution_marquee = istrue( var_2 );
        scripts\cp_mp\utility\killstreak_utility::x1loadout( var_0.streakinfo );
    }

    var_0 sentryturret_setturretmodel( "destroyed" );
    var_0 setturretowner( undefined );

    if ( !istrue( var_1 ) )
    {
        var_0 playsound( "sentry_explode_smoke" );
        var_0 setscriptablepartstate( "shutdown", "on" );
        scripts\cp_mp\hostmigration::hostmigration_waitlongdurationwithpause( 2 );
        var_0 setscriptablepartstate( "explode", "regular" );
    }
    else
        var_0 setscriptablepartstate( "explode", "violent" );

    var_0 playsound( "mp_equip_destroyed" );

    if ( isdefined( level.killstreakfinishusefunc ) )
        level thread [[ level.killstreakfinishusefunc ]]( var_0.streakinfo );

    if ( isdefined( var_0.killcament ) )
        var_0.killcament delete();

    if ( isdefined( var_0.useownerobj ) )
        var_0.useownerobj delete();

    if ( isdefined( var_0.useotherobj ) )
        var_0.useotherobj delete();

    if ( isdefined( var_0.escape_if_player_is_in_hangar ) )
        var_0.escape_if_player_is_in_hangar delete();

    if ( isdefined( var_0.minimapid ) )
    {
        if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "game", "returnObjectiveID" ) )
            [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "game", "returnObjectiveID" ) ]]( var_0.minimapid );

        var_0.minimapid = undefined;
    }

    wait 0.2;
    var_0 delete();
}

sentryturret_delayscriptabledelete()
{
    level endon( "game_ended" );
    scripts\cp_mp\hostmigration::hostmigration_waitlongdurationwithpause( 5 );
    self delete();
}

sentryturret_watchtimeout( var_0 )
{
    var_0 endon( "kill_turret" );
    var_0 endon( "carried" );
    self endon( "disconnect" );
    level endon( "game_ended" );

    while ( var_0.timeout > 0 )
    {
        var_0.timeout = var_0.timeout - 0.05;
        scripts\cp_mp\hostmigration::hostmigration_waitlongdurationwithpause( 0.05 );
    }

    if ( scripts\cp_mp\utility\script_utility::issharedfuncdefined( "sound", "playKillstreakDialogOnPlayer" ) )
        [[ scripts\cp_mp\utility\script_utility::getsharedfunc( "sound", "playKillstreakDialogOnPlayer" ) ]]( "destroyed_" + var_0.streakinfo.streakname, undefined, undefined, self.origin );

    var_0 notify( "kill_turret", 0, 0 );
}

sentryturret_watchdisown( var_0 )
{
    var_0 endon( "kill_turret" );
    var_0 endon( "carried" );
    scripts\engine\utility::_id_12E40( "disconnect", "joined_team", "joined_spectators" );
    var_0 notify( "kill_turret", 0, 0 );
}

_id_11D9B( var_0 )
{
    var_0 endon( "kill_turret" );
    var_0 endon( "carried" );
    level waittill( "game_ended" );
    var_0 notify( "kill_turret", 0, 0 );
}

sentryturret_setturretmodel( var_0 )
{
    var_1 = undefined;

    if ( var_0 == "placed" )
        var_1 = level.sentrysettings[self.turrettype].modelbaseground;
    else
        var_1 = level.sentrysettings[self.turrettype].modeldestroyedground;

    self setmodel( var_1 );
}

sentry_attacktargets()
{
    self endon( "kill_turret" );
    self endon( "carried" );
    level endon( "game_ended" );
    self.momentum = 0;

    for (;;)
    {
        self waittill( "turretstatechange" );

        if ( self isfiringturret() )
        {
            self laseron();
            thread sentry_burstfirestart();
            continue;
        }

        self laseroff();
        sentry_spindown();
        thread sentry_burstfirestop();
    }
}

sentry_targetlocksound()
{
    self endon( "death" );
    self playsound( "sentry_gun_target_lock_beep" );
    wait 0.19;
    self playsound( "sentry_gun_target_lock_beep" );
}

sentry_spinup()
{
    thread sentry_targetlocksound();

    while ( self.momentum < level.sentrysettings[self.turrettype].spinuptime )
    {
        self.momentum = self.momentum + 0.1;
        wait 0.1;
    }
}

sentry_spindown()
{
    self.momentum = 0;
}

sentry_burstfirestart()
{
    self endon( "death" );
    self endon( "stop_shooting" );
    level endon( "game_ended" );
    sentry_spinup();
    var_0 = weaponfiretime( level.sentrysettings[self.turrettype].weaponinfo );
    var_1 = level.sentrysettings[self.turrettype].burstmin;
    var_2 = level.sentrysettings[self.turrettype].burstmax;
    var_3 = level.sentrysettings[self.turrettype].pausemin;
    var_4 = level.sentrysettings[self.turrettype].pausemax;
    var_5 = level.sentrysettings[self.turrettype].lockstrength;

    for (;;)
    {
        var_6 = randomintrange( var_1, var_2 + 1 );

        for ( var_7 = 0; var_7 < var_6 && !self.overheated; var_7++ )
        {
            self shootturret( "tag_flash", var_5 );
            self.streakinfo.shots_fired++;
            wait( var_0 );
        }

        wait( randomfloatrange( var_3, var_4 ) );
    }
}

sentry_burstfirestop()
{
    self notify( "stop_shooting" );
}

turret_heatmonitor()
{
    self endon( "kill_turret" );
    self endon( "carried" );
    level endon( "game_ended" );
    var_0 = level.sentrysettings[self.turrettype].overheattime;

    for (;;)
    {
        if ( self.heatlevel > var_0 )
        {
            self.overheated = 1;

            while ( self.heatlevel )
                wait 0.1;

            self.overheated = 0;
            self notify( "not_overheated" );
        }

        wait 0.05;
    }
}

playheatfx()
{
    self endon( "death" );
    self endon( "not_overheated" );
    level endon( "game_ended" );
    self notify( "playing_heat_fx" );
    self endon( "playing_heat_fx" );

    for (;;)
    {
        playfxontag( scripts\engine\utility::getfx( "sentry_overheat_mp" ), self, "tag_flash" );
        wait( level.sentrysettings[self.turrettype].fxtime );
    }
}

turret_coolmonitor()
{
    self endon( "kill_turret" );
    self endon( "carried" );
    level endon( "game_ended" );

    for (;;)
    {
        if ( self.heatlevel > 0 )
        {
            if ( self.cooldownwaittime <= 0 )
                self.heatlevel = max( 0, self.heatlevel - 0.05 );
            else
                self.cooldownwaittime = max( 0, self.cooldownwaittime - 0.05 );
        }

        wait 0.05;
    }
}

sentry_beepsounds()
{
    self endon( "death" );
    self endon( "carried" );
    self endon( "kill_turret" );
    level endon( "game_ended" );

    for (;;)
    {
        wait 3.0;

        if ( self isfiringturret() )
        {
            waitframe();
            continue;
        }

        self playsound( "sentry_gun_beep" );
    }
}
