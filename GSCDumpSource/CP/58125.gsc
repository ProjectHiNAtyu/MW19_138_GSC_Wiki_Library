// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

_id_11F1C( var_0, var_1 )
{
    var_2 = "sentry_turret";
    var_3 = level.sentrysettings[var_2];
    var_4 = spawnturret( "misc_turret", var_0.origin, level.sentrysettings[var_2].weaponinfo );
    var_4.team = "axis";

    if ( !isdefined( var_0.angles ) )
        var_0.angles = ( 0, 0, 0 );

    var_4.angles = var_0.angles;
    var_4.health = var_3.maxhealth;
    var_4.maxhealth = var_3.maxhealth;
    var_4.sentrytype = var_2;
    var_4.momentum = 0;
    var_4.heatlevel = 0;
    var_4.overheated = 0;
    var_4.cooldownwaittime = 2;
    var_4.turrettype = "sentry_turret";

    if ( !isdefined( var_1 ) )
        var_1 = "weapon_wm_mg_sentry_turret";

    var_4 setmodel( var_1 );
    var_4 setturretteam( "axis" );
    var_4 makeunusable();
    var_4 setnodeploy( 1 );
    var_4 setdefaultdroppitch( 0 );
    var_4 setautorotationdelay( 0.2 );
    var_4 maketurretinoperable();
    var_4 setleftarc( 80 );
    var_4 setrightarc( 80 );
    var_4 setbottomarc( 50 );
    var_4 settoparc( 60 );
    var_4 setconvergencetime( 0.6, "pitch" );
    var_4 setconvergencetime( 0.6, "yaw" );
    var_4 setconvergenceheightpercent( 0.65 );
    var_4 setdefaultdroppitch( -89.0 );
    var_4 setturretmodechangewait( 1 );
    var_4 solid();
    var_4 scripts\cp_mp\emp_debuff::set_start_emp_callback( ::sentryturret_empstarted );
    var_4 scripts\cp_mp\emp_debuff::set_clear_emp_callback( ::sentryturret_empcleared );
    var_4 scripts\cp_mp\emp_debuff::allow_emp( 0 );
    var_0.turret = var_4;

    if ( !isdefined( level.relicsquadlink ) )
        level.relicsquadlink = [];

    level.relicsquadlink = scripts\engine\utility::array_add( level.relicsquadlink, var_4 );
    wait 1;
    var_4 setmode( "auto_nonai" );
    var_4 scripts\cp_mp\emp_debuff::allow_emp( 1 );
    var_4 sentryturret_empupdate();
    var_4 thread gas_trigger_think();
    var_4 thread sentry_attacktargets();
    var_4 thread sentry_handledeath();
    var_4 thread scripts\cp_mp\killstreaks\sentry_gun::sentry_beepsounds();
    return var_4;
}

sentryturret_empstarted( var_0 )
{
    sentryturret_empupdate();
}

sentryturret_empcleared( var_0 )
{
    if ( var_0 )
        return;

    sentryturret_empupdate();
}

sentryturret_empupdate()
{
    if ( scripts\cp_mp\emp_debuff::is_empd() )
    {
        self turretfiredisable();
        self setmode( level.sentrysettings[self.turrettype].sentrymodeoff );
        self laseroff();
    }
    else
    {
        self turretfireenable();
        self setmode( "auto_nonai" );
    }
}

ignorefallback()
{
    self endon( "death" );
    self endon( "kill_turret" );
    level endon( "game_ended" );
    var_0 = self.origin;
    var_1 = 0.05;
    var_2 = int( var_1 * 20 );

    for (;;)
        wait( var_1 );
}

gas_trigger_think()
{
    self endon( "death" );
    self endon( "kill_turret" );
    level endon( "game_ended" );
    self setcandamage( 1 );

    for (;;)
    {
        self waittill( "damage", var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9, var_10, var_11, var_12, var_13, var_14 );

        if ( !isdefined( var_1 ) || !isplayer( var_1 ) && ( !isdefined( var_1.owner ) || !isplayer( var_1.owner ) ) )
            continue;

        if ( isdefined( var_9.basename ) )
        {
            if ( issubstr( var_9.basename, "emp_drone" ) )
            {

            }
        }

        var_15 = isdefined( var_1 ) && isplayer( var_1 );
        var_16 = isdefined( var_1.owner ) && isplayer( var_1.owner );
        var_17 = isdefined( var_1.classname ) && var_1.classname == "script_vehicle" && isdefined( var_1.owner ) && isplayer( var_1.owner );
        var_18 = var_17 && var_4 == "MOD_CRUSH";

        if ( var_15 || var_16 || var_18 )
        {
            if ( !scripts\cp\utility::prematchintiallandingcomplete() )
            {
                if ( var_16 )
                    var_1 = var_1.owner;

                scripts\cp\cp_agent_damage::addattacker( self, var_1, var_13, var_9, var_0, var_3, var_2, undefined, undefined, var_4 );
            }
        }

        scripts\cp\cp_damagefeedback::process_damage_feedback( var_13, var_1, var_0, var_8, var_4, var_9, var_2, var_2, var_7, undefined, self );
    }
}

sentry_attacktargets()
{
    self endon( "death" );
    level endon( "game_ended" );
    self.momentum = 0;
    self.heatlevel = 0;
    self.overheated = 0;
    thread sentry_heatmonitor();

    for (;;)
    {
        scripts\engine\utility::waittill_either( "turretstatechange", "cooled" );

        if ( self isfiringturret() )
        {
            self laseron();
            thread sentry_burstfirestart();
            continue;
        }

        self laseroff();
        sentry_spindown();
        thread sentry_burstfirestop();
    }
}

sentry_targetlocksound()
{
    self endon( "death" );
    self playsound( "sentry_gun_beep" );
    wait 0.1;
    self playsound( "sentry_gun_beep" );
    wait 0.1;
    self playsound( "sentry_gun_beep" );
}

sentry_spinup()
{
    thread sentry_targetlocksound();

    while ( self.momentum < level.sentrysettings[self.sentrytype].spinuptime )
    {
        self.momentum = self.momentum + 0.1;
        wait 0.1;
    }
}

sentry_spindown()
{
    self.momentum = 0;
}

sentry_burstfirestart()
{
    self endon( "death" );
    self endon( "stop_shooting" );
    level endon( "game_ended" );
    sentry_spinup();
    var_0 = weaponfiretime( level.sentrysettings[self.sentrytype].weaponinfo );
    var_1 = level.sentrysettings[self.sentrytype].burstmin;
    var_2 = level.sentrysettings[self.sentrytype].burstmax;
    var_3 = level.sentrysettings[self.sentrytype].pausemin;
    var_4 = level.sentrysettings[self.sentrytype].pausemax;

    for (;;)
    {
        var_5 = randomintrange( var_1, var_2 + 1 );

        for ( var_6 = 0; var_6 < var_5 && !self.overheated; var_6++ )
        {
            if ( !_id_11D97() )
                break;

            self shootturret();
            self notify( "bullet_fired" );
            self.heatlevel = self.heatlevel + var_0;
            wait( var_0 );
        }

        wait( randomfloatrange( var_3, var_4 ) );
    }
}

_id_11D97()
{
    if ( istrue( self.handlemeleekillrewardbullets ) )
    {
        var_0 = self getturrettarget( 0 );

        if ( isdefined( var_0 ) && isplayer( var_0 ) && var_0 isparachuting() )
            return 0;
    }

    return 1;
}

sentry_burstfirestop()
{
    self notify( "stop_shooting" );
}

sentry_heatmonitor()
{
    if ( istrue( self._id_1209C ) )
        return;

    self endon( "death" );
    var_0 = weaponfiretime( level.sentrysettings[self.sentrytype].weaponinfo );
    var_1 = 0;
    var_2 = 0;
    var_3 = level.sentrysettings[self.sentrytype].overheattime;
    var_4 = level.sentrysettings[self.sentrytype].cooldowntime;

    for (;;)
    {
        if ( self.heatlevel != var_1 )
            wait( var_0 );
        else
            self.heatlevel = max( 0, self.heatlevel - 0.05 );

        if ( self.heatlevel > var_3 )
        {
            self.overheated = 1;
            thread playheatfx();

            while ( self.heatlevel )
            {
                self.heatlevel = max( 0, self.heatlevel - var_4 );
                wait 0.1;
            }

            self.overheated = 0;
            self notify( "not_overheated" );
        }

        var_1 = self.heatlevel;
        wait 0.05;
    }
}

playheatfx()
{
    self endon( "death" );
    self endon( "not_overheated" );
    level endon( "game_ended" );
    self notify( "playing_heat_fx" );
    self endon( "playing_heat_fx" );

    for (;;)
    {
        playfxontag( scripts\engine\utility::getfx( "sentry_overheat_mp" ), self, "tag_flash" );
        wait( level.sentrysettings[self.sentrytype].fxtime );
    }
}

sentry_beepsounds()
{
    self endon( "death" );
    level endon( "game_ended" );

    for (;;)
    {
        wait 3.0;

        if ( !isdefined( self.carriedby ) )
            self playsound( "sentry_gun_beep" );
    }
}

sentry_handledeath()
{
    self waittill( "death" );
    level.relicsquadlink = scripts\engine\utility::array_remove( level.relicsquadlink, self );

    if ( !isdefined( self ) )
        return;

    self setmode( "sentry_offline" );
    self setscriptablepartstate( "explode", "violent" );

    if ( isdefined( self.attackerdata ) )
    {
        foreach ( var_1 in level.players )
        {
            var_2 = 0;

            if ( isdefined( self.attackerdata[var_1.guid] ) && isdefined( self.attackerdata[var_1.guid].damage ) )
            {
                if ( self.attackerdata[var_1.guid].damage >= self.maxhealth * 0.1 )
                    var_2 = 1;

                if ( self.attackerdata[var_1.guid].damage >= self.maxhealth * 0.2 )
                    var_2 = 2;

                if ( var_2 >= 1 )
                    var_1 thread scripts\mp\calloutmarkerping_mp::giverankxp( "destroyed_sentry_gun", scripts\mp\calloutmarkerping_mp::getscoreinfovalue( "destroyed_sentry_gun" ) );
            }
        }
    }

    if ( isdefined( self ) )
        thread sentry_deleteturret();
}

sentry_deleteturret()
{
    self notify( "sentry_delete_turret" );
    self endon( "sentry_delete_turret" );
    wait 1.5;
    playfxontag( scripts\engine\utility::getfx( "sentry_explode_mp" ), self, "tag_aim" );
    playfxontag( scripts\engine\utility::getfx( "sentry_smoke_mp" ), self, "tag_aim" );
    self playsound( "sentry_explode_smoke" );
    wait 0.1;
    self notify( "deleting" );

    if ( isdefined( self ) )
        self delete();
}
