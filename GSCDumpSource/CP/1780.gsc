// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

_giveweapon( var_0, var_1, var_2, var_3 )
{
    if ( !isdefined( var_1 ) )
        var_1 = -1;

    if ( !isdefined( var_3 ) )
        var_3 = 0;

    var_4 = undefined;

    if ( issameweapon( var_0 ) )
        var_4 = var_0;
    else
        var_4 = asmdevgetallstates( var_0 );

    if ( var_4 hasattachment( "akimbo", 1 ) || var_4 hasattachment( "g18pap2", 1 ) || isdefined( var_2 ) && var_2 == 1 )
        self giveweapon( var_4, var_1, 1, -1, var_3 );
    else
        self giveweapon( var_4, var_1, 0, -1, var_3 );

    thread updatelaststandpistol( var_4 );
    return var_4;
}

setplayerstunned()
{
    if ( !isdefined( self.isstunned ) )
        self.isstunned = 1;
    else
        self.isstunned++;
}

waittillphysicsmodelstops()
{
    wait 0.5;

    for (;;)
    {
        var_0 = self physics_getbodyid( 0 );
        var_1 = physics_getbodylinvel( var_0 );

        if ( lengthsquared( var_1 ) > 0.5 )
        {
            wait 0.1;
            continue;
        }

        break;
    }

    self physicsstopserver();
}

setplayerunstunned()
{
    self.isstunned--;
}

setupdamagetriggers( var_0 )
{
    var_0 endon( "disconnect" );

    if ( scripts\engine\utility::flag_exist( "infil_complete" ) )
        scripts\engine\utility::flag_wait( "infil_complete" );

    wait 1;
    var_1 = getent( "playable_area", "targetname" );
    var_2 = getent( "boundary_toxic_line", "targetname" );
    var_3 = isdefined( var_1 );
    var_4 = getdvar( "NSQLTTMRMP" );
    var_5 = getdvar( "MOLPOSLOMO" );
    var_0.last_good_pos = undefined;
    var_0.outofbounds = 1;
    var_6 = undefined;

    if ( var_5 == "cp_strike" )
        var_7 = "abandon_mission";
    else
        var_7 = "turn_back";

    for (;;)
    {
        var_8 = 0;

        if ( var_3 )
            var_8 = var_0 istouching( var_1 );
        else
            var_8 = !var_0 istouching( var_2 );

        var_9 = var_0 isonground();
        var_10 = var_0 isonladder();
        var_11 = scripts\cp\cp_laststand::player_in_laststand( var_0 );

        if ( !var_9 || var_11 || var_10 )
        {
            wait 0.5;
            continue;
        }

        if ( var_8 )
        {
            var_0.last_good_pos = var_0.origin;
            var_6 = undefined;

            if ( var_0.outofbounds )
                var_0 thread hint_prompt( var_7, 0 );

            var_0.outofbounds = 0;
        }
        else if ( !var_0.outofbounds )
        {
            var_0 thread hint_prompt( var_7, 1 );
            var_0.outofbounds = 1;
            var_6 = gettime() + 5000;
        }
        else if ( isdefined( var_6 ) && gettime() > var_6 )
        {
            if ( isdefined( var_0.hostagecarried ) && isdefined( level.hostage ) && isdefined( level.hostage_drop ) )
                level.hostage [[ level.hostage_drop ]]( var_0, level.hostage, var_0.last_good_pos, 0, 0.4 );

            var_0 dodamage( var_0.health + 1000, var_0.origin, var_1, var_1, "MOD_UNKNOWN" );
            var_0 thread hint_prompt( var_7, 0 );
            var_0 thread warp_to_last_good_pos();
        }

        wait 0.5;
    }
}

warp_to_last_good_pos()
{
    self setorigin( self.last_good_pos );
}

updatelaststandpistol( var_0 )
{
    if ( isdefined( var_0 ) )
    {
        if ( isdefined( level.last_stand_weapons ) )
        {
            var_1 = getweaponbasename( var_0 );

            if ( scripts\engine\utility::array_contains( level.last_stand_weapons, var_1 ) )
            {
                self.last_stand_pistol = var_0;
                return;
            }
        }
    }

    var_2 = self getweaponslistall();
    var_3 = 0;

    if ( isdefined( self.last_stand_pistol ) )
    {
        var_4 = getweaponbasename( self.last_stand_pistol );

        foreach ( var_6 in var_2 )
        {
            var_7 = getweaponbasename( var_6 );

            if ( var_7 == var_4 )
            {
                var_3 = 1;
                return;
            }
        }
    }

    if ( !var_3 )
    {
        if ( isdefined( level.last_stand_weapons ) )
        {
            foreach ( var_6 in var_2 )
            {
                var_7 = getweaponbasename( var_6 );

                for ( var_10 = level.last_stand_weapons.size - 1; var_10 > -1; var_10-- )
                {
                    if ( var_7 == level.last_stand_weapons[var_10] )
                    {
                        var_3 = 1;
                        self.last_stand_pistol = var_6;
                        return;
                    }
                }
            }
        }

        var_12 = getrawbaseweaponname( self.default_starting_pistol );

        if ( isdefined( self.weapon_build_models ) && isdefined( self.weapon_build_models[var_12] ) )
            self.last_stand_pistol = asmdevgetallstates( self.weapon_build_models[var_12] );
        else
            self.last_stand_pistol = self.default_starting_pistol;
    }
}

giveperk( var_0 )
{
    if ( issubstr( var_0, "specialty_weapon_" ) )
    {
        _setperk( var_0 );
        return;
    }

    _setperk( var_0 );
    _setextraperks( var_0 );
}

_hasperk( var_0 )
{
    var_1 = self.perks;

    if ( !isdefined( var_1 ) )
        return 0;

    if ( isdefined( var_1[var_0] ) )
        return 1;

    return 0;
}

takeperk( var_0 )
{
    if ( issubstr( var_0, "specialty_weapon_" ) )
    {
        _unsetperk( var_0 );
        return;
    }

    _unsetperk( var_0 );
    _unsetextraperks( var_0 );
}

_setperk( var_0 )
{
    self.perks[var_0] = 1;
    self.perksperkname[var_0] = var_0;
    var_1 = level.perksetfuncs[var_0];

    if ( isdefined( var_1 ) )
        self thread [[ var_1 ]]();

    self setperk( var_0, !isdefined( level.scriptperks[var_0] ) );
}

_setextraperks( var_0 )
{
    if ( isdefined( level.extraperkmap[var_0] ) )
    {
        foreach ( var_2 in level.extraperkmap[var_0] )
        {
            _setperk( var_2 );
            _setextraperks( var_2 );
        }
    }
}

_unsetperk( var_0 )
{
    self.perks[var_0] = undefined;
    self.perksperkname[var_0] = undefined;

    if ( isdefined( level.perkunsetfuncs[var_0] ) )
        self thread [[ level.perkunsetfuncs[var_0] ]]();

    self unsetperk( var_0, !isdefined( level.scriptperks[var_0] ) );
}

_unsetextraperks( var_0 )
{
    if ( isdefined( level.extraperkmap[var_0] ) )
    {
        foreach ( var_2 in level.extraperkmap[var_0] )
        {
            _unsetperk( var_2 );
            _unsetextraperks( var_2 );
        }
    }
}

_clearperks()
{
    foreach ( var_2, var_1 in self.perks )
    {
        if ( isdefined( level.perkunsetfuncs[var_2] ) )
            self [[ level.perkunsetfuncs[var_2] ]]();
    }

    self.perks = [];
    self.perksperkname = [];
    self clearperks();
}

clearlowermessages()
{
    if ( isdefined( self.lowermessages ) )
    {
        for ( var_0 = 0; var_0 < self.lowermessages.size; var_0++ )
            self.lowermessages[var_0] = undefined;
    }

    if ( !isdefined( self.lowermessage ) )
        return;

    updatelowermessage();
}

setlowermessage( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9 )
{
    if ( !isdefined( var_3 ) )
        var_3 = 1;

    if ( !isdefined( var_2 ) )
        var_2 = 0;

    if ( !isdefined( var_4 ) )
        var_4 = 0;

    if ( !isdefined( var_5 ) )
        var_5 = 0;

    if ( !isdefined( var_6 ) )
        var_6 = 0.85;

    if ( !isdefined( var_7 ) )
        var_7 = 3.0;

    if ( !isdefined( var_8 ) )
        var_8 = 0;

    if ( !isdefined( var_9 ) )
        var_9 = 1;

    addlowermessage( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9 );
    updatelowermessage();
}

play_bink_video( var_0, var_1, var_2 )
{
    level thread play_bink_video_internal( var_0, var_1, var_2 );
}

play_bink_video_internal( var_0, var_1, var_2 )
{
    foreach ( var_4 in level.players )
        var_4 freezecontrolswrapper( 1 );

    playcinematicforall( var_0 );
    wait( var_1 );

    foreach ( var_4 in level.players )
    {
        var_4 freezecontrolswrapper( 0 );

        if ( !isdefined( var_2 ) || !var_2 )
            var_4 thread player_black_screen( 0, 1, 0.5, 1 );
    }
}

updatelowermessage()
{
    self endon( "disconnect" );

    if ( !isdefined( self ) )
        return;

    var_0 = getlowermessage();

    if ( !isdefined( var_0 ) )
    {
        if ( isdefined( self.lowermessage ) )
        {
            self.lowermessage.alpha = 0;
            self.lowermessage settext( "" );

            if ( isdefined( self.lowertimer ) )
                self.lowertimer.alpha = 0;
        }
    }
    else
    {
        self.lowermessage settext( var_0.text );
        self.lowermessage.alpha = 0.85;
        self.lowertimer.alpha = 1;
        self.lowermessage.hidewhenindemo = var_0.hidewhenindemo;
        self.lowermessage.hidewheninmenu = var_0.hidewheninmenu;

        if ( var_0.shouldfade )
        {
            self.lowermessage fadeovertime( min( var_0.fadetoalphatime, 60 ) );
            self.lowermessage.alpha = var_0.fadetoalpha;
        }

        if ( var_0.time > 0 && var_0.showtimer )
            self.lowertimer settimer( max( var_0.time - ( gettime() - var_0.addtime ) / 1000, 0.1 ) );
        else
        {
            if ( var_0.time > 0 && !var_0.showtimer )
            {
                self.lowertimer settext( "" );
                self.lowermessage fadeovertime( min( var_0.time, 60 ) );
                self.lowermessage.alpha = 0;
                thread clearondeath( var_0 );
                thread clearafterfade( var_0 );
                return;
            }

            self.lowertimer settext( "" );
        }
    }
}

addlowermessage( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9 )
{
    var_10 = undefined;

    foreach ( var_12 in self.lowermessages )
    {
        if ( var_12.name == var_0 )
        {
            if ( var_12.text == var_1 && var_12.priority == var_3 )
                return;

            var_10 = var_12;
            break;
        }
    }

    if ( !isdefined( var_10 ) )
    {
        var_10 = spawnstruct();
        self.lowermessages[self.lowermessages.size] = var_10;
    }

    var_10.name = var_0;
    var_10.text = var_1;
    var_10.time = var_2;
    var_10.addtime = gettime();
    var_10.priority = var_3;
    var_10.showtimer = var_4;
    var_10.shouldfade = var_5;
    var_10.fadetoalpha = var_6;
    var_10.fadetoalphatime = var_7;
    var_10.hidewhenindemo = var_8;
    var_10.hidewheninmenu = var_9;
    sortlowermessages();
}

sortlowermessages()
{
    for ( var_0 = 1; var_0 < self.lowermessages.size; var_0++ )
    {
        var_1 = self.lowermessages[var_0];
        var_2 = var_1.priority;

        for ( var_3 = var_0 - 1; var_3 >= 0 && var_2 > self.lowermessages[var_3].priority; var_3-- )
            self.lowermessages[var_3 + 1] = self.lowermessages[var_3];

        self.lowermessages[var_3 + 1] = var_1;
    }
}

getlowermessage()
{
    if ( !isdefined( self.lowermessages ) )
        return undefined;

    return self.lowermessages[0];
}

clearondeath( var_0 )
{
    self notify( "message_cleared" );
    self endon( "message_cleared" );
    self endon( "disconnect" );
    level endon( "game_ended" );
    self waittill( "death" );
    clearlowermessage( var_0.name );
}

clearafterfade( var_0 )
{
    wait( var_0.time );
    clearlowermessage( var_0.name );
    self notify( "message_cleared" );
}

clearlowermessage( var_0 )
{
    removelowermessage( var_0 );
    updatelowermessage();
}

removelowermessage( var_0 )
{
    if ( isdefined( self.lowermessages ) )
    {
        for ( var_1 = self.lowermessages.size; var_1 > 0; var_1-- )
        {
            if ( self.lowermessages[var_1 - 1].name != var_0 )
                continue;

            var_2 = self.lowermessages[var_1 - 1];

            for ( var_3 = var_1; var_3 < self.lowermessages.size; var_3++ )
            {
                if ( isdefined( self.lowermessages[var_3] ) )
                    self.lowermessages[var_3 - 1] = self.lowermessages[var_3];
            }

            self.lowermessages[self.lowermessages.size - 1] = undefined;
        }

        sortlowermessages();
    }
}

freezecontrolswrapper( var_0 )
{
    if ( isdefined( level.hostmigrationtimer ) )
    {
        self.hostmigrationcontrolsfrozen = 1;
        self freezecontrols( 1 );
        return;
    }

    self freezecontrols( var_0 );
    self.controlsfrozen = var_0;
}

setthirdpersondof( var_0 )
{
    if ( var_0 )
        self setdepthoffield( 0, 110, 512, 4096, 6, 1.8 );
    else
        self setdepthoffield( 0, 0, 512, 512, 4, 0 );
}

setusingremote( var_0 )
{
    if ( isdefined( self.carryicon ) )
        self.carryicon.alpha = 0;

    self.usingremote = var_0;

    if ( scripts\common\utility::is_offhand_weapons_allowed() )
        scripts\common\utility::allow_offhand_weapons( 0 );

    self notify( "using_remote" );
    self setclientomnvar( "ui_using_killstreak_remote", 1 );
    self notify( "using_remote" );
}

isusingremote()
{
    return isdefined( self.usingremote );
}

updatesessionstate( var_0, var_1 )
{
    self.sessionstate = var_0;

    if ( !isdefined( var_1 ) )
        var_1 = "";

    self.statusicon = var_1;
    self setclientomnvar( "ui_session_state", var_0 );
}

getuniqueid()
{
    if ( isdefined( self.pers["guid"] ) )
        return self.pers["guid"];

    var_0 = self getguid();

    if ( var_0 == "0000000000000000" )
    {
        if ( isdefined( level.guidgen ) )
            level.guidgen++;
        else
            level.guidgen = 1;

        var_0 = "script" + level.guidgen;
    }

    self.pers["guid"] = var_0;
    return self.pers["guid"];
}

gameflagset( var_0 )
{
    game["flags"][var_0] = 1;
    level notify( var_0 );
}

gameflaginit( var_0, var_1 )
{
    game["flags"][var_0] = var_1;
}

gameflag( var_0 )
{
    return game["flags"][var_0];
}

gameflagwait( var_0 )
{
    while ( !gameflag( var_0 ) )
        level waittill( var_0 );
}

matchmakinggame()
{
    return level.onlinegame && !getdvarint( "LSTLQTSSRM" );
}

inovertime()
{
    return isdefined( game["status"] ) && game["status"] == "overtime";
}

initlevelflags()
{
    if ( !isdefined( level.levelflags ) )
        level.levelflags = [];
}

initgameflags()
{
    if ( !isdefined( game["flags"] ) )
        game["flags"] = [];
}

isenemy( var_0 )
{
    if ( level.teambased )
        return isplayeronenemyteam( var_0 );
    else
        return isplayerffaenemy( var_0 );
}

isplayeronenemyteam( var_0 )
{
    return var_0.team != self.team;
}

isplayerffaenemy( var_0 )
{
    if ( isdefined( var_0.owner ) )
        return var_0.owner != self;
    else
        return var_0 != self;
}

isgameplayteam( var_0 )
{
    return isdefined( var_0 ) && scripts\engine\utility::array_contains( level.teamnamelist, var_0 );
}

notusableforjoiningplayers( var_0 )
{
    self notify( "notusablejoiningplayers" );
    self endon( "death" );
    level endon( "game_ended" );
    var_0 endon( "disconnect" );
    var_0 endon( "death" );
    self endon( "notusablejoiningplayers" );

    for (;;)
    {
        level waittill( "player_spawned", var_1 );

        if ( isdefined( var_1 ) && var_1 != var_0 )
            self disableplayeruse( var_1 );
    }
}

setselfusable( var_0 )
{
    self makeusable();

    foreach ( var_2 in level.players )
    {
        if ( var_2 != var_0 )
        {
            self disableplayeruse( var_2 );
            continue;
        }

        self enableplayeruse( var_2 );
    }
}

isenvironmentweapon( var_0 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    if ( issameweapon( var_0 ) )
    {
        if ( var_0.basename == "turret_minigun_mp" )
            return 1;
        else
            return 0;
    }

    if ( var_0 == "turret_minigun_mp" )
        return 1;

    return 0;
}

issuperweapon( var_0 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    var_1 = undefined;

    if ( issameweapon( var_0 ) )
        var_1 = createheadicon( var_0 );
    else
        var_1 = var_0;

    if ( isdefined( level.superweapons ) && isdefined( level.superweapons[var_1] ) )
        return 1;

    return 0;
}

strip_suffix( var_0, var_1 )
{
    if ( var_0.size <= var_1.size )
        return var_0;

    if ( getsubstr( var_0, var_0.size - var_1.size, var_0.size ) == var_1 )
        return getsubstr( var_0, 0, var_0.size - var_1.size );

    return var_0;
}

playteamfxforclient( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    var_6 = undefined;

    if ( self.team != var_0 )
        var_6 = spawnfxforclient( scripts\engine\utility::getfx( var_3 ), var_1, self );
    else
        var_6 = spawnfxforclient( scripts\engine\utility::getfx( var_2 ), var_1, self );

    if ( isdefined( var_6 ) )
        triggerfx( var_6 );

    var_6 thread delayentdelete( var_4 );

    if ( isdefined( var_5 ) && var_5 )
        var_6 thread deleteonplayerdeathdisconnect( self );

    return var_6;
}

toggle_team_emp_effects( var_0, var_1, var_2, var_3 )
{
    var_4 = [];

    foreach ( var_6 in level.players )
    {
        if ( !var_6 scripts\cp_mp\utility\player_utility::_isalive() )
            continue;

        if ( var_6.team != var_0 )
            continue;

        var_4[var_4.size] = var_6;
    }

    if ( istrue( var_1 ) )
    {
        foreach ( var_6 in var_4 )
            thread toggle_player_emp_effects( var_6, 1, var_2 );
    }
    else
    {
        foreach ( var_6 in var_4 )
            thread toggle_player_emp_effects( var_6, 0 );
    }
}

toggle_player_emp_effects( var_0, var_1, var_2 )
{
    if ( istrue( var_1 ) )
    {
        var_3 = getcompleteweaponname( "emp_drone_non_player_mp" );
        var_4 = scripts\cp_mp\utility\damage_utility::packdamagedata;
        var_5 = [[ var_4 ]]( var_0, var_0, 1, var_3 );
        var_0 thread _emp_grenade_apply_player( var_5, var_2 );
    }
    else
        var_0 notify( "emp_cleared" );
}

_emp_grenade_apply_player( var_0, var_1 )
{
    scripts\cp_mp\emp_debuff::apply_emp_struct( var_0 );
    _emp_grenade_end_early( var_0, var_1 );

    if ( isdefined( var_0.victim ) )
        var_0.victim scripts\cp_mp\emp_debuff::remove_emp();
}

_emp_grenade_end_early( var_0, var_1 )
{
    var_0.victim endon( "death_or_disconnect" );
    level endon( "game_ended" );

    if ( isdefined( var_1 ) )
        var_2 = scripts\engine\utility::waittill_notify_or_timeout_return( "emp_cleared", var_1 );
    else
        self waittill( "emp_cleared" );
}

delayentdelete( var_0 )
{
    self endon( "death" );
    wait( var_0 );

    if ( isdefined( self ) )
        self delete();
}

deleteonplayerdeathdisconnect( var_0 )
{
    self endon( "death" );
    var_0 scripts\engine\utility::_id_12E3F( "death", "disconnect" );
    self delete();
}

isstrstart( var_0, var_1 )
{
    return getsubstr( var_0, 0, var_1.size ) == var_1;
}

getbaseweaponname( var_0 )
{
    if ( issameweapon( var_0 ) )
        var_1 = var_0.basename;
    else
        var_1 = var_0;

    var_2 = strtok( var_1, "_" );
    var_3 = 0;

    if ( var_2[0] == "alt" )
        var_3++;

    if ( var_2[var_3] == "iw7" )
        var_1 = var_2[var_3] + "_" + var_2[var_3 + 1];
    else if ( var_2[var_3] == "iw8" )
    {
        var_4 = [ "ar", "sm", "lm", "sh", "sn", "dm", "pi", "la" ];

        if ( scripts\engine\utility::array_contains( var_4, var_2[var_3 + 1] ) )
            var_1 = var_2[var_3] + "_" + var_2[var_3 + 1] + "_" + var_2[var_3 + 2];
        else
            var_1 = var_2[var_3] + "_" + var_2[var_3 + 1];
    }

    return var_1;
}

getzbaseweaponname( var_0, var_1 )
{
    var_2 = strtok( var_0, "_" );

    if ( var_2[0] == "iw5" || var_2[0] == "iw6" || var_2[0] == "iw7" )
    {
        if ( isdefined( var_1 ) && var_1 > 1 )
            var_0 = var_2[0] + "_z" + var_2[1] + var_1;
        else
            var_0 = var_2[0] + "_z" + var_2[1];
    }
    else if ( var_2[0] == "alt" )
    {
        if ( isdefined( var_1 ) && var_1 > 1 )
            var_0 = var_2[1] + "_z" + var_2[2] + var_1;
        else
            var_0 = var_2[1] + "_z" + var_2[2];
    }

    return var_0;
}

get_closest_entrance( var_0 )
{
    if ( !isdefined( level.window_entrances ) )
        return undefined;

    var_1 = sortbydistance( level.window_entrances, var_0 );

    foreach ( var_3 in var_1 )
    {
        if ( var_3.enabled )
            return var_3;
    }

    return undefined;
}

entrance_is_fully_repaired( var_0 )
{
    if ( !isdefined( var_0.barrier ) )
        return 1;

    var_1 = [[ level.next_board_to_repair_func ]]( var_0 );

    if ( !isdefined( var_1 ) )
        return 1;

    return 0;
}

is_weapon_purchase_disabled()
{
    return istrue( level.weapon_purchase_disabled );
}

get_attachment_from_interaction( var_0 )
{
    var_1 = var_0.item.model;
    var_2 = "arkblue";
    var_3 = "stun_ammo";

    switch ( var_1 )
    {
        case "attachment_zmb_arcane_muzzlebrake_wm":
            var_2 = "arcane_base";
            break;
        default:
            break;
    }

    return var_2;
}

are_any_consumables_active()
{
    foreach ( var_2, var_1 in self.consumables )
    {
        if ( var_1.on == 1 )
            return 1;
    }

    return 0;
}

getrawbaseweaponname( var_0 )
{
    if ( issameweapon( var_0 ) )
        var_1 = var_0.basename;
    else
        var_1 = var_0;

    var_2 = strtok( var_1, "_" );

    if ( var_2[0] == "iw5" || var_2[0] == "iw6" || var_2[0] == "iw7" )
        var_1 = var_2[1];
    else if ( var_2[0] == "alt" )
        var_1 = var_2[2];

    return var_1;
}

getintproperty( var_0, var_1 )
{
    var_2 = var_1;
    var_2 = getdvarint( var_0, var_1 );
    return var_2;
}

leaderdialogonplayer( var_0, var_1, var_2, var_3 )
{
    if ( !isdefined( game["dialog"][var_0] ) )
        return;

    var_4 = self.pers["team"];

    if ( isdefined( var_4 ) && ( var_4 == "axis" || var_4 == "allies" ) )
    {
        var_5 = game["voice"][var_4] + game["dialog"][var_0];
        self queuedialogforplayer( var_5, var_0, 2, var_1, var_2, var_3 );
    }
}

_setactionslot( var_0, var_1, var_2 )
{
    self.saved_actionslotdata[var_0].type = var_1;
    self.saved_actionslotdata[var_0].item = var_2;
    self setactionslot( var_0, var_1, var_2 );
}

getkillstreakweapon( var_0 )
{
    return tablelookup( level.global_tables["killstreakTable"].path, level.global_tables["killstreakTable"].ref_col, var_0, level.global_tables["killstreakTable"].weapon_col );
}

_objective_delete( var_0 )
{
    objective_delete( var_0 );

    if ( !isdefined( level.reclaimedreservedobjectives ) )
    {
        level.reclaimedreservedobjectives = [];
        level.reclaimedreservedobjectives[0] = var_0;
    }
    else
        level.reclaimedreservedobjectives[level.reclaimedreservedobjectives.size] = var_0;
}

touchingbadtrigger( var_0 )
{
    var_1 = getentarray( "trigger_hurt", "classname" );

    foreach ( var_3 in var_1 )
    {
        if ( self istouching( var_3 ) && ( level.mapname != "mp_mine" || var_3.dmg > 0 ) )
            return 1;
    }

    var_5 = getentarray( "radiation", "targetname" );

    foreach ( var_3 in var_5 )
    {
        if ( self istouching( var_3 ) )
            return 1;
    }

    if ( isdefined( var_0 ) && var_0 == "gryphon" )
    {
        var_8 = getentarray( "gryphonDeath", "targetname" );

        foreach ( var_3 in var_8 )
        {
            if ( self istouching( var_3 ) )
                return 1;
        }
    }

    return 0;
}

playsoundinspace( var_0, var_1, var_2 )
{
    if ( isdefined( var_0 ) )
    {
        if ( isarray( var_0 ) )
            var_0 = scripts\engine\utility::random( var_0 );

        var_3 = lookupsoundlength( var_0 );
        playsoundatpos( var_1, var_0 );

        if ( isdefined( var_2 ) )
            wait( var_3 / 1000 );

        return var_3;
    }
}

play_random_sound_in_space( var_0, var_1, var_2 )
{
    if ( isdefined( var_0 ) )
    {
        if ( !isarray( var_0 ) )
        {
            var_3 = [];
            var_3[0] = var_0;
            var_0 = var_3[0];
        }

        var_4 = scripts\engine\utility::random( var_0 );
        var_5 = lookupsoundlength( var_4 );
        playsoundatpos( var_1, var_4 );

        if ( isdefined( var_2 ) )
            wait( var_5 );

        return var_5;
    }
}

play_looping_sound_on_ent( var_0 )
{
    if ( soundexists( var_0 ) )
        self playloopsound( var_0 );
}

stop_looping_sound_on_ent( var_0 )
{
    if ( soundexists( var_0 ) )
        self stoploopsound( var_0 );
}

playdeathsound()
{
    var_0 = randomintrange( 1, 8 );
    var_1 = "generic";

    if ( self hasfemalecustomizationmodel() )
        var_1 = "female";

    if ( self.team == "axis" )
    {
        var_2 = var_1 + "_death_russian_" + var_0;

        if ( soundexists( var_2 ) )
            self playsound( var_2 );
    }
    else
    {
        var_2 = var_1 + "_death_american_" + var_0;

        if ( soundexists( var_2 ) )
            self playsound( var_2 );
    }
}

isfmjdamage( var_0, var_1, var_2 )
{
    return isdefined( var_2 ) && var_2 _hasperk( "specialty_armorpiercing" ) && isdefined( var_1 ) && scripts\engine\utility::isbulletdamage( var_1 );
}

ischangingweapon()
{
    return isdefined( self.changingweapon );
}

getattachmenttype( var_0 )
{
    if ( !isdefined( var_0 ) )
        return "none";

    var_1 = tablelookup( "mp/attachmenttable.csv", 4, var_0, 2 );

    if ( !isdefined( var_1 ) || isdefined( var_1 ) && var_1 == "" )
    {
        var_2 = getdvar( "NKTMKRMSKR" );

        if ( var_2 == "zombie" )
            var_1 = tablelookup( "cp/zombies/zombie_attachmentTable.csv", 4, var_0, 2 );
    }

    return var_1;
}

weaponhasattachment( var_0, var_1 )
{
    if ( !isdefined( var_0 ) || var_0 == "none" || var_0 == "" )
        return 0;

    var_2 = getweaponattachmentsbasenames( var_0 );

    foreach ( var_4 in var_2 )
    {
        if ( var_4 == var_1 )
            return 1;
    }

    return 0;
}

getweaponattachmentsbasenames( var_0 )
{
    var_1 = getweaponattachments( var_0 );

    foreach ( var_4, var_3 in var_1 )
        var_1[var_4] = attachmentmap_tobase( var_3 );

    return var_1;
}

attachmentmap_tobase( var_0 )
{
    if ( isdefined( level.attachmentmap_uniquetobase[var_0] ) )
        var_0 = level.attachmentmap_uniquetobase[var_0];

    return var_0;
}

random_loot_override( var_0 )
{
    return scripts\engine\utility::string_starts_with( var_0, "barsil_" ) || var_0 == "barcust2_mpapa5";
}

randomcarepackagedrops( var_0 )
{
    return scripts\engine\utility::string_starts_with( var_0, "silencer" );
}

projectiledeleteonnote( var_0 )
{
    return var_0 == "calcust" || var_0 == "calsmg" || var_0 == "calsmgdrums";
}

isjuggernaut()
{
    if ( isdefined( self.unittype ) && self.unittype == "juggernaut" )
        return 1;

    if ( isdefined( self.isjuggernaut ) && self.isjuggernaut == 1 )
        return 1;

    if ( isdefined( self.isjuggernautdef ) && self.isjuggernautdef == 1 )
        return 1;

    if ( isdefined( self.isjuggernautgl ) && self.isjuggernautgl == 1 )
        return 1;

    if ( isdefined( self.isjuggernautrecon ) && self.isjuggernautrecon == 1 )
        return 1;

    if ( isdefined( self.isjuggernautmaniac ) && self.isjuggernautmaniac == 1 )
        return 1;

    if ( isdefined( self.isjuggernautlevelcustom ) && self.isjuggernautlevelcustom == 1 )
        return 1;

    return 0;
}

attachmentmap_tounique( var_0, var_1 )
{
    var_2 = undefined;

    if ( issameweapon( var_1 ) )
        var_2 = createheadicon( var_1 );
    else
        var_2 = var_1;

    var_3 = getweaponrootname( var_1 );

    if ( var_3 != var_2 )
    {
        var_4 = getweaponbasename( var_1 );

        if ( isdefined( level.attachmentmap_basetounique[var_4] ) && isdefined( level.attachmentmap_uniquetobase[var_0] ) && isdefined( level.attachmentmap_basetounique[var_4][level.attachmentmap_uniquetobase[var_0]] ) )
        {
            var_5 = level.attachmentmap_uniquetobase[var_0];
            return level.attachmentmap_basetounique[var_4][var_5];
        }
        else if ( isdefined( level.attachmentmap_basetounique[var_4] ) && isdefined( level.attachmentmap_basetounique[var_4][var_0] ) )
            return level.attachmentmap_basetounique[var_4][var_0];
        else
        {
            var_6 = strtok( var_4, "_" );

            if ( var_6.size > 3 )
            {
                var_7 = var_6[0] + "_" + var_6[1] + "_" + var_6[2];

                if ( isdefined( level.attachmentmap_basetounique[var_7] ) && isdefined( level.attachmentmap_basetounique[var_7][var_0] ) )
                    return level.attachmentmap_basetounique[var_7][var_0];
            }
        }
    }

    if ( isdefined( level.attachmentmap_basetounique[var_3] ) && isdefined( level.attachmentmap_basetounique[var_3][var_0] ) )
        return level.attachmentmap_basetounique[var_3][var_0];
    else
    {
        var_8 = weapongroupmap( var_3 );

        if ( isdefined( level.attachmentmap_basetounique[var_8] ) && isdefined( level.attachmentmap_basetounique[var_8][var_0] ) )
            return level.attachmentmap_basetounique[var_8][var_0];
    }

    return var_0;
}

weapongroupmap( var_0 )
{
    if ( isdefined( level.weaponmapdata[var_0] ) && isdefined( level.weaponmapdata[var_0].group ) )
        return level.weaponmapdata[var_0].group;

    return undefined;
}

weaponnumbermap( var_0 )
{
    if ( isdefined( level.weaponmapdata[var_0] ) && isdefined( level.weaponmapdata[var_0].number ) )
        return level.weaponmapdata[var_0].number;

    return undefined;
}

allowridekillstreakplayerexit( var_0, var_1 )
{
    if ( isdefined( var_0 ) )
        self endon( var_0 );

    if ( isdefined( var_1 ) )
        var_2 = self;
    else
    {
        if ( !isdefined( self.owner ) )
            return;

        var_2 = self.owner;
    }

    level endon( "game_ended" );
    var_2 endon( "disconnect" );
    var_2 endon( "end_remote" );
    var_2 notify( "watch_use_exit" );
    var_2 endon( "diable_use_exit" );
    self endon( "death" );
    thread allow_force_player_exit();

    if ( !isdefined( level.framedurationseconds ) )
        level.framedurationseconds = level.frameduration / 1000;

    var_3 = level.framedurationseconds;
    var_4 = 0.75;
    var_5 = 1;

    for (;;)
    {
        var_6 = 0;

        if ( var_5 == 1 )
        {
            var_2 setclientomnvar( "ui_exit_progress", 0 );
            var_5 = 0;
        }

        while ( var_2 usebuttonpressed() )
        {
            var_6 = var_6 + var_3;
            var_5 = 1;
            var_2 setclientomnvar( "ui_exit_progress", var_6 / var_4 );

            if ( var_6 > var_4 )
            {
                self notify( "killstreakExit" );
                return;
            }

            wait( var_3 );
        }

        wait( var_3 );
    }
}

allow_force_player_exit()
{
    self endon( "killstreakExit" );
    level waittill( "cp_force_killstreak_exit" );
    self notify( "killstreakExit" );
}

killstreak_createobjective( var_0, var_1, var_2, var_3, var_4 )
{
    var_5 = nonobjective_requestobjectiveid( 1 );
    objective_position( var_5, self.origin );
    objective_icon( var_5, var_0 );
    objective_state( var_5, "active" );
    objective_setbackground( var_5, 1 );

    if ( !isdefined( self getlinkedparent() ) && !istrue( var_3 ) )
        update_objective_position( var_5, self.origin );
    else if ( istrue( var_3 ) && istrue( var_4 ) )
        update_objective_onentitywithrotation( var_5, self );
    else
        update_objective_onentity( var_5, self );

    if ( isdefined( var_1 ) )
    {
        objective_setownerteam( var_5, var_1 );

        if ( !level.teambased && isdefined( self.owner ) )
        {
            if ( istrue( var_2 ) )
                scripts\mp\objidpoolmanager::objective_mask_showtoplayerteam( var_5, self.owner );
            else
                scripts\mp\objidpoolmanager::objective_teammask_single( var_5, var_1 );
        }
    }
    else
        scripts\mp\objidpoolmanager::objective_playermask_showtoall( var_5 );

    return var_5;
}

reload_handle_hintstring( var_0, var_1, var_2 )
{
    var_3 = nonobjective_requestobjectiveid( 1 );

    if ( var_3 == -1 )
        return -1;

    objective_delete( var_3 );
    objective_state( var_3, "invisible" );
    objective_position( var_3, ( 0, 0, 0 ) );

    if ( !isdefined( self getlinkedparent() ) && !istrue( var_1 ) )
        update_objective_position( var_3, self.origin );
    else if ( istrue( var_1 ) && istrue( var_2 ) )
        update_objective_onentitywithrotation( var_3, self );
    else
        update_objective_onentity( var_3, self );

    objective_state( var_3, "active" );
    objective_icon( var_3, var_0 );
    objective_setbackground( var_3, 1 );
    objective_setownerteam( var_3, self.team );
    scripts\cp\cp_objectives::minimap_objective_playermask_hidefromall( var_3 );
    return var_3;
}

update_objective_position( var_0, var_1 )
{
    if ( var_0 == -1 )
        return;

    objective_position( var_0, var_1 );
}

update_objective_onentity( var_0, var_1 )
{
    if ( var_0 == -1 )
        return;

    objective_onentity( var_0, var_1 );
}

update_objective_onentitywithrotation( var_0, var_1 )
{
    if ( var_0 == -1 )
        return;

    objective_onentity( var_0, var_1 );
    objective_setrotateonminimap( var_0, 1 );
}

nonobjective_returnobjectiveid( var_0 )
{
    scripts\cp\cp_objectives::freeworldidbyobjid( var_0 );
}

nonobjective_requestobjectiveid( var_0 )
{
    return scripts\cp\cp_objectives::requestworldid( "nonobj_marker", 1 );
}

clearusingremote( var_0 )
{
    scripts\common\utility::allow_vehicle_use( 1 );
    scripts\common\utility::allow_crate_use( 1 );
    scripts\common\utility::allow_ads( 1 );

    if ( isdefined( self.carryicon ) )
        self.carryicon.alpha = 1;

    self.usingremote = undefined;

    if ( !isdefined( var_0 ) )
    {
        scripts\common\utility::allow_offhand_weapons( 1 );
        _freezecontrols( 0 );
    }

    self setclientomnvar( "ui_using_killstreak_remote", 0 );
    self notify( "stopped_using_remote" );
}

cp_add_dialogue_line( var_0 )
{
    if ( getdvarint( "loc_warnings", 0 ) )
        return;

    if ( istrue( level.ghostridewhip ) )
        return;

    if ( !isdefined( level.dialogue_huds ) )
        level.dialogue_huds = [];

    if ( level.dialogue_huds.size == 5 )
    {
        var_1 = level.dialogue_huds[0];
        level.dialogue_huds = scripts\engine\utility::array_remove_index( level.dialogue_huds, 0 );
        scripts\engine\utility::update_dialogue_huds();
        var_1 thread scripts\engine\utility::destroy_dialogue_hud();
    }

    if ( soundexists( "cp_ui_menu_title_decode_text" ) )
    {
        foreach ( var_3 in level.players )
            var_3 playlocalsound( "cp_ui_menu_title_decode_text" );
    }

    var_5 = "^3";
    var_6 = 1;

    if ( isdefined( level.dialoguelinescale ) )
        var_6 = level.dialoguelinescale;

    var_7 = newhudelem();
    var_7.elemtype = "font";
    var_7.font = "default";
    var_7.fontscale = var_6;
    var_7.x = 0;
    var_7.y = 0;
    var_7.width = 0;
    var_7.height = int( level.fontheight * var_6 );
    var_7.xoffset = 0;
    var_7.yoffset = 0;
    var_8 = level.dialogue_huds.size;
    level.dialogue_huds[var_8] = var_7;
    var_7.foreground = 1;
    var_7.sort = 20;
    var_7.x = 40;
    var_7.y = 260 + var_8 * ( 12 * var_6 );
    var_7.label = var_0;
    var_7.alpha = 0;
    var_7 fadeovertime( 0.2 );
    var_7.alpha = 1;
    var_7 endon( "death" );
    wait 8;
    level.dialogue_huds = scripts\engine\utility::array_remove( level.dialogue_huds, var_7 );
    scripts\engine\utility::update_dialogue_huds();
    var_7 thread cp_destroy_dialogue_hud();
}

cp_destroy_dialogue_hud()
{
    var_0 = 1;

    if ( isdefined( level.dialoguelinescale ) )
        var_0 = level.dialoguelinescale;

    self endon( "death" );
    self fadeovertime( 0.2 );
    self moveovertime( 0.2 );
    self.y = self.y - 12 * var_0;
    self.alpha = 0;
    wait 0.2;
    self destroy();
}

getfirstprimaryweapon()
{
    var_0 = self getweaponslistprimaries();
    return var_0[0];
}

set_visionset_for_watching_players( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    var_6 = get_players_watching( var_4, var_5 );

    foreach ( var_8 in var_6 )
    {
        var_8 notify( "changing_watching_visionset" );

        if ( isdefined( var_3 ) && var_3 )
            var_8 visionsetmissilecamforplayer( var_0, var_1 );
        else
            var_8 visionsetnakedforplayer( var_0, var_1 );

        if ( var_0 != "" && isdefined( var_2 ) )
        {
            var_8 thread reset_visionset_on_team_change( self, var_1 + var_2 );
            var_8 thread reset_visionset_on_disconnect( self );

            if ( var_8 isinkillcam() )
                var_8 thread reset_visionset_on_spawn();
        }
    }
}

get_players_watching( var_0, var_1 )
{
    if ( !isdefined( var_0 ) )
        var_0 = 0;

    if ( !isdefined( var_1 ) )
        var_1 = 0;

    var_2 = self getentitynumber();
    var_3 = [];

    foreach ( var_5 in level.players )
    {
        if ( var_5 == self )
            continue;

        var_6 = 0;

        if ( !var_1 )
        {
            if ( var_5.team == "spectator" || var_5.sessionstate == "spectator" )
            {
                var_7 = var_5 getspectatingplayer();

                if ( isdefined( var_7 ) && var_7 == self )
                    var_6 = 1;
            }

            if ( var_5.forcespectatorclient == var_2 )
                var_6 = 1;
        }

        if ( !var_0 )
        {
            if ( var_5.killcamentity == var_2 )
                var_6 = 1;
        }

        if ( var_6 )
            var_3[var_3.size] = var_5;
    }

    return var_3;
}

reset_visionset_on_team_change( var_0, var_1 )
{
    self endon( "changing_watching_visionset" );
    var_2 = gettime();
    var_3 = self.team;

    while ( gettime() - var_2 < var_1 * 1000 )
    {
        if ( self.team != var_3 || !scripts\engine\utility::array_contains( var_0 get_players_watching(), self ) )
        {
            self visionsetnakedforplayer( "", 0.0 );
            self notify( "changing_visionset" );
            break;
        }

        wait 0.05;
    }
}

reset_visionset_on_disconnect( var_0 )
{
    self endon( "changing_watching_visionset" );
    var_0 waittill( "disconnect" );

    if ( isdefined( level.vision_set_override ) )
        self visionsetnakedforplayer( level.vision_set_override, 0.0 );
    else
        self visionsetnakedforplayer( "", 0.0 );
}

reset_visionset_on_spawn()
{
    self endon( "disconnect" );
    self waittill( "spawned" );

    if ( isdefined( level.vision_set_override ) )
        self visionsetnakedforplayer( level.vision_set_override, 0.0 );
    else
        self visionsetnakedforplayer( "", 0.0 );
}

isinkillcam()
{
    return self.spectatekillcam;
}

createfontstring( var_0, var_1, var_2 )
{
    if ( !isdefined( var_2 ) || !var_2 )
        var_3 = newclienthudelem( self );
    else
        var_3 = newhudelem();

    var_3.elemtype = "font";
    var_3.font = var_0;
    var_3.fontscale = var_1;
    var_3.basefontscale = var_1;
    var_3.x = 0;
    var_3.y = 0;
    var_3.width = 0;
    var_3.height = int( level.fontheight * var_1 );
    var_3.xoffset = 0;
    var_3.yoffset = 0;
    var_3.children = [];
    var_3 setparent( level.uiparent );
    var_3.hidden = 0;
    return var_3;
}

setparent( var_0 )
{
    if ( isdefined( self.parent ) && self.parent == var_0 )
        return;

    if ( isdefined( self.parent ) )
        self.parent removechild( self );

    self.parent = var_0;
    self.parent addchild( self );

    if ( isdefined( self.point ) )
        setpoint( self.point, self.relativepoint, self.xoffset, self.yoffset );
    else
        setpoint( "TOPLEFT" );
}

removechild( var_0 )
{
    var_0.parent = undefined;

    if ( self.children[self.children.size - 1] != var_0 )
    {
        self.children[var_0.index] = self.children[self.children.size - 1];
        self.children[var_0.index].index = var_0.index;
    }

    self.children[self.children.size - 1] = undefined;
    var_0.index = undefined;
}

addchild( var_0 )
{
    var_0.index = self.children.size;
    self.children[self.children.size] = var_0;
    removedestroyedchildren();
}

removedestroyedchildren()
{
    if ( isdefined( self.childchecktime ) && self.childchecktime == gettime() )
        return;

    self.childchecktime = gettime();
    var_0 = [];

    foreach ( var_3, var_2 in self.children )
    {
        if ( !isdefined( var_2 ) )
            continue;

        var_2.index = var_0.size;
        var_0[var_0.size] = var_2;
    }

    self.children = var_0;
}

setpoint( var_0, var_1, var_2, var_3, var_4 )
{
    if ( !isdefined( var_4 ) )
        var_4 = 0;

    var_5 = getparent();

    if ( var_4 )
        self moveovertime( var_4 );

    if ( !isdefined( var_2 ) )
        var_2 = 0;

    self.xoffset = var_2;

    if ( !isdefined( var_3 ) )
        var_3 = 0;

    self.yoffset = var_3;
    self.point = var_0;
    self.alignx = "center";
    self.aligny = "middle";

    if ( issubstr( var_0, "TOP" ) )
        self.aligny = "top";

    if ( issubstr( var_0, "BOTTOM" ) )
        self.aligny = "bottom";

    if ( issubstr( var_0, "LEFT" ) )
        self.alignx = "left";

    if ( issubstr( var_0, "RIGHT" ) )
        self.alignx = "right";

    if ( !isdefined( var_1 ) )
        var_1 = var_0;

    self.relativepoint = var_1;
    var_6 = "center_adjustable";
    var_7 = "middle";

    if ( issubstr( var_1, "TOP" ) )
        var_7 = "top_adjustable";

    if ( issubstr( var_1, "BOTTOM" ) )
        var_7 = "bottom_adjustable";

    if ( issubstr( var_1, "LEFT" ) )
        var_6 = "left_adjustable";

    if ( issubstr( var_1, "RIGHT" ) )
        var_6 = "right_adjustable";

    if ( var_5 == level.uiparent )
    {
        self.horzalign = var_6;
        self.vertalign = var_7;
    }
    else
    {
        self.horzalign = var_5.horzalign;
        self.vertalign = var_5.vertalign;
    }

    if ( strip_suffix( var_6, "_adjustable" ) == var_5.alignx )
    {
        var_8 = 0;
        var_9 = 0;
    }
    else if ( var_6 == "center" || var_5.alignx == "center" )
    {
        var_8 = int( var_5.width / 2 );

        if ( var_6 == "left_adjustable" || var_5.alignx == "right" )
            var_9 = -1;
        else
            var_9 = 1;
    }
    else
    {
        var_8 = var_5.width;

        if ( var_6 == "left_adjustable" )
            var_9 = -1;
        else
            var_9 = 1;
    }

    self.x = var_5.x + var_8 * var_9;

    if ( strip_suffix( var_7, "_adjustable" ) == var_5.aligny )
    {
        var_10 = 0;
        var_11 = 0;
    }
    else if ( var_7 == "middle" || var_5.aligny == "middle" )
    {
        var_10 = int( var_5.height / 2 );

        if ( var_7 == "top_adjustable" || var_5.aligny == "bottom" )
            var_11 = -1;
        else
            var_11 = 1;
    }
    else
    {
        var_10 = var_5.height;

        if ( var_7 == "top_adjustable" )
            var_11 = -1;
        else
            var_11 = 1;
    }

    self.y = var_5.y + var_10 * var_11;
    self.x = self.x + self.xoffset;
    self.y = self.y + self.yoffset;

    switch ( self.elemtype )
    {
        case "bar":
            setpointbar( var_0, var_1, var_2, var_3 );
            break;
    }

    updatechildren();
}

getparent()
{
    return self.parent;
}

setpointbar( var_0, var_1, var_2, var_3 )
{
    self.bar.horzalign = self.horzalign;
    self.bar.vertalign = self.vertalign;
    self.bar.alignx = "left";
    self.bar.aligny = self.aligny;
    self.bar.y = self.y;

    if ( self.alignx == "left" )
        self.bar.x = self.x;
    else if ( self.alignx == "right" )
        self.bar.x = self.x - self.width;
    else
        self.bar.x = self.x - int( self.width / 2 );

    if ( self.aligny == "top" )
        self.bar.y = self.y;
    else if ( self.aligny == "bottom" )
        self.bar.y = self.y;

    updatebar( self.bar.frac );
}

updatebar( var_0, var_1 )
{
    if ( self.elemtype == "bar" )
        updatebarscale( var_0, var_1 );
}

updatebarscale( var_0, var_1 )
{
    var_2 = int( self.width * var_0 + 0.5 );

    if ( !var_2 )
        var_2 = 1;

    self.bar.frac = var_0;
    self.bar setshader( self.bar.shader, var_2, self.height );

    if ( isdefined( var_1 ) && var_2 < self.width )
    {
        if ( var_1 > 0 )
            self.bar scaleovertime( ( 1 - var_0 ) / var_1, self.width, self.height );
        else if ( var_1 < 0 )
            self.bar scaleovertime( var_0 / ( -1 * var_1 ), 1, self.height );
    }

    self.bar.rateofchange = var_1;
    self.bar.lastupdatetime = gettime();
}

updatechildren()
{
    for ( var_0 = 0; var_0 < self.children.size; var_0++ )
    {
        var_1 = self.children[var_0];
        var_1 setpoint( var_1.point, var_1.relativepoint, var_1.xoffset, var_1.yoffset );
    }
}

createicon( var_0, var_1, var_2, var_3 )
{
    if ( !isdefined( var_3 ) )
        var_4 = newclienthudelem( self );
    else
        var_4 = newhudelem();

    var_4.elemtype = "icon";
    var_4.x = 0;
    var_4.y = 0;
    var_4.width = var_1;
    var_4.height = var_2;
    var_4.basewidth = var_4.width;
    var_4.baseheight = var_4.height;
    var_4.xoffset = 0;
    var_4.yoffset = 0;
    var_4.children = [];
    var_4 setparent( level.uiparent );
    var_4.hidden = 0;

    if ( isdefined( var_0 ) )
    {
        var_4 setshader( var_0, var_1, var_2 );
        var_4.shader = var_0;
    }

    return var_4;
}

destroyelem()
{
    var_0 = [];

    for ( var_1 = 0; var_1 < self.children.size; var_1++ )
    {
        if ( isdefined( self.children[var_1] ) )
            var_0[var_0.size] = self.children[var_1];
    }

    for ( var_1 = 0; var_1 < var_0.size; var_1++ )
        var_0[var_1] setparent( getparent() );

    if ( self.elemtype == "bar" || self.elemtype == "bar_shader" )
        self.bar destroy();

    self destroy();
}

showelem()
{
    if ( !self.hidden )
        return;

    self.hidden = 0;

    if ( self.elemtype == "bar" || self.elemtype == "bar_shader" )
    {
        if ( self.alpha != 0.5 )
            self.alpha = 0.5;

        self.bar.hidden = 0;

        if ( self.bar.alpha != 1 )
            self.bar.alpha = 1;
    }
    else if ( self.alpha != 1 )
        self.alpha = 1;
}

hideelem()
{
    if ( self.hidden )
        return;

    self.hidden = 1;

    if ( self.alpha != 0 )
        self.alpha = 0;

    if ( self.elemtype == "bar" || self.elemtype == "bar_shader" )
    {
        self.bar.hidden = 1;

        if ( self.bar.alpha != 0 )
            self.bar.alpha = 0;
    }
}

createprimaryprogressbartext( var_0, var_1, var_2, var_3 )
{
    if ( isagent( self ) )
        return undefined;

    if ( !isdefined( var_0 ) )
        var_0 = 0;

    if ( !isdefined( var_1 ) )
        var_1 = -25;

    if ( self issplitscreenplayer() )
        var_1 = var_1 + 20;

    var_4 = level.primaryprogressbarfontsize;
    var_5 = "default";

    if ( isdefined( var_2 ) )
        var_4 = var_2;

    if ( isdefined( var_3 ) )
        var_5 = var_3;

    var_6 = createfontstring( var_5, var_4 );
    var_6 setpoint( "CENTER", undefined, level.primaryprogressbartextx + var_0, level.primaryprogressbartexty + var_1 );
    var_6.sort = -1;
    return var_6;
}

createprimaryprogressbar( var_0, var_1, var_2, var_3 )
{
    if ( isagent( self ) )
        return undefined;

    if ( !isdefined( var_0 ) )
        var_0 = 0;

    if ( !isdefined( var_1 ) )
        var_1 = -25;

    if ( self issplitscreenplayer() )
        var_1 = var_1 + 20;

    if ( !isdefined( var_2 ) )
        var_2 = level.primaryprogressbarwidth;

    if ( !isdefined( var_3 ) )
        var_3 = level.primaryprogressbarheight;

    var_4 = createbar( ( 1, 1, 1 ), var_2, var_3 );
    var_4 setpoint( "CENTER", undefined, level.primaryprogressbarx + var_0, level.primaryprogressbary + var_1 );
    return var_4;
}

createbar( var_0, var_1, var_2, var_3 )
{
    var_4 = newclienthudelem( self );
    var_4.x = 0;
    var_4.y = 0;
    var_4.frac = 0;
    var_4.color = var_0;
    var_4.sort = -2;
    var_4.shader = "progress_bar_fill";
    var_4 setshader( "progress_bar_fill", var_1, var_2 );
    var_4.hidden = 0;

    if ( isdefined( var_3 ) )
        var_4.flashfrac = var_3;

    var_5 = newclienthudelem( self );
    var_5.elemtype = "bar";
    var_5.width = var_1;
    var_5.height = var_2;
    var_5.xoffset = 0;
    var_5.yoffset = 0;
    var_5.bar = var_4;
    var_5.children = [];
    var_5.sort = -3;
    var_5.color = ( 0, 0, 0 );
    var_5.alpha = 0.5;
    var_5 setparent( level.uiparent );
    var_5 setshader( "progress_bar_bg", var_1 + 4, var_2 + 4 );
    var_5.hidden = 0;
    return var_5;
}

isgameparticipant( var_0 )
{
    if ( isaigameparticipant( var_0 ) )
        return 1;

    if ( isplayer( var_0 ) )
        return 1;

    return 0;
}

isaigameparticipant( var_0 )
{
    if ( isagent( var_0 ) && isdefined( var_0.agent_gameparticipant ) && var_0.agent_gameparticipant == 1 )
        return 1;

    if ( isbot( var_0 ) )
        return 1;

    return 0;
}

setteamheadicon( var_0, var_1 )
{
    if ( !level.teambased )
        return;

    if ( !isdefined( self.entityheadiconteam ) )
    {
        self.entityheadiconteam = "none";
        self.entityheadicon = undefined;
    }

    var_2 = game["entity_headicon_" + var_0];
    self.entityheadiconteam = var_0;

    if ( isdefined( var_1 ) )
        self.entityheadiconoffset = var_1;
    else
        self.entityheadiconoffset = ( 0, 0, 0 );

    self notify( "kill_entity_headicon_thread" );

    if ( var_0 == "none" )
    {
        if ( isdefined( self.entityheadicon ) )
            self.entityheadicon destroy();

        return;
    }

    var_3 = newteamhudelem( var_0 );
    var_3.archived = 1;
    var_3.x = self.origin[0] + self.entityheadiconoffset[0];
    var_3.y = self.origin[1] + self.entityheadiconoffset[1];
    var_3.z = self.origin[2] + self.entityheadiconoffset[2];
    var_3.alpha = 0.8;
    var_3 setshader( var_2, 10, 10 );
    var_3 setwaypoint( 0, 0, 0, 1 );
    self.entityheadicon = var_3;
    thread keepiconpositioned();
    thread destroyheadiconsondeath();
}

setplayerheadicon( var_0, var_1 )
{
    if ( level.teambased )
        return;

    if ( !isdefined( self.entityheadiconteam ) )
    {
        self.entityheadiconteam = "none";
        self.entityheadicon = undefined;
    }

    self notify( "kill_entity_headicon_thread" );

    if ( !isdefined( var_0 ) )
    {
        if ( isdefined( self.entityheadicon ) )
            self.entityheadicon destroy();

        return;
    }

    var_2 = var_0.team;
    self.entityheadiconteam = var_2;

    if ( isdefined( var_1 ) )
        self.entityheadiconoffset = var_1;
    else
        self.entityheadiconoffset = ( 0, 0, 0 );

    var_3 = game["entity_headicon_" + var_2];
    var_4 = newclienthudelem( var_0 );
    var_4.archived = 1;
    var_4.x = self.origin[0] + self.entityheadiconoffset[0];
    var_4.y = self.origin[1] + self.entityheadiconoffset[1];
    var_4.z = self.origin[2] + self.entityheadiconoffset[2];
    var_4.alpha = 0.8;
    var_4 setshader( var_3, 10, 10 );
    var_4 setwaypoint( 0, 0, 0, 1 );
    self.entityheadicon = var_4;
    thread keepiconpositioned();
    thread destroyheadiconsondeath();
}

keepiconpositioned()
{
    self.entityheadicon linkwaypointtotargetwithoffset( self, self.entityheadiconoffset );
}

destroyheadiconsondeath()
{
    self endon( "kill_entity_headicon_thread" );
    self waittill( "death" );

    if ( !isdefined( self.entityheadicon ) )
        return;

    self.entityheadicon destroy();
}

setheadicon( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9, var_10 )
{
    if ( isgameparticipant( var_0 ) && !isplayer( var_0 ) )
        return;

    if ( !isdefined( self.entityheadicons ) )
        self.entityheadicons = [];

    if ( !isdefined( var_5 ) )
        var_5 = 1;

    if ( !isdefined( var_6 ) )
        var_6 = 0.05;

    if ( !isdefined( var_7 ) )
        var_7 = 1;

    if ( !isdefined( var_8 ) )
        var_8 = 1;

    if ( !isdefined( var_9 ) )
        var_9 = 0;

    if ( !isdefined( var_10 ) )
        var_10 = 1;

    if ( !isplayer( var_0 ) && var_0 == "none" )
    {
        foreach ( var_13, var_12 in self.entityheadicons )
        {
            if ( isdefined( var_12 ) )
                var_12 destroy();

            self.entityheadicons[var_13] = undefined;
        }
    }
    else
    {
        if ( isplayer( var_0 ) )
        {
            if ( isdefined( self.entityheadicons[var_0.guid] ) )
            {
                self.entityheadicons[var_0.guid] destroy();
                self.entityheadicons[var_0.guid] = undefined;
            }

            if ( var_1 == "" )
                return;

            if ( isdefined( var_0.team ) )
            {
                if ( isdefined( self.entityheadicons[var_0.team] ) )
                {
                    self.entityheadicons[var_0.team] destroy();
                    self.entityheadicons[var_0.team] = undefined;
                }
            }

            var_12 = newclienthudelem( var_0 );
            self.entityheadicons[var_0.guid] = var_12;
        }
        else
        {
            if ( isdefined( self.entityheadicons[var_0] ) )
            {
                self.entityheadicons[var_0] destroy();
                self.entityheadicons[var_0] = undefined;
            }

            if ( var_1 == "" )
                return;

            foreach ( var_13, var_15 in self.entityheadicons )
            {
                if ( var_13 == "axis" || var_13 == "allies" )
                    continue;

                var_16 = getplayerforguid( var_13 );

                if ( var_16.team == var_0 )
                {
                    self.entityheadicons[var_13] destroy();
                    self.entityheadicons[var_13] = undefined;
                }
            }

            var_12 = newteamhudelem( var_0 );
            self.entityheadicons[var_0] = var_12;
        }

        if ( !isdefined( var_3 ) || !isdefined( var_4 ) )
        {
            var_3 = 10;
            var_4 = 10;
        }

        var_12.archived = var_5;
        var_12.x = self.origin[0] + var_2[0];
        var_12.y = self.origin[1] + var_2[1];
        var_12.z = self.origin[2] + var_2[2];
        var_12.alpha = 0.85;
        var_12 setshader( var_1, var_3, var_4 );
        var_12 setwaypoint( var_7, var_8, var_9, var_10 );
        var_12 thread keeppositioned( self, var_2, var_6 );
        thread destroyiconsondeath();

        if ( isplayer( var_0 ) )
            var_12 thread destroyonownerdisconnect( var_0 );

        if ( isplayer( self ) )
            var_12 thread destroyonownerdisconnect( self );
    }
}

showheadicon( var_0 )
{
    foreach ( var_2 in var_0 )
    {
        if ( isdefined( var_2 ) )
            var_2.alpha = 0.85;
    }
}

hideheadicon( var_0 )
{
    foreach ( var_2 in var_0 )
    {
        if ( isdefined( var_2 ) )
            var_2.alpha = 0;
    }
}

getplayerforguid( var_0 )
{
    foreach ( var_2 in level.players )
    {
        if ( var_2.guid == var_0 )
            return var_2;
    }

    return undefined;
}

getpotentiallivingplayers()
{
    var_0 = [];

    foreach ( var_2 in level.players )
    {
        if ( !var_2 scripts\cp_mp\utility\player_utility::_isalive() )
            continue;

        var_0[var_0.size] = var_2;
    }

    return var_0;
}

getplayersinradius( var_0, var_1, var_2, var_3 )
{
    var_4 = [ "physicscontents_player" ];
    return getentitiesinradius( var_0, var_1, var_2, var_3, physics_createcontents( var_4 ) );
}

getactorsinradius( var_0, var_1, var_2, var_3 )
{
    var_4 = [ "physicscontents_actor" ];
    return getentitiesinradius( var_0, var_1, var_2, var_3, physics_createcontents( var_4 ) );
}

getentitiesinradius( var_0, var_1, var_2, var_3, var_4 )
{
    if ( var_1 <= 0 )
        return [];

    var_5 = undefined;

    if ( isdefined( var_3 ) )
    {
        if ( isarray( var_3 ) )
            var_5 = var_3;
        else
            var_5 = [ var_3 ];
    }

    var_6 = physics_querypoint( var_0, var_1, var_4, var_5, "physicsquery_all" );
    var_7 = [];

    if ( !isdefined( var_2 ) )
    {
        foreach ( var_9 in var_6 )
        {
            var_10 = var_9["entity"];
            var_7[var_7.size] = var_10;
        }
    }
    else
    {
        foreach ( var_9 in var_6 )
        {
            var_10 = var_9["entity"];

            if ( isdefined( var_10.team ) && var_10.team == var_2 )
                var_7[var_7.size] = var_10;
        }
    }

    return var_7;
}

keeppositioned( var_0, var_1, var_2 )
{
    self endon( "death" );
    var_0 endon( "death" );
    var_0 endon( "disconnect" );
    var_3 = isdefined( var_0.classname ) && !isownercarepakage( var_0 );

    if ( var_3 )
        self linkwaypointtotargetwithoffset( var_0, var_1 );

    for (;;)
    {
        if ( !isdefined( var_0 ) )
            return;

        if ( !var_3 )
        {
            var_4 = var_0.origin;
            self.x = var_4[0] + var_1[0];
            self.y = var_4[1] + var_1[1];
            self.z = var_4[2] + var_1[2];
        }

        if ( var_2 > 0.05 )
        {
            self.alpha = 0.85;
            self fadeovertime( var_2 );
            self.alpha = 0;
        }

        wait( var_2 );
    }
}

isownercarepakage( var_0 )
{
    return isdefined( var_0.targetname ) && var_0.targetname == "care_package";
}

destroyiconsondeath()
{
    self notify( "destroyIconsOnDeath" );
    self endon( "destroyIconsOnDeath" );
    self waittill( "death" );

    if ( !isdefined( self.entityheadicons ) )
        return;

    foreach ( var_2, var_1 in self.entityheadicons )
    {
        if ( !isdefined( var_1 ) )
            continue;

        var_1 destroy();
    }
}

destroyonownerdisconnect( var_0 )
{
    self endon( "death" );
    var_0 waittill( "disconnect" );
    self destroy();
}

_suicide()
{
    if ( !isusingremote() && !isdefined( self.fauxdead ) )
        self suicide();
}

player_lua_progressbar( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    var_6 = lua_progress_bar_think( var_0, var_1, var_2, var_3, var_4, var_5 );
    return var_6;
}

lua_progress_bar_think( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    self.curprogress = 0;
    self.inuse = 1;
    self.userate = 1;
    self.usetime = var_1;
    var_0 thread create_lua_progress_bar( self, var_3 );
    var_0.hasprogressbar = 1;
    var_6 = lua_progress_bar_think_loop( var_0, self, var_2, var_4, var_5 );

    if ( isalive( var_0 ) )
        var_0.hasprogressbar = 0;

    if ( !isdefined( self ) )
        return 0;

    self.inuse = 0;
    self.curprogress = 0;
    return var_6;
}

create_lua_progress_bar( var_0, var_1 )
{
    self endon( "disconnect" );
    self setclientomnvar( "ui_securing", var_1 );
    var_2 = -1;

    while ( scripts\cp_mp\utility\player_utility::_isalive() && isdefined( var_0 ) && var_0.inuse && !level.gameended )
    {
        if ( var_2 != var_0.userate )
        {
            if ( var_0.curprogress > var_0.usetime )
                var_0.curprogress = var_0.usetime;
        }

        var_2 = var_0.userate;
        self setclientomnvar( "ui_securing_progress", var_0.curprogress / var_0.usetime );
        wait 0.05;
    }

    wait 0.5;
    self setclientomnvar( "ui_securing_progress", 0 );
    self setclientomnvar( "ui_securing", 0 );
}

lua_progress_bar_think_loop( var_0, var_1, var_2, var_3, var_4 )
{
    while ( !level.gameended && isdefined( self ) && var_0 scripts\cp_mp\utility\player_utility::_isalive() && ( var_0 usebuttonpressed() || isdefined( var_3 ) || var_0 attackbuttonpressed() && isdefined( var_4 ) ) && should_continue_progress_bar_think( var_0 ) )
    {
        wait 0.05;

        if ( isdefined( var_1 ) && isdefined( var_2 ) )
        {
            if ( distancesquared( var_0.origin, var_1.origin ) > var_2 )
                return 0;
        }

        self.curprogress = self.curprogress + 50 * self.userate;
        self.userate = 1;

        if ( self.curprogress >= self.usetime )
        {
            var_0 setclientomnvar( "ui_securing_progress", 1 );
            return var_0 scripts\cp_mp\utility\player_utility::_isalive();
        }
    }

    return 0;
}

should_continue_progress_bar_think( var_0 )
{
    if ( isdefined( level.should_continue_progress_bar_think ) )
        return [[ level.should_continue_progress_bar_think ]]( var_0 );
    else
        return !scripts\cp\cp_laststand::player_in_laststand( var_0 );
}

isplayingsolo()
{
    if ( getmaxclients() == 1 )
        return 1;

    return 0;
}

removefromparticipantsarray()
{
    var_0 = 0;

    for ( var_1 = 0; var_1 < level.participants.size; var_1++ )
    {
        if ( level.participants[var_1] == self )
        {
            for ( var_0 = 1; var_1 < level.participants.size - 1; var_1++ )
                level.participants[var_1] = level.participants[var_1 + 1];

            level.participants[var_1] = undefined;
            break;
        }
    }
}

removefromcharactersarray()
{
    var_0 = 0;

    for ( var_1 = 0; var_1 < level.characters.size; var_1++ )
    {
        if ( level.characters[var_1] == self )
        {
            for ( var_0 = 1; var_1 < level.characters.size - 1; var_1++ )
                level.characters[var_1] = level.characters[var_1 + 1];

            level.characters[var_1] = undefined;
            break;
        }
    }
}

removefromspawnedgrouparray()
{
    if ( isdefined( self.group_name ) )
    {
        if ( isdefined( level.spawned_group ) && isdefined( level.spawned_group[self.group_name] ) )
            level.spawned_group[self.group_name] = scripts\engine\utility::array_remove( level.spawned_group[self.group_name], self );
    }
}

createtimer( var_0, var_1 )
{
    var_2 = newclienthudelem( self );
    var_2.elemtype = "timer";
    var_2.font = var_0;
    var_2.fontscale = var_1;
    var_2.basefontscale = var_1;
    var_2.x = 0;
    var_2.y = 0;
    var_2.width = 0;
    var_2.height = int( level.fontheight * var_1 );
    var_2.xoffset = 0;
    var_2.yoffset = 0;
    var_2.children = [];
    var_2 setparent( level.uiparent );
    var_2.hidden = 0;
    return var_2;
}

maderecentkill( var_0 )
{
    if ( var_0 > 20 )
        return "ui_mp_timer_countdown";
    else if ( var_0 > 10 )
        return "ui_mp_timer_countdown_10";
    else if ( var_0 > 5 )
        return "ui_mp_timer_countdown_half_sec";
    else if ( var_0 > 1.5 )
        return "ui_mp_timer_countdown_quarter_sec";
    else
        return "ui_mp_timer_countdown_1";
}

maxrangesq( var_0, var_1 )
{
    var_2 = 1;

    if ( isdefined( var_1 ) )
        var_2 = var_1;

    var_3 = undefined;

    switch ( var_0 )
    {
        case 300:
            if ( istrue( var_2 ) && scripts\engine\utility::cointoss() )
                var_3 = "dx_cps_lass_timecheck_5min_10";
            else
                var_3 = "dx_cps_kama_timecheck_5min_10";

            break;
        case 120:
            if ( istrue( var_2 ) && scripts\engine\utility::cointoss() )
                var_3 = "dx_cps_lass_timecheck_2min_20";
            else
                var_3 = "dx_cps_kama_timecheck_2min_20";

            break;
        case 60:
            if ( istrue( var_2 ) && scripts\engine\utility::cointoss() )
                var_3 = "dx_cps_lass_timecheck_1min_30";
            else
                var_3 = "dx_cps_kama_timecheck_1min_30";

            break;
        case 30:
            if ( istrue( var_2 ) && scripts\engine\utility::cointoss() )
                var_3 = "dx_cps_lass_timecheck_30sec_40";
            else
                var_3 = "dx_cps_kama_timecheck_30sec_40";

            break;
        case 10:
            if ( istrue( var_2 ) && scripts\engine\utility::cointoss() )
                var_3 = "dx_cps_lass_timecheck_10sec_50";
            else
                var_3 = "dx_cps_kama_timecheck_10sec_50";

            break;
    }

    return var_3;
}

_detachall( var_0 )
{
    if ( !istrue( var_0 ) )
        self.headmodel = undefined;

    if ( isdefined( self.riotshieldmodel ) )
        riotshield_detach( 1 );

    if ( isdefined( self.riotshieldmodelstowed ) )
        riotshield_detach( 0 );

    self.hasriotshieldequipped = 0;

    if ( !istrue( var_0 ) )
        self detachall();

    scripts\cp\equipment\nvg::clearnvg( istrue( var_0 ) );
}

is_valid_perk( var_0 )
{
    var_1 = getarraykeys( level.alien_perks["perk_0"] );

    if ( scripts\engine\utility::array_contains( var_1, var_0 ) )
        return 1;

    var_2 = getarraykeys( level.alien_perks["perk_1"] );

    if ( scripts\engine\utility::array_contains( var_2, var_0 ) )
        return 1;

    var_3 = getarraykeys( level.alien_perks["perk_2"] );
    return scripts\engine\utility::array_contains( var_3, var_0 );
}

is_consumable_active( var_0 )
{
    if ( isdefined( self.consumables ) && isdefined( self.consumables[var_0] ) && isdefined( self.consumables[var_0].on ) && self.consumables[var_0].on == 1 )
        return 1;
    else
        return 0;
}

notify_used_consumable( var_0 )
{
    self notify( self.consumables[var_0].usednotify );
}

notify_timeup_consumable( var_0 )
{
    self notify( level.consumables[var_0].timeupnotify );
}

drawline( var_0, var_1, var_2, var_3 )
{
    var_4 = int( var_2 * 20 );

    for ( var_5 = 0; var_5 < var_4; var_5++ )
        wait 0.05;
}

is_upgrade_enabled( var_0 )
{
    if ( !is_using_extinction_tokens() )
        return 0;

    if ( self getplayerdata( "cp", "upgrades_enabled_flags", var_0 ) )
        return 1;
    else
        return 0;
}

allow_player_teleport( var_0, var_1 )
{
    if ( var_0 )
    {
        if ( !isdefined( self.teleportdisableflags ) && isdefined( var_1 ) )
        {
            foreach ( var_3 in self.teleportdisableflags )
            {
                if ( var_3 == var_1 )
                    self.teleportdisableflags = scripts\engine\utility::array_remove( self.teleportdisableflags, var_1 );
            }
        }

        self.disabledteleportation--;

        if ( !self.disabledteleportation )
        {
            self.teleportdisableflags = [];
            self.can_teleport = 1;
            self notify( "can_teleport" );
        }
    }
    else
    {
        if ( !isdefined( self.teleportdisableflags ) )
            self.teleportdisableflags = [];

        if ( isdefined( var_1 ) )
            self.teleportdisableflags[self.teleportdisableflags.size] = var_1;

        self.disabledteleportation++;
        self.can_teleport = 0;
    }
}

ismeleeenabled()
{
    return !isdefined( self.disabledmelee ) || !self.disabledmelee;
}

isteleportenabled()
{
    return !isdefined( self.disabledteleportation ) || !self.disabledteleportation;
}

allow_player_interactions( var_0 )
{
    if ( var_0 )
    {
        self.disabledinteractions--;

        if ( !self.disabledinteractions )
            self.interactions_disabled = undefined;
    }
    else
    {
        self.disabledinteractions++;
        self.interactions_disabled = 1;
    }
}

areinteractionsenabled()
{
    return self.disabledinteractions < 1;
}

_linkto( var_0, var_1, var_2, var_3, var_4 )
{
    if ( !isdefined( var_2 ) )
        var_2 = "tag_origin";

    if ( !isdefined( var_3 ) )
        var_3 = ( 0, 0, 0 );

    if ( !isdefined( var_4 ) )
        var_4 = ( 0, 0, 0 );

    if ( !isdefined( self.playerlinkedcounter ) )
        self.playerlinkedcounter = 0;

    self.playerlinkedcounter++;

    if ( self.playerlinkedcounter == 1 )
        self linkto( var_1, var_2, var_3, var_4 );
}

_unlink()
{
    if ( isplayerlinked() )
    {
        self.playerlinkedcounter--;

        if ( self.playerlinkedcounter <= 0 )
        {
            self.playerlinkedcounter = 0;
            self unlink();
        }
    }
}

get_linked_struct()
{
    var_0 = scripts\engine\utility::get_linked_structs();

    if ( !var_0.size )
        return undefined;

    return var_0[0];
}

isplayerlinked()
{
    return isdefined( self.playerlinkedcounter ) && self.playerlinkedcounter > 0;
}

enable_infinite_ammo( var_0 )
{
    if ( var_0 )
    {
        self.infiniteammocounter++;
        self setclientomnvar( "zm_ui_unlimited_ammo", 1 );
    }
    else
    {
        if ( self.infiniteammocounter > 0 )
            self.infiniteammocounter--;

        if ( !self.infiniteammocounter )
            self setclientomnvar( "zm_ui_unlimited_ammo", 0 );
    }
}

isinfiniteammoenabled()
{
    return self.infiniteammocounter >= 1;
}

binoculars_cleanupheadiconondisconnect( var_0 )
{
    if ( !isdefined( self.hostdamagefactorhigh ) )
        self.hostdamagefactorhigh = 0;

    if ( var_0 )
    {
        self.hostdamagefactorhigh++;
        self skydive_setbasejumpingstatus( 1 );
        self skydive_setdeploymentstatus( 1 );
    }
    else
    {
        self.hostdamagefactorhigh--;

        if ( self.hostdamagefactorhigh < 0 )
            self.hostdamagefactorhigh = 0;

        if ( !self.hostdamagefactorhigh )
        {
            self skydive_setbasejumpingstatus( 0 );
            self skydive_setdeploymentstatus( 0 );
        }
    }
}

binoculars_clearexpirationtimer( var_0 )
{
    if ( !isdefined( self.hostdamagefactormedium ) )
        self.hostdamagefactormedium = 0;

    if ( var_0 )
    {
        self.hostdamagefactormedium++;
        hideminimap( 1 );
    }
    else
    {
        self.hostdamagefactormedium--;

        if ( self.hostdamagefactormedium < 0 )
            self.hostdamagefactormedium = 0;

        if ( !self.hostdamagefactormedium )
            showminimap();
    }
}

postspawn_trucks()
{
    if ( isdefined( self.hostdamagefactormedium ) && self.hostdamagefactormedium > 0 )
        return 1;

    return 0;
}

allow_player_ignore_me( var_0 )
{
    if ( var_0 )
    {
        self.enabledignoreme++;
        self.ignoreme = 1;
    }
    else
    {
        self.enabledignoreme--;

        if ( !self.enabledignoreme )
            self.ignoreme = 0;
    }
}

binoculars_clearuidata( var_0 )
{
    if ( var_0 )
    {
        self.hostdamagepercentlow++;
        self.shouldskiplaststand = 1;
    }
    else
    {
        self.hostdamagepercentlow--;

        if ( !self.hostdamagepercentlow )
            self.shouldskiplaststand = 0;
    }
}

binoculars_clearpendingtimer( var_0 )
{
    if ( var_0 )
    {
        self.hostdamagepercenthigh++;
        self.shouldskipdeathsshield = 1;
    }
    else
    {
        self.hostdamagepercenthigh--;

        if ( !self.hostdamagepercenthigh )
            self.shouldskipdeathsshield = 0;
    }
}

purchase_balloon_nags()
{
    return self.hostdamagepercentlow >= 1;
}

propdeductchange()
{
    return self.hostdamagepercenthigh >= 1;
}

isignoremeenabled()
{
    return self.enabledignoreme >= 1;
}

force_usability_enabled()
{
    scripts\common\input_allow::clear_allow_info( "usability" );
    self enableusability();
}

is_using_extinction_tokens()
{
    return 0;

    if ( getdvarint( "MTMLKQMPST" ) > 0 )
        return 1;

    return 0;
}

coop_getweaponclass( var_0 )
{
    if ( !isdefined( var_0 ) )
        return "none";

    if ( issameweapon( var_0 ) && nullweapon( var_0 ) )
        return "none";

    if ( isstring( var_0 ) && var_0 == "none" )
        return "none";

    var_1 = getbaseweaponname( var_0 );
    var_2 = tablelookup( "mp/statstable.csv", 4, var_1, 1 );

    if ( var_2 == "" && isdefined( level.game_mode_statstable ) )
    {
        if ( isdefined( var_0 ) )
        {
            var_1 = getbaseweaponname( var_0 );
            var_2 = tablelookup( level.game_mode_statstable, 4, var_1, 2 );
        }
    }

    if ( isenvironmentweapon( var_0 ) )
        var_2 = "weapon_mg";
    else if ( issameweapon( var_0 ) && nullweapon( var_0 ) )
        var_2 = "other";
    else if ( isstring( var_0 ) && var_0 == "none" )
        var_2 = "other";
    else if ( var_2 == "" )
        var_2 = "other";

    return var_2;
}

is_holding_deployable()
{
    return istrue( self.is_holding_deployable );
}

has_special_weapon()
{
    return istrue( self.has_special_weapon );
}

filloffhandweapons( var_0, var_1 )
{
    var_2 = self getweaponslistoffhands();
    var_3 = 0;
    var_4 = undefined;
    var_5 = 0;

    foreach ( var_7 in var_2 )
    {
        if ( var_7 != var_0 )
        {
            if ( nullweapon( var_7 ) )
                continue;

            var_8 = var_7.basename;

            if ( var_8 != "alienthrowingknife_mp" && var_8 != "alientrophy_mp" && var_8 != "iw6_aliendlc21_mp" )
                self takeweapon( var_7 );

            continue;
        }

        if ( !nullweapon( var_7 ) )
        {
            var_5 = self getammocount( var_7 );
            self setweaponammostock( var_7, var_5 + var_1 );
            var_3 = 1;
            break;
        }
    }

    if ( var_3 == 0 )
    {
        _giveweapon( var_0 );
        self setweaponammostock( var_0, var_1 );
    }
}

getequipmenttype( var_0 )
{
    switch ( var_0 )
    {
        case "arc_grenade_mp":
        case "zom_repulsor_mp":
        case "splash_grenade_zm":
        case "splash_grenade_mp":
        case "impalement_spike_mp":
        case "mortar_shelljugg_mp":
        case "proximity_explosive_mp":
        case "bouncing_betty_mp":
        case "throwingknifesmokewall_mp":
        case "throwingknifec4_mp":
        case "at_mine_mp":
        case "claymore_mp":
        case "cluster_grenade_zm":
        case "semtex_zm":
        case "c4_mp_p":
        case "c4_zm":
        case "frag_grenade_mp":
        case "frag_grenade_zm":
        case "pop_rocket_mp":
        case "throwingknife_mp":
        case "throwingknife":
        case "gas_mp":
        case "thermite_mp":
        case "molotov_mp":
        case "molotov":
        case "semtex_mp":
        case "semtex":
        case "frag":
            var_1 = "lethal";
            break;
        case "ztransponder_mp":
        case "transponder_mp":
        case "blackout_grenade_mp":
        case "player_trophy_system_mp":
        case "proto_ricochet_device_mp":
        case "emp_grenade_mp":
        case "trophy_mp":
        case "mobile_radar_mp":
        case "gravity_grenade_mp":
        case "alienflare_mp":
        case "concussion_grenade_mp":
        case "smoke_grenadejugg_mp":
        case "smoke_grenade_mp":
        case "thermobaric_grenade_mp":
        case "portal_generator_zm":
        case "portal_generator_mp":
        case "flash_grenade_mp":
        case "dud_grenade_zm":
        case "noisemaker":
        case "teargas":
        case "signal":
        case "smoke_tall":
        case "smoke":
        case "flash":
            var_1 = "tactical";
            break;
        default:
            var_1 = undefined;
            break;
    }

    return var_1;
}

giveperkoffhand( var_0 )
{
    if ( var_0 == "none" || var_0 == "specialty_null" )
        self setoffhandsecondaryclass( "none" );
    else
    {
        self.secondarygrenade = var_0;

        if ( issubstr( var_0, "_mp" ) )
        {
            switch ( var_0 )
            {
                case "dud_grenade_zm":
                case "splash_grenade_zm":
                case "splash_grenade_mp":
                case "mortar_shelljugg_mp":
                case "cluster_grenade_zm":
                case "semtex_zm":
                case "frag_grenade_mp":
                case "frag_grenade_zm":
                case "semtex_mp":
                    self setoffhandsecondaryclass( "frag" );
                    break;
                case "throwingknifejugg_mp":
                case "throwingknifesmokewall_mp":
                case "throwingknifec4_mp":
                case "c4_zm":
                case "throwingknife_mp":
                    self setoffhandsecondaryclass( "throwingknife" );
                    break;
                case "player_trophy_system_mp":
                case "proto_ricochet_device_mp":
                case "emp_grenade_mp":
                case "trophy_mp":
                case "mobile_radar_mp":
                case "alienflare_mp":
                case "thermobaric_grenade_mp":
                case "flash_grenade_mp":
                    self setoffhandsecondaryclass( "flash" );
                    break;
                case "concussion_grenade_mp":
                case "smoke_grenadejugg_mp":
                case "smoke_grenade_mp":
                    self setoffhandsecondaryclass( "smoke" );
                    break;
                case "ztransponder_mp":
                case "transponder_mp":
                case "zom_repulsor_mp":
                default:
                    self setoffhandsecondaryclass( "other" );
                    break;
            }

            _giveweapon( var_0, 0 );

            switch ( var_0 )
            {
                case "ztransponder_mp":
                case "transponder_mp":
                case "player_trophy_system_mp":
                case "proto_ricochet_device_mp":
                case "emp_grenade_mp":
                case "trophy_mp":
                case "mobile_radar_mp":
                case "gravity_grenade_mp":
                case "alienflare_mp":
                case "concussion_grenade_mp":
                case "smoke_grenade_mp":
                case "thermobaric_grenade_mp":
                case "flash_grenade_mp":
                    self setweaponammoclip( var_0, 1 );
                    break;
                default:
                    self givestartammo( var_0 );
                    break;
            }

            _setperk( var_0 );
            return;
        }

        _setperk( var_0 );
    }
}

_launchgrenade( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    var_6 = self launchgrenade( var_0, var_1, var_2, var_3, var_5 );

    if ( !isdefined( var_4 ) )
        var_6.notthrown = 1;
    else
        var_6.notthrown = var_4;

    var_6 setotherent( self );
    return var_6;
}

moveplayerperpendicularly( var_0, var_1 )
{
    if ( !isdefined( var_0 ) )
        var_0 = 1200;

    if ( isdefined( var_1 ) )
        var_2 = vectornormalize( var_1 );
    else
        var_2 = anglestoforward( self.angles );

    var_3 = vectorcross( ( 0, 0, 1 ), var_2 );
    var_4 = vectornormalize( var_3 );
    self knockback( var_4, var_0 );
}

blockperkfunction( var_0 )
{
    if ( !isdefined( self.perksblocked[var_0] ) )
        self.perksblocked[var_0] = 1;
    else
        self.perksblocked[var_0]++;

    if ( self.perksblocked[var_0] == 1 && _hasperk( var_0 ) )
    {
        foreach ( var_6, var_2 in level.extraperkmap )
        {
            if ( var_0 == var_6 )
            {
                foreach ( var_4 in var_2 )
                {
                    if ( !isdefined( self.perksblocked[var_4] ) )
                        self.perksblocked[var_4] = 1;
                    else
                        self.perksblocked[var_4]++;

                    if ( self.perksblocked[var_4] == 1 )
                    {

                    }
                }

                break;
            }
        }
    }
}

unblockperkfunction( var_0 )
{
    self.perksblocked[var_0]--;

    if ( self.perksblocked[var_0] == 0 )
    {
        self.perksblocked[var_0] = undefined;

        if ( _hasperk( var_0 ) )
        {
            foreach ( var_6, var_2 in level.extraperkmap )
            {
                if ( var_0 == var_6 )
                {
                    foreach ( var_4 in var_2 )
                    {
                        self.perksblocked[var_4]--;

                        if ( self.perksblocked[var_4] == 0 )
                            self.perksblocked[var_4] = undefined;
                    }

                    break;
                }
            }
        }
    }
}

getweaponclass( var_0 )
{
    var_1 = getbaseweaponname( var_0 );
    var_2 = tablelookup( "mp/statstable.csv", 4, var_1, 1 );

    if ( var_2 == "" )
    {
        var_3 = strip_suffix( var_0.basename, "_zm" );
        var_2 = tablelookup( "mp/statstable.csv", 4, var_3, 1 );
    }

    if ( isenvironmentweapon( var_0.basename ) )
        var_2 = "weapon_mg";
    else if ( iskillstreakweapon( var_0.basename ) )
        var_2 = "killstreak";
    else if ( issuperweapon( var_0.basename ) )
        var_2 = "super";
    else if ( var_0.basename == "none" )
        var_2 = "other";
    else if ( var_2 == "" )
        var_2 = "other";

    return var_2;
}

removedamagemodifier( var_0, var_1 )
{
    if ( !isdefined( var_1 ) )
        var_1 = 1;

    if ( var_1 )
    {
        if ( !isdefined( self.additivedamagemodifiers ) )
            return;

        self.additivedamagemodifiers[var_0] = undefined;
    }
    else
    {
        if ( !isdefined( self.multiplicativedamagemodifiers ) )
            return;

        self.multiplicativedamagemodifiers[var_0] = undefined;
    }
}

adddamagemodifier( var_0, var_1, var_2 )
{
    if ( !isdefined( var_2 ) )
        var_2 = 1;

    if ( var_2 )
    {
        if ( !isdefined( self.additivedamagemodifiers ) )
            self.additivedamagemodifiers = [];

        self.additivedamagemodifiers[var_0] = var_1;
    }
    else
    {
        if ( !isdefined( self.multiplicativedamagemodifiers ) )
            self.multiplicativedamagemodifiers = [];

        self.multiplicativedamagemodifiers[var_0] = var_1;
    }
}

getdamagemodifiertotal( var_0, var_1, var_2, var_3, var_4, var_5, var_6 )
{
    var_7 = 1.0;

    if ( isdefined( self.additivedamagemodifiers ) )
    {
        foreach ( var_9 in self.additivedamagemodifiers )
            var_7 = var_7 + ( var_9 - 1.0 );
    }

    var_11 = 1.0;

    if ( isdefined( self.multiplicativedamagemodifiers ) )
    {
        foreach ( var_9 in self.multiplicativedamagemodifiers )
            var_11 = var_11 * var_9;
    }

    return var_7 * var_11;
}

isinventoryprimaryweapon( var_0 )
{
    switch ( weaponinventorytype( var_0 ) )
    {
        case "altmode":
        case "primary":
            return 1;
        default:
            return 0;
    }
}

_enablecollisionnotifies( var_0 )
{
    if ( !isdefined( self.enabledcollisionnotifies ) )
        self.enabledcollisionnotifies = 0;

    if ( var_0 )
    {
        if ( self.enabledcollisionnotifies == 0 )
            self enablecollisionnotifies( 1 );

        self.enabledcollisionnotifies++;
    }
    else
    {
        if ( self.enabledcollisionnotifies == 1 )
            self enablecollisionnotifies( 0 );

        self.enabledcollisionnotifies--;
    }
}

has_tag( var_0, var_1 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    var_2 = getnumparts( var_0 );

    for ( var_3 = 0; var_3 < var_2; var_3++ )
    {
        if ( tolower( getpartname( var_0, var_3 ) ) == tolower( var_1 ) )
            return 1;
    }

    return 0;
}

is_trap( var_0, var_1 )
{
    if ( isdefined( var_1 ) && ( var_1.basename == "iw7_beamtrap_zm" || var_1.basename == "iw7_escapevelocity_zm" || var_1.basename == "iw7_rockettrap_zm" || var_1.basename == "iw7_discotrap_zm" || var_1.basename == "iw7_chromosphere_zm" || var_1.basename == "iw7_buffertrap_zm" || var_1.basename == "iw7_electrictrap_zm" || var_1.basename == "iw7_fantrap_zm" || var_1.basename == "iw7_hydranttrap_zm" || var_1.basename == "iw7_moshtrap_zm" ) )
        return 1;

    if ( !isdefined( var_0 ) )
        return 0;

    if ( isdefined( var_0.tesla_type ) )
        return 1;

    if ( !isdefined( var_0.script_noteworthy ) && !isdefined( var_0.targetname ) )
        return 0;

    if ( isdefined( var_0.targetname ) && ( var_0.targetname == "fence_generator" || var_0.targetname == "puddle_generator" ) )
        return 1;

    if ( isdefined( var_0.script_noteworthy ) && var_0.script_noteworthy == "fire_trap" )
        return 1;

    return 0;
}

riotshieldname()
{
    var_0 = self getweaponslist( "primary" );

    if ( !self.hasriotshield )
        return;

    foreach ( var_2 in var_0 )
    {
        if ( weapontype( var_2 ) == "riotshield" )
            return var_2;
    }
}

player_has_special_ammo( var_0, var_1 )
{
    return isdefined( var_0.special_ammo_type ) && var_0.special_ammo_type == var_1;
}

has_stun_ammo( var_0 )
{
    if ( isdefined( self.special_ammo_type ) )
        return player_has_special_ammo( self, "stun_ammo" );

    if ( !isdefined( var_0 ) )
        var_1 = self getcurrentweapon();
    else if ( issameweapon( var_0 ) )
        var_1 = var_0;
    else
        var_1 = asmdevgetallstates( var_0 );

    if ( nullweapon( var_1 ) )
        var_1 = self getweaponslistprimaries()[0];

    var_2 = getrawbaseweaponname( var_1 );

    if ( isdefined( self.special_ammocount ) && isdefined( self.special_ammocount[var_2] ) && self.special_ammocount[var_2] > 0 )
        return 1;

    if ( isdefined( self.special_ammocount_comb ) && isdefined( self.special_ammocount_comb[var_2] ) && self.special_ammocount_comb[var_2] > 0 )
        return 1;

    return 0;
}

is_ricochet_damage()
{
    return level.ricochetdamage;
}

is_hardcore_mode()
{
    return level.hardcoremode;
}

is_casual_mode()
{
    return level.casualmode == 1;
}

rear_minigun_origin_offset( var_0 )
{
    if ( isdefined( var_0 ) && var_0.basename != "none" )
    {
        if ( issuperweapon( var_0.basename ) )
            return 1;

        var_1 = getequipmenttype( var_0.basename );

        if ( isdefined( var_1 ) && var_1 == "lethal" )
            return 1;
    }

    return 0;
}

isriotshield( var_0 )
{
    if ( issameweapon( var_0 ) && nullweapon( var_0 ) )
        return 0;

    if ( isstring( var_0 ) && var_0 == "none" )
        return 0;

    return weapontype( var_0 ) == "riotshield";
}

isaltmodeweapon( var_0 )
{
    if ( !isdefined( var_0 ) || var_0 == "none" )
        return 0;

    return weaponinventorytype( var_0 ) == "altmode";
}

hasriotshield()
{
    var_0 = 0;
    var_1 = self getweaponslistprimaries();

    foreach ( var_3 in var_1 )
    {
        if ( isriotshield( var_3 ) )
        {
            var_0 = 1;
            break;
        }
    }

    return var_0;
}

is_empty_string( var_0 )
{
    return var_0 == "";
}

notifyafterframeend( var_0, var_1 )
{
    self waittill( var_0 );
    waittillframeend;
    self notify( var_1 );
}

player_last_death_pos()
{
    level endon( "game_ended" );
    self endon( "death" );
    self endon( "disconnect" );
    self.last_death_pos = self.origin;

    for (;;)
    {
        self waittill( "damage" );
        self.last_death_pos = self.origin;
    }
}

isheadshot( var_0, var_1, var_2, var_3 )
{
    if ( isdefined( var_3 ) )
    {
        if ( isdefined( var_3.owner ) )
        {
            if ( var_3.code_classname == "script_vehicle" )
                return 0;

            if ( var_3.code_classname == "misc_turret" )
                return 0;

            if ( var_3.code_classname == "script_model" )
                return 0;
        }

        if ( isdefined( var_3.agent_type ) )
        {
            if ( var_3.agent_type == "dog" || var_3.agent_type == "alien" )
                return 0;
        }
    }

    return ( var_1 == "head" || var_1 == "helmet" || var_1 == "neck" ) && var_2 != "MOD_MELEE" && var_2 != "MOD_IMPACT" && var_2 != "MOD_SCARAB" && var_2 != "MOD_CRUSH" && var_2 != "MOD_HEAD_SHOT" && !isenvironmentweapon( var_0.basename );
}

getteamarray( var_0, var_1 )
{
    var_2 = [];

    if ( !isdefined( var_1 ) || var_1 )
    {
        foreach ( var_4 in level.characters )
        {
            if ( var_4.team == var_0 )
                var_2[var_2.size] = var_4;
        }
    }
    else
    {
        foreach ( var_4 in level.players )
        {
            if ( var_4.team == var_0 )
                var_2[var_2.size] = var_4;
        }
    }

    return var_2;
}

getotherteam( var_0 )
{
    if ( level.multiteambased )
    {

    }

    if ( var_0 == "allies" )
        return "axis";
    else if ( var_0 == "axis" )
        return "allies";
    else
        return "none";
}

player_black_screen( var_0, var_1, var_2, var_3 )
{
    self endon( "disconnect" );
    self endon( "intermission" );
    self endon( "death" );
    self.player_black_screen = newclienthudelem( self );
    self.player_black_screen.x = 0;
    self.player_black_screen.y = 0;
    self.player_black_screen setshader( "black", 640, 480 );
    self.player_black_screen.alignx = "left";
    self.player_black_screen.aligny = "top";
    self.player_black_screen.sort = 1;
    self.player_black_screen.horzalign = "fullscreen";
    self.player_black_screen.vertalign = "fullscreen";
    self.player_black_screen.alpha = 0;
    self.player_black_screen.foreground = 1;

    if ( !istrue( var_3 ) )
        self.player_black_screen fadeovertime( var_0 );

    self.player_black_screen.alpha = 1;

    if ( !istrue( var_3 ) )
        wait( var_0 + 0.05 );

    wait( var_1 );
    self.player_black_screen fadeovertime( var_2 );
    self.player_black_screen.alpha = 0;
    wait( var_2 + 0.05 );
    self.player_black_screen destroy();
}

riotshield_hasweapon()
{
    var_0 = 0;
    var_1 = self getweaponslistprimaries();

    foreach ( var_3 in var_1 )
    {
        if ( isriotshield( var_3 ) )
        {
            var_0 = 1;
            break;
        }
    }

    return var_0;
}

riotshield_attach( var_0, var_1 )
{
    var_2 = undefined;

    if ( var_0 )
    {
        self.riotshieldmodel = var_1;
        var_2 = "j_shield_ri";
    }
    else
    {
        self.riotshieldmodelstowed = var_1;
        var_2 = "tag_shield_back";
    }

    if ( !isdefined( self.fulton_actors_players ) || self.fulton_actors_players != var_2 )
    {
        self.fulton_actors_players = var_2;
        self attachshieldmodel( var_1, var_2 );
    }

    self.hasriotshield = riotshield_hasweapon();
}

riotshield_detach( var_0 )
{
    var_1 = undefined;
    var_2 = undefined;

    if ( var_0 )
    {
        var_1 = self.riotshieldmodel;
        var_2 = "j_shield_ri";
    }
    else
    {
        var_1 = self.riotshieldmodelstowed;
        var_2 = "tag_shield_back";
    }

    if ( isdefined( self.fulton_actors_players ) && self.fulton_actors_players == var_2 )
    {
        self.fulton_actors_players = undefined;
        self detachshieldmodel( var_1, var_2 );
    }

    if ( var_0 )
        self.riotshieldmodel = undefined;
    else
        self.riotshieldmodelstowed = undefined;

    self.hasriotshield = riotshield_hasweapon();
}

launchshield( var_0, var_1 )
{
    if ( riotshield_hasweapon() )
    {
        if ( isdefined( self.riotshieldmodel ) )
            riotshield_detach( 1 );

        if ( isdefined( self.riotshieldmodelstowed ) )
            riotshield_detach( 0 );
    }
}

riotshield_move( var_0 )
{
    var_1 = undefined;
    var_2 = undefined;
    var_3 = undefined;

    if ( var_0 )
    {
        var_3 = self.riotshieldmodel;
        var_1 = "j_shield_ri";
        var_2 = "tag_shield_back";
    }
    else
    {
        var_3 = self.riotshieldmodelstowed;
        var_1 = "tag_shield_back";
        var_2 = "j_shield_ri";
    }

    if ( !isdefined( self.fulton_actors_players ) || self.fulton_actors_players != var_2 )
    {
        self.fulton_actors_players = var_2;
        self moveshieldmodel( var_3, var_1, var_2 );
    }

    if ( var_0 )
    {
        self.riotshieldmodelstowed = var_3;
        self.riotshieldmodel = undefined;
    }
    else
    {
        self.riotshieldmodel = var_3;
        self.riotshieldmodelstowed = undefined;
    }
}

riotshield_clear()
{
    self.hasriotshieldequipped = 0;
    self.hasriotshield = 0;
    self.riotshieldmodelstowed = undefined;
    self.riotshieldmodel = undefined;
}

remove_crafting_item()
{
    self setclientomnvar( "zombie_souvenir_piece_index", 0 );

    if ( isdefined( level.crafting_remove_func ) )
        self [[ level.crafting_remove_func ]]();

    self.current_crafting_struct = undefined;
}

store_weapons_status( var_0, var_1 )
{
    self.copy_fullweaponlist = self getweaponslistall();
    self.copy_weapon_current = get_current_weapon( self, var_1 );
    self.copy_weapon_level = [];
    var_2 = [];

    foreach ( var_4 in self.copy_fullweaponlist )
    {
        if ( var_4.isalternate )
            continue;

        if ( issubstr( var_4.basename, "iw8_execution_" ) )
            continue;

        var_2[var_2.size] = var_4;
    }

    self.copy_fullweaponlist = var_2;

    foreach ( var_4 in self.copy_fullweaponlist )
    {
        var_7 = createheadicon( var_4 );
        self.copy_weapon_ammo_clip[var_7] = self getweaponammoclip( var_4 );
        self.copy_weapon_ammo_stock[var_7] = self getweaponammostock( var_4 );

        if ( issubstr( var_4.basename, "akimbo" ) )
            self.copy_weapon_ammo_clip_left[var_7] = self getweaponammoclip( var_4, "left" );

        var_8 = getrawbaseweaponname( var_4 );

        if ( isdefined( self.pap[var_8] ) )
            self.copy_weapon_level[var_7] = self.pap[var_8].lvl;
    }

    if ( isdefined( var_0 ) )
    {
        var_10 = [];

        foreach ( var_4 in self.copy_fullweaponlist )
        {
            var_12 = 0;

            foreach ( var_14 in var_0 )
            {
                if ( var_4 == var_14 )
                {
                    var_12 = 1;
                    break;
                }
                else if ( var_4 getbaseweapon() == var_14 )
                {
                    var_12 = 1;
                    break;
                }
            }

            if ( var_12 )
                continue;

            var_10[var_10.size] = var_4;
        }

        self.copy_fullweaponlist = var_10;

        foreach ( var_14 in var_0 )
        {
            if ( self.copy_weapon_current == var_14 )
            {
                self.copy_weapon_current = isundefinedweapon();
                break;
            }
        }
    }
}

get_current_weapon( var_0, var_1 )
{
    var_2 = var_0 getcurrentweapon();

    if ( istrue( var_1 ) && is_melee_weapon( var_2 ) )
        var_2 = var_0 getweaponslistall()[1];

    return var_2;
}

is_melee_weapon( var_0, var_1 )
{
    var_2 = undefined;

    if ( issameweapon( var_0 ) )
        var_2 = var_0.basename;
    else
        var_2 = var_0;

    switch ( var_2 )
    {
        case "iw7_knife_zm_disco":
        case "alt_iw7_knife_zm_survivor":
        case "alt_iw7_knife_zm_grunge":
        case "alt_iw7_knife_zm_hiphop":
        case "alt_iw7_knife_zm_raver":
        case "alt_iw7_knife_zm_chola":
        case "iw7_knife_zm_survivor":
        case "iw7_knife_zm_grunge":
        case "iw7_knife_zm_hiphop":
        case "iw7_knife_zm_raver":
        case "iw7_knife_zm_chola":
        case "alt_iw7_knife_zm_vgirl":
        case "alt_iw7_knife_zm_rapper":
        case "alt_iw7_knife_zm_nerd":
        case "alt_iw7_knife_zm_jock":
        case "alt_iw7_knife_zm":
        case "iw7_knife_zm_vgirl":
        case "iw7_knife_zm_rapper":
        case "iw7_knife_zm_nerd":
        case "iw7_knife_zm_jock":
        case "alt_iw7_knife_zm_hoff":
        case "iw7_knife_zm_hoff":
        case "iw8_knife_mp":
            return 1;
        case "iw7_katana_zm_pap2":
        case "iw7_katana_zm_pap1":
        case "iw7_nunchucks_zm_pap2":
        case "iw7_nunchucks_zm_pap1":
        case "iw7_katana_zm":
        case "iw7_nunchucks_zm":
        case "iw7_axe_zm_pap2":
        case "iw7_axe_zm_pap1":
        case "iw7_axe_zm":
        case "iw7_fists_zm_kevinsmith":
        case "iw7_fists_zm_raver":
        case "iw7_fists_zm_hiphop":
        case "iw7_fists_zm_grunge":
        case "iw7_fists_zm_chola":
        case "iw7_fists_zm":
            if ( istrue( var_1 ) )
                return 0;
            else
                return 1;
        default:
            return 0;
    }
}

is_primary_melee_weapon( var_0 )
{
    var_1 = undefined;

    if ( issameweapon( var_0 ) )
        var_1 = var_0.basename;
    else
        var_1 = var_0;

    switch ( var_1 )
    {
        case "iw7_katana_zm_pap2":
        case "iw7_katana_zm_pap1":
        case "iw7_nunchucks_zm_pap2":
        case "iw7_nunchucks_zm_pap1":
        case "iw7_katana_zm":
        case "iw7_nunchucks_zm":
        case "iw7_axe_zm_pap2":
        case "iw7_axe_zm_pap1":
        case "iw7_axe_zm":
            return 1;
    }

    return 0;
}

restore_weapons_status( var_0 )
{
    if ( !isdefined( self.copy_fullweaponlist ) || !isdefined( self.copy_weapon_current ) || !isdefined( self.copy_weapon_ammo_clip ) || !isdefined( self.copy_weapon_ammo_stock ) )
    {

    }

    var_1 = self getweaponslistall();

    foreach ( var_3 in var_1 )
    {
        if ( !scripts\engine\utility::array_contains( self.copy_fullweaponlist, var_3 ) && !in_inclusion_list( var_0, var_3 ) )
            self takeweapon( var_3 );
    }

    if ( isdefined( self._id_11B38 ) )
    {
        if ( !scripts\engine\utility::array_contains( self.copy_fullweaponlist, self._id_11B38 ) )
            self.copy_fullweaponlist[self.copy_fullweaponlist.size] = self._id_11B38;

        self._id_11B38 = undefined;
    }

    foreach ( var_3 in self.copy_fullweaponlist )
    {
        if ( !self hasweapon( var_3 ) )
            self giveweapon( var_3, -1, 0, -1, 1 );

        var_6 = createheadicon( var_3 );

        if ( isdefined( self.powerprimarygrenade ) && self.powerprimarygrenade == var_6 )
            self assignweaponoffhandprimary( var_3 );

        if ( isdefined( self.powersecondarygrenade ) && self.powersecondarygrenade == var_6 )
            self assignweaponoffhandsecondary( var_3 );

        if ( isdefined( self.specialoffhandgrenade ) && self.specialoffhandgrenade == var_6 )
            self assignweaponoffhandspecial( var_3 );

        if ( isdefined( self.copy_weapon_ammo_clip[var_6] ) )
            self setweaponammoclip( var_3, self.copy_weapon_ammo_clip[var_6] );

        if ( isdefined( self.copy_weapon_ammo_clip_left ) )
        {
            if ( isdefined( self.copy_weapon_ammo_clip_left[var_6] ) )
                self setweaponammoclip( var_3, self.copy_weapon_ammo_clip_left[var_6], "left" );
        }

        if ( isdefined( self.copy_weapon_ammo_stock[var_6] ) )
            self setweaponammostock( var_3, self.copy_weapon_ammo_stock[var_6] );

        if ( isdefined( self.copy_weapon_level[var_6] ) )
        {
            var_7 = spawnstruct();
            var_7.lvl = self.copy_weapon_level[var_6];
            self.pap[getrawbaseweaponname( var_3 )] = var_7;
        }
    }

    var_9 = self.copy_weapon_current;

    if ( getqueuedspleveltransients( var_9 ) )
    {
        foreach ( var_11 in self.copy_fullweaponlist )
        {
            if ( scripts\cp\cp_weapon::isbulletweapon( var_11 ) )
            {
                var_9 = var_11;
                break;
            }
        }
    }

    if ( scripts\common\utility::is_weapon_switch_allowed() )
        self switchtoweaponimmediate( var_9 );

    if ( !istrue( self.bspawningviaac130 ) )
    {
        self.copy_fullweaponlist = undefined;
        self.copy_weapon_current = undefined;
        self.copy_weapon_ammo_clip = undefined;
        self.copy_weapon_ammo_stock = undefined;
        self.copy_weapon_ammo_clip_left = undefined;
    }

    if ( isdefined( level.arcade_last_stand_power_func ) )
        self [[ level.arcade_last_stand_power_func ]]();
}

restore_primary_weapons_only( var_0 )
{
    if ( !isdefined( self.copy_fullweaponlist ) || !isdefined( self.copy_weapon_current ) || !isdefined( self.copy_weapon_ammo_clip ) || !isdefined( self.copy_weapon_ammo_stock ) )
    {

    }

    self.primary_weapons = [];
    var_1 = 0;

    foreach ( var_3 in self.copy_fullweaponlist )
    {
        if ( isinventoryprimaryweapon( var_3 ) )
        {
            self.primary_weapons[var_1] = var_3;
            var_1 = var_1 + 1;
        }
    }

    var_5 = 0;

    foreach ( var_3 in self.primary_weapons )
    {
        if ( var_5 < 3 )
        {
            if ( var_3.isalternate )
                continue;

            if ( !self hasweapon( var_3 ) )
                self giveweapon( var_3, -1, 0, -1, 1 );

            var_7 = createheadicon( var_3 );
            self setweaponammoclip( var_3, self.copy_weapon_ammo_clip[var_7] );
            self setweaponammostock( var_3, self.copy_weapon_ammo_stock[var_7] );

            if ( isdefined( self.copy_weapon_level[var_7] ) )
            {
                var_8 = spawnstruct();
                var_8.lvl = self.copy_weapon_level[var_7];
                self.pap[getrawbaseweaponname( var_3 )] = var_8;
            }

            var_5++;
        }
    }

    var_10 = self.copy_weapon_current;

    if ( !isdefined( var_10 ) || !self hasweapon( var_10 ) || nullweapon( var_10 ) )
        var_10 = getweapontoswitchbackto();

    self switchtoweaponimmediate( var_10 );
    self.copy_fullweaponlist = undefined;
    self.copy_weapon_current = undefined;
    self.copy_weapon_ammo_clip = undefined;
    self.copy_weapon_ammo_stock = undefined;
}

clear_weapons_status()
{
    self.copy_fullweaponlist = [];
    self.copy_weapon_current = isundefinedweapon();
    self.copy_weapon_ammo_clip = [];
    self.copy_weapon_ammo_clip_left = [];
    self.copy_weapon_ammo_stock = [];
    self.copy_weapon_level = [];
}

add_to_weapons_status( var_0, var_1, var_2, var_3 )
{
    foreach ( var_5 in var_0 )
    {
        var_6 = undefined;
        var_7 = undefined;

        if ( issameweapon( var_5 ) )
        {
            var_6 = var_5;
            var_7 = createheadicon( var_5 );
        }
        else
        {
            var_6 = asmdevgetallstates( var_5 );
            var_7 = var_5;
        }

        self.copy_fullweaponlist[self.copy_fullweaponlist.size] = var_6;
        self.copy_weapon_ammo_clip[var_7] = var_1[var_7];
        self.copy_weapon_ammo_stock[var_7] = var_2[var_7];
    }

    self.copy_weapon_current = var_3;
}

in_inclusion_list( var_0, var_1 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    return scripts\engine\utility::array_contains( var_0, var_1 );
}

vec_multiply( var_0, var_1 )
{
    return ( var_0[0] * var_1, var_0[1] * var_1, var_0[2] * var_1 );
}

restore_super_weapon()
{
    self giveweapon( "super_default_zm" );
    self assignweaponoffhandspecial( "super_default_zm" );
    self.specialoffhandgrenade = "super_default_zm";

    if ( istrue( self.consumable_meter_full ) )
        self setweaponammoclip( "super_default_zm", 1 );
}

getcloseststruct( var_0, var_1, var_2 )
{
    var_3 = scripts\engine\utility::getstructarray( var_1, "script_noteworthy" );
    var_4 = sortbydistance( var_3, var_0 )[0];

    if ( isdefined( var_2 ) && distancesquared( var_0, var_4.origin ) > squared( var_2 ) )
        return undefined;

    return var_4;
}

is_zombie_agent()
{
    return isagent( self ) && isdefined( self.species ) && ( self.species == "humanoid" || self.species == "zombie" );
}

is_soldier_agent()
{
    return isagent( self ) && isdefined( self.species ) && self.species == "human";
}

coop_mode_has( var_0 )
{
    if ( !isdefined( level.coop_mode_feature ) )
        return 0;

    return isdefined( level.coop_mode_feature[var_0] );
}

coop_mode_enable( var_0 )
{
    if ( isdefined( var_0 ) )
    {
        if ( !isdefined( level.coop_mode_feature ) )
            level.coop_mode_feature = [];

        if ( isarray( var_0 ) )
        {
            foreach ( var_2 in var_0 )
                level.coop_mode_feature[var_2] = 1;
        }
        else
            level.coop_mode_feature[var_0] = 1;
    }
}

make_entity_sentient_cp( var_0, var_1 )
{
    if ( !isdefined( var_1 ) )
        var_1 = 1;

    if ( var_1 )
        return self makeentitysentient( var_0, 1 );
    else
        return self makeentitysentient( var_0 );
}

get_attacker_as_player( var_0 )
{
    if ( isdefined( var_0 ) )
    {
        if ( isplayer( var_0 ) )
            return var_0;

        if ( isdefined( var_0.owner ) && isplayer( var_0.owner ) )
            return var_0.owner;
    }

    return undefined;
}

removeexcludedattachments( var_0 )
{
    if ( isdefined( level.excludedattachments ) )
    {
        foreach ( var_2 in level.excludedattachments )
        {
            foreach ( var_4 in var_0 )
            {
                if ( attachmentmap_tobase( var_4 ) == var_2 )
                    var_0 = scripts\engine\utility::array_remove( var_0, var_4 );
            }
        }
    }

    return var_0;
}

getrandomweaponattachments( var_0, var_1, var_2 )
{
    var_3 = [];

    if ( weaponhaspassive( var_0, var_1, "passive_random_attachments" ) )
    {
        if ( 0 )
        {
            var_4 = getavailableattachments( var_0, var_2, 0 );
            var_3[var_3.size] = var_4[randomint( var_4.size )];
        }
        else
        {
            var_5 = int( max( 0, 5 - var_2.size ) );

            if ( var_5 > 0 )
            {
                var_6 = randomintrange( 1, var_5 + 1 );
                var_3 = buildrandomattachmentarray( var_0, var_6, var_2 );
            }
        }
    }

    return var_3;
}

weaponhaspassive( var_0, var_1, var_2 )
{
    var_3 = getweaponpassives( var_0, var_1 );

    if ( !isdefined( var_3 ) || var_3.size <= 0 )
        return 0;

    foreach ( var_5 in var_3 )
    {
        if ( var_2 == var_5 )
            return 1;
    }

    return 0;
}

buildrandomattachmentarray( var_0, var_1, var_2 )
{
    var_3 = [];
    var_4 = scripts\cp\cp_weapon::getattachmenttypeslist( var_0, var_2 );

    if ( var_4.size > 0 )
    {
        var_3 = [];
        var_5 = scripts\engine\utility::array_randomize_objects( var_4 );

        foreach ( var_10, var_7 in var_5 )
        {
            if ( var_1 <= 0 )
                break;

            var_8 = 1;

            switch ( var_10 )
            {
                case "undermount":
                case "barrel":
                    var_8 = 1;
                    break;
                case "rail":
                case "pap":
                case "perk":
                    var_8 = 0;
                    break;
                default:
                    var_8 = randomintrange( 1, var_1 + 1 );
                    break;
            }

            if ( var_8 > 0 )
            {
                if ( var_8 > var_7.size )
                    var_8 = var_7.size;

                var_1 = var_1 - var_8;

                for ( var_7 = scripts\engine\utility::array_randomize_objects( var_7 ); var_8 > 0; var_8-- )
                {
                    var_9 = var_7[var_7.size - var_8];

                    if ( !issubstr( var_9, "ark" ) && !issubstr( var_9, "arcane" ) )
                        var_3[var_3.size] = var_9;
                }
            }
        }
    }

    return var_3;
}

getavailableattachments( var_0, var_1, var_2 )
{
    if ( !isdefined( var_2 ) )
        var_2 = 1;

    var_3 = getweaponattachmentarrayfromstats( var_0 );
    var_4 = [];

    foreach ( var_6 in var_3 )
    {
        var_7 = getattachmenttype( var_6 );

        if ( !var_2 && var_7 == "rail" )
            continue;

        if ( isdefined( var_1 ) && listhasattachment( var_1, var_6 ) )
            continue;

        var_4[var_4.size] = var_6;
    }

    return var_4;
}

listhasattachment( var_0, var_1 )
{
    foreach ( var_3 in var_0 )
    {
        if ( var_3 == var_1 )
            return 1;
    }

    return 0;
}

getweaponattachmentarrayfromstats( var_0 )
{
    var_1 = getweaponrootname( var_0 );

    if ( !isdefined( level.weaponattachments ) )
        level.weaponattachments = [];

    if ( !isdefined( level.weaponattachments[var_1] ) )
    {
        var_2 = [];

        for ( var_3 = 0; var_3 < 10; var_3++ )
        {
            var_4 = tablelookup( "mp/statstable.csv", 4, var_1, 10 + var_3 );

            if ( var_4 == "" )
                break;

            var_2[var_2.size] = var_4;
        }

        level.weaponattachments[var_1] = var_2;
    }

    return level.weaponattachments[var_1];
}

getweaponpaintjobid( var_0 )
{
    return -1;
}

getweaponcamo( var_0 )
{
    var_1 = self getplayerdata( "cp", "zombiePlayerLoadout", "zombiePlayerWeaponModels", var_0, "camo" );

    if ( isdefined( var_1 ) && var_1 != "none" )
        return var_1;
    else
        return "none";
}

getweaponcosmeticattachment( var_0 )
{
    var_1 = self getplayerdata( "cp", "zombiePlayerLoadout", "zombiePlayerWeaponModels", var_0, "cosmeticAttachment" );

    if ( isdefined( var_1 ) && var_1 != "none" )
        return var_1;
    else
        return "none";
}

getweaponreticle( var_0 )
{
    var_1 = self getplayerdata( "cp", "zombiePlayerLoadout", "zombiePlayerWeaponModels", var_0, "reticle" );

    if ( isdefined( var_1 ) && var_1 != "none" )
        return var_1;
    else
        return "none";
}

mpbuildweaponname( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8 )
{
    var_9 = weaponattachdefaultmap( var_0 );
    var_10 = buildweaponassetname( var_0, var_4 );
    var_11 = coop_getweaponclass( var_10 );

    if ( isdefined( var_9 ) )
        var_1 = scripts\engine\utility::array_combine_unique( var_1, var_9 );

    var_1 = weaponattachremoveextraattachments( var_1 );
    var_1 = removeexcludedattachments( var_1 );

    for ( var_12 = 0; var_12 < var_1.size; var_12++ )
        var_1[var_12] = attachmentmap_tounique( var_1[var_12], var_10 );

    if ( isdefined( var_9 ) )
    {
        for ( var_12 = 0; var_12 < var_9.size; var_12++ )
            var_9[var_12] = attachmentmap_tounique( var_9[var_12], var_10 );
    }

    if ( isdefined( var_9 ) )
        var_1 = scripts\engine\utility::array_combine_unique( var_1, var_9 );

    var_1 = scripts\engine\utility::array_remove( var_1, "none" );

    if ( isdefined( var_8 ) && var_8 != "none" )
        var_1[var_1.size] = var_8;

    if ( var_1.size > 0 )
        var_1 = filterattachments( var_1 );

    var_13 = [];

    foreach ( var_15 in var_1 )
    {
        var_16 = attachmentmap_toextra( var_15 );

        if ( isdefined( var_16 ) )
            var_13[var_13.size] = attachmentmap_tounique( var_16, var_10 );
    }

    if ( var_13.size > 0 )
        var_1 = scripts\engine\utility::array_combine_unique( var_1, var_13 );

    if ( var_1.size > 0 )
        var_1 = scripts\engine\utility::alphabetize( var_1 );

    var_10 = reassign_weapon_name( var_10, var_1 );

    foreach ( var_19 in var_1 )
        var_10 = var_10 + ( "+" + var_19 );

    if ( issubstr( var_10, "iw7" ) )
    {
        var_10 = buildweaponnamecamo( var_10, var_2, var_4 );
        var_21 = 0;

        if ( isholidayweapon( var_10, var_4 ) )
            var_21 = isholidayweaponusingdefaultscope( var_10, var_1 );

        if ( var_21 )
            var_10 = var_10 + "+scope1";
        else
            var_10 = buildweaponnamereticle( var_10, var_3 );

        var_10 = buildweaponnamevariantid( var_10, var_4 );
    }

    return var_10;
}

reassign_weapon_name( var_0, var_1 )
{
    if ( isdefined( level.weapon_upgrade_path ) && isdefined( level.weapon_upgrade_path[getweaponbasename( var_0 )] ) )
        return var_0;
    else
    {
        switch ( var_0 )
        {
            case "iw7_machete_mp":
                if ( istrue( self.base_weapon ) )
                    var_0 = "iw7_machete_mp";
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 1 || istrue( self.ephemeral_downgrade ) )
                {
                    if ( istrue( self.bang_bangs ) )
                        var_0 = "iw7_machete_mp";
                    else
                        var_0 = "iw7_machete_mp_pap1";
                }
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 2 )
                {
                    if ( istrue( self.bang_bangs ) )
                        var_0 = "iw7_machete_mp_pap1";
                    else
                        var_0 = "iw7_machete_mp_pap2";
                }
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 3 )
                    var_0 = "iw7_machete_mp_pap2";

                break;
            case "iw7_two_headed_axe_mp":
                if ( istrue( self.base_weapon ) )
                    var_0 = "iw7_two_headed_axe_mp";
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 1 || istrue( self.ephemeral_downgrade ) )
                {
                    if ( istrue( self.bang_bangs ) )
                        var_0 = "iw7_two_headed_axe_mp";
                    else
                        var_0 = "iw7_two_headed_axe_mp_pap1";
                }
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 2 )
                {
                    if ( istrue( self.bang_bangs ) )
                        var_0 = "iw7_two_headed_axe_mp_pap1";
                    else
                        var_0 = "iw7_two_headed_axe_mp_pap2";
                }
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 3 )
                    var_0 = "iw7_two_headed_axe_mp_pap2";

                break;
            case "iw7_spiked_bat_mp":
                if ( istrue( self.base_weapon ) )
                    var_0 = "iw7_spiked_bat_mp";
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 1 || istrue( self.ephemeral_downgrade ) )
                {
                    if ( istrue( self.bang_bangs ) )
                        var_0 = "iw7_spiked_bat_mp";
                    else
                        var_0 = "iw7_spiked_bat_mp_pap1";
                }
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 2 )
                {
                    if ( istrue( self.bang_bangs ) )
                        var_0 = "iw7_spiked_bat_mp_pap1";
                    else
                        var_0 = "iw7_spiked_bat_mp_pap2";
                }
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 3 )
                    var_0 = "iw7_spiked_bat_mp_pap2";

                break;
            case "iw7_golf_club_mp":
                if ( istrue( self.base_weapon ) )
                    var_0 = "iw7_golf_club_mp";
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 1 || istrue( self.ephemeral_downgrade ) )
                {
                    if ( istrue( self.bang_bangs ) )
                        var_0 = "iw7_golf_club_mp";
                    else
                        var_0 = "iw7_golf_club_mp_pap1";
                }
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 2 )
                {
                    if ( istrue( self.bang_bangs ) )
                        var_0 = "iw7_golf_club_mp_pap1";
                    else
                        var_0 = "iw7_golf_club_mp_pap2";
                }
                else if ( isdefined( self.pap[getrawbaseweaponname( var_0 )] ) && self.pap[getrawbaseweaponname( var_0 )].lvl == 3 )
                    var_0 = "iw7_golf_club_mp_pap2";

                break;
            case "iw7_axe_zm":
                if ( scripts\engine\utility::array_contains( var_1, "axepap1" ) )
                    var_0 = "iw7_axe_zm_pap1";
                else if ( scripts\engine\utility::array_contains( var_1, "axepap2" ) )
                    var_0 = "iw7_axe_zm_pap2";

                break;
            case "iw7_katana_zm":
                if ( scripts\engine\utility::array_contains( var_1, "katanapap1" ) )
                    var_0 = "iw7_katana_zm_pap1";
                else if ( scripts\engine\utility::array_contains( var_1, "katanapap2" ) )
                    var_0 = "iw7_katana_zm_pap2";

                break;
            case "iw7_nunchucks_zm":
                if ( scripts\engine\utility::array_contains( var_1, "nunchuckspap1" ) )
                    var_0 = "iw7_nunchucks_zm_pap1";
                else if ( scripts\engine\utility::array_contains( var_1, "nunchuckspap2" ) )
                    var_0 = "iw7_nunchucks_zm_pap2";

                break;
            case "iw7_forgefreeze_zm":
                if ( scripts\engine\utility::array_contains( var_1, "freezepap1" ) )
                    var_0 = "iw7_forgefreeze_zm_pap1";
                else if ( scripts\engine\utility::array_contains( var_1, "freezepap2" ) )
                    var_0 = "iw7_forgefreeze_zm_pap2";

                break;
            case "iw7_shredder_zm":
                if ( scripts\engine\utility::array_contains( var_1, "shredderpap1" ) )
                    var_0 = "iw7_shredder_zm_pap1";

                break;
            case "iw7_dischord_zm":
                if ( scripts\engine\utility::array_contains( var_1, "dischordpap1" ) )
                    var_0 = "iw7_dischord_zm_pap1";

                break;
            case "iw7_facemelter_zm":
                if ( scripts\engine\utility::array_contains( var_1, "fmpap1" ) )
                    var_0 = "iw7_facemelter_zm_pap1";

                break;
            case "iw7_headcutter_zm":
                if ( scripts\engine\utility::array_contains( var_1, "hcpap1" ) )
                    var_0 = "iw7_headcutter_zm_pap1";

                break;
        }
    }

    return var_0;
}

get_weapon_variant_id( var_0, var_1 )
{
    var_2 = getbaseweaponname( var_1 );
    return -1;
}

weaponhasvariants( var_0 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    var_1 = undefined;

    if ( issameweapon( var_0 ) )
        var_1 = var_0.basename;
    else
        var_1 = var_0;

    switch ( var_0 )
    {
        case "iw7_glprox":
        case "iw7_lockon":
        case "iw7_chargeshot":
        case "iw7_axe":
        case "iw7_g18c":
        case "iw7_arclassic":
        case "iw7_spasc":
        case "iw7_cheytacc":
        case "iw7_ump45c":
        case "iw7_m1c":
            return 0;
        default:
            return 1;
    }
}

weaponattachremoveextraattachments( var_0, var_1 )
{
    var_2 = [];

    foreach ( var_4 in var_0 )
    {
        var_5 = attachmentmap_tounique( var_4, var_1 );
        var_6 = attachmentmap_toextra( var_5 );

        if ( isdefined( var_6 ) )
            var_2[var_2.size] = var_6;
    }

    var_8 = [];

    foreach ( var_4 in var_0 )
    {
        var_10 = 0;

        foreach ( var_6 in var_2 )
        {
            if ( var_4 == var_6 )
            {
                var_10 = 1;
                break;
            }
        }

        if ( !var_10 )
            var_8[var_8.size] = var_4;
    }

    return var_8;
}

weaponattachdefaultmap( var_0 )
{
    if ( isdefined( level.weaponmapdata[var_0] ) && isdefined( level.weaponmapdata[var_0].attachdefaults ) )
        return level.weaponmapdata[var_0].attachdefaults;

    return undefined;
}

weaponassetnamemap( var_0, var_1 )
{
    if ( iskillstreakweapon( var_0 ) )
        return var_0;

    if ( isdefined( var_1 ) )
    {
        var_2 = var_0 + "|" + var_1;

        if ( isdefined( level.weaponlootmapdata[var_2] ) && isdefined( level.weaponlootmapdata[var_2].assetoverridename ) )
            return level.weaponlootmapdata[var_2].assetoverridename;
    }

    if ( isdefined( level.weaponmapdata[var_0] ) && isdefined( level.weaponmapdata[var_0].assetname ) )
        return level.weaponmapdata[var_0].assetname;

    return var_0;
}

iskillstreakweapon( var_0 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    var_1 = undefined;

    if ( issameweapon( var_0 ) )
        var_1 = var_0.basename;
    else
        var_1 = var_0;

    if ( isdefined( level.killstreakweaponmap ) && isdefined( level.killstreakweaponmap[var_1] ) )
        return 1;

    return 0;
}

buildweaponassetname( var_0, var_1 )
{
    return weaponassetnamemap( var_0, var_1 );
}

getweaponassetfromrootweapon( var_0, var_1 )
{
    var_2 = "mp/loot/weapon/" + var_0 + ".csv";
    var_3 = tablelookup( var_2, 0, var_1, 3 );
    return var_3;
}

getweaponvariantattachments( var_0, var_1 )
{
    var_2 = [];
    var_3 = getweaponpassives( var_0, var_1 );

    if ( isdefined( var_3 ) )
    {
        foreach ( var_5 in var_3 )
        {
            var_6 = getpassiveattachment( var_5 );

            if ( !isdefined( var_6 ) )
                continue;

            var_2[var_2.size] = var_6;
        }
    }

    return var_2;
}

getpassiveattachment( var_0 )
{
    var_1 = getpassivestruct( var_0 );

    if ( !isdefined( var_1 ) || !isdefined( var_1.attachmentref ) )
        return undefined;

    return var_1.attachmentref;
}

getweaponpassives( var_0, var_1 )
{
    return getpassivesforweapon( var_0, var_1 );
}

getpassivesforweapon( var_0, var_1 )
{
    var_2 = getlootinfoforweapon( var_0, var_1 );

    if ( isdefined( var_2 ) )
        return var_2.passives;

    return undefined;
}

getlootinfoforweapon( var_0, var_1 )
{
    var_2 = getweaponrootname( var_0 );

    if ( !isdefined( level.lootweaponcache ) )
        level.lootweaponcache = [];

    if ( isdefined( level.lootweaponcache[var_2] ) && isdefined( level.lootweaponcache[var_2][var_1] ) )
    {
        var_3 = level.lootweaponcache[var_2][var_1];
        return var_3;
    }

    var_3 = cachelootweaponweaponinfo( var_0, var_2, var_1 );

    if ( isdefined( var_3 ) )
        return var_3;

    return undefined;
}

getweaponrootname( var_0 )
{
    var_1 = undefined;

    if ( issameweapon( var_0 ) )
        var_1 = var_0.basename;
    else
        var_1 = var_0;

    var_2 = level.weaponrootcache[var_1];

    if ( isdefined( var_2 ) )
        return var_2;

    var_3 = var_1;
    var_4 = strtok( var_1, "_" );
    var_5 = 0;

    if ( var_4[0] == "alt" )
        var_5++;

    if ( var_4[var_5] == "iw8" )
    {
        var_6 = [ "ar", "sm", "lm", "sh", "sn", "dm", "pi", "la", "me" ];

        if ( scripts\engine\utility::array_contains( var_6, var_4[var_5 + 1] ) )
            var_1 = var_4[var_5] + "_" + var_4[var_5 + 1] + "_" + var_4[var_5 + 2];
        else
            var_1 = var_4[var_5] + "_" + var_4[var_5 + 1];
    }

    if ( level.weaponrootcache.size < 100 )
        level.weaponrootcache[var_3] = var_1;

    return var_1;
}

make_focus_fire_icon_anchor( var_0 )
{
    var_1 = getweaponrootname( var_0 );

    if ( isdefined( level.weaponmapdata[var_1] ) && isdefined( level.weaponmapdata[var_1].assetname ) )
        var_0 = level.weaponmapdata[var_1].assetname;

    return var_0;
}

weapon_is_a_cp_mod( var_0, var_1 )
{
    if ( isdefined( var_0[var_1 + 3] ) && isdefined( var_0[var_1 + 4] ) )
        return 1;

    return 0;
}

weapon_is_cp_loot( var_0 )
{
    var_1 = undefined;

    if ( issameweapon( var_0 ) )
        var_1 = var_0.basename;
    else
        var_1 = var_0;

    return issubstr( var_1, "commmon" ) || issubstr( var_1, "uncommon" ) || issubstr( var_1, "rare" ) || issubstr( var_1, "legendary" ) || issubstr( var_1, "epic" ) || issubstr( var_1, "godtier" );
}

weapon_is_dlc2_melee( var_0 )
{
    var_1 = undefined;

    if ( issameweapon( var_0 ) )
        var_1 = var_0.basename;
    else
        var_1 = var_0;

    return issubstr( var_1, "katana" ) || issubstr( var_1, "nunchucks" );
}

weapon_is_dlc_melee( var_0 )
{
    var_1 = undefined;

    if ( issameweapon( var_0 ) )
        var_1 = var_0.basename;
    else
        var_1 = var_0;

    return issubstr( var_1, "two_headed" ) || issubstr( var_1, "spiked_bat" ) || issubstr( var_1, "machete" ) || issubstr( var_1, "golf_club" );
}

cachelootweaponweaponinfo( var_0, var_1, var_2 )
{
    if ( !isdefined( level.lootweaponcache[var_1] ) )
        level.lootweaponcache[var_1] = [];

    var_3 = getweaponloottable( var_0 );
    var_4 = readweaponinfofromtable( var_3, var_2 );
    level.lootweaponcache[var_1][var_2] = var_4;
    return var_4;
}

readweaponinfofromtable( var_0, var_1 )
{
    var_2 = tablelookuprownum( var_0, 0, var_1 );
    var_3 = spawnstruct();
    var_3.ref = tablelookupbyrow( var_0, var_2, 1 );
    var_3.weaponasset = tablelookupbyrow( var_0, var_2, 3 );
    var_3.passives = [];

    for ( var_4 = 0; var_4 < 3; var_4++ )
    {
        var_5 = tablelookupbyrow( var_0, var_2, 5 + var_4 );

        if ( isdefined( var_5 ) && var_5 != "" )
            var_3.passives[var_3.passives.size] = var_5;
    }

    return var_3;
}

fire_rate( var_0 )
{
    var_1 = spawn( "script_model", var_0.origin );
    var_1 setmodel( "container_ammo_box_01_nophysics" );
    var_1.angles = var_0.angles;
    var_1.targetname = var_0.targetname;
    return var_1;
}

create_fake_loot( var_0 )
{
    if ( istrue( self.available ) )
        return;

    if ( istrue( level.getsuperrefforsuperextraweapon ) )
        return;

    self show();
    self.available = 1;
    var_1 = undefined;

    if ( isdefined( var_0 ) )
    {
        if ( isstring( var_0 ) )
            var_1 = [ var_0 ];
        else
            var_1 = var_0;
    }
    else if ( istrue( level.getsubgametype ) )
        var_1 = [ "brloot_munition_grenade_crate", "brloot_munition_armor" ];
    else
        var_1 = [ "brloot_munition_ammo", "brloot_munition_grenade_crate", "brloot_munition_armor" ];

    self.loot_type = scripts\engine\utility::random( var_1 );
    var_2 = &"COOP_CRAFTING/AMMO_CRATE";

    switch ( self.loot_type )
    {
        case "brloot_munition_grenade_crate":
            var_2 = &"CP_BR/GRENADE_CRATE";
            break;
        case "brloot_munition_armor":
            var_2 = &"CP_BR/ARMOR_CRATE";
            break;
        case "brloot_munition_deployable_cover":
            var_2 = &"EQUIPMENT/TACTICAL_COVER";
            break;
    }

    self setmodel( "offhand_wm_supportbox_killstreak" );
    self.origin = self.origin + ( 0, 0, 16 );

    if ( self tagexists( "tag_use" ) )
        sethintobject( "tag_use", "HINT_BUTTON", undefined, var_2, 25, "duration_none", "show", 128, 80, 128, 80 );
    else
        sethintobject( undefined, "HINT_BUTTON", undefined, var_2, 25, "duration_none", "show", 128, 80, 128, 80 );

    for (;;)
    {
        self waittill( "trigger", var_3 );

        if ( !var_3 is_valid_player() )
            continue;

        if ( !scripts\cp\loot_system::give_munition( self.loot_type, var_3 ) )
            continue;

        self playsoundtoplayer( "scavenger_pack_pickup", var_3 );
        self makeunusable();
        self hide();
        self.available = 0;
        return;
    }
}

filterattachments( var_0 )
{
    var_1 = [];

    if ( isdefined( var_0 ) )
    {
        for ( var_2 = 0; var_2 < var_0.size; var_2++ )
        {
            var_3 = var_0[var_2];

            if ( var_3 == "none" )
                continue;

            var_4 = 1;

            for ( var_5 = 0; var_5 < var_1.size; var_5++ )
            {
                if ( var_3 == var_1[var_5] )
                {
                    var_4 = 0;
                    break;
                }

                var_6 = scripts\cp\cp_weapon::attachmentsconflict( var_3, var_1[var_5] );

                if ( var_6 != "" )
                {
                    var_4 = 0;
                    var_1 = scripts\engine\utility::array_remove_index( var_1, var_5 );
                    var_7 = [];
                    var_7 = strtok( var_6, " " );

                    foreach ( var_10, var_9 in var_7 )
                        var_0 = scripts\engine\utility::array_insert( var_0, var_9, var_2 + 1 + var_10 );

                    break;
                }
            }

            if ( var_4 )
                var_1[var_1.size] = var_3;
        }
    }

    return var_1;
}

attachmentiscosmetic( var_0 )
{
    return isdefined( var_0 ) && scripts\engine\utility::string_starts_with( var_0, "cos_" );
}

attachmentmap_toextra( var_0 )
{
    var_1 = undefined;

    if ( isdefined( level.attachmentmap_uniquetoextra[var_0] ) )
        var_1 = level.attachmentmap_uniquetoextra[var_0];

    return var_1;
}

getpassivestruct( var_0 )
{
    if ( !isdefined( level.passivemap[var_0] ) )
        return undefined;

    var_1 = level.passivemap[var_0];
    return var_1;
}

map_check( var_0 )
{
    if ( !isdefined( var_0 ) )
        return 1;

    switch ( var_0 )
    {
        case 0:
            if ( level.script == "cp_zmb" )
                return 1;
            else
                return 0;
        case 1:
            if ( level.script == "cp_rave" )
                return 1;
            else
                return 0;
        case 2:
            if ( level.script == "cp_disco" )
                return 1;
            else
                return 0;
        case 3:
            if ( level.script == "cp_town" )
                return 1;
            else
                return 0;
        default:
            return 1;
    }
}

buildweaponname( var_0, var_1, var_2, var_3, var_4 )
{
    if ( isstrstart( var_0, "iw7_" ) )
        var_2 = 0;

    var_5 = [];

    foreach ( var_7 in var_1 )
        var_5[var_5.size] = attachmentmap_tounique( var_7, var_0 );

    var_9 = getrawbaseweaponname( var_0 );
    var_10 = var_0;
    var_11 = var_9 == "kbs" || var_9 == "cheytac" || var_9 == "m8" || var_9 == "ripper" || var_9 == "erad" || var_9 == "ar57";

    if ( var_11 )
    {
        var_12 = 0;

        foreach ( var_7 in var_5 )
        {
            if ( getattachmenttype( var_7 ) == "rail" )
            {
                var_12 = 1;
                break;
            }
        }

        if ( !var_12 )
            var_5[var_5.size] = var_9 + "scope";
    }

    if ( var_5.size > 0 )
    {
        var_15 = scripts\engine\utility::array_remove_duplicates( var_5 );
        var_5 = scripts\engine\utility::alphabetize( var_15 );
    }

    foreach ( var_7 in var_5 )
        var_10 = var_10 + ( "+" + var_7 );

    if ( issubstr( var_10, "iw6" ) || issubstr( var_10, "iw7" ) )
    {
        var_10 = buildweaponnamecamo( var_10, var_2 );

        if ( var_4 != "weapon_sniper" && isdefined( var_3 ) )
            var_10 = buildweaponnamereticle( var_10, var_3 );
    }
    else if ( !scripts\cp\cp_weapon::isvalidzombieweapon( var_10 + "_mp" ) )
        var_10 = var_0 + "_mp";
    else
    {
        var_10 = buildweaponnamecamo( var_10, var_2 );
        var_10 = buildweaponnamereticle( var_10, var_3 );
        var_10 = var_10 + "_mp";
    }

    return var_10;
}

buildweaponnamevariantid( var_0, var_1 )
{
    if ( !isdefined( var_1 ) || var_1 < 0 )
        return var_0;

    var_0 = var_0 + ( "+loot" + var_1 );
    return var_0;
}

isholidayweapon( var_0, var_1 )
{
    if ( !isdefined( var_1 ) || var_1 < 0 )
        return 0;

    if ( var_1 == 6 )
    {
        var_2 = getweaponrootname( var_0 );
        return var_2 == "iw7_ripper" || var_2 == "iw7_lmg03" || var_2 == "iw7_ar57";
    }

    return 0;
}

ismark2weapon( var_0 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    return var_0 >= 32;
}

isholidayweaponusingdefaultscope( var_0, var_1 )
{
    var_2 = attachmentmap_tounique( "scope", getweaponbasename( var_0 ) );
    return isdefined( var_2 ) && scripts\engine\utility::array_contains( var_1, var_2 );
}

is_pap_camo( var_0 )
{
    if ( isdefined( level.pap_1_camo ) && var_0 == level.pap_1_camo )
        return 1;
    else if ( isdefined( level.pap_2_camo ) && var_0 == level.pap_2_camo )
        return 1;

    return 0;
}

buildweaponnamecamo( var_0, var_1, var_2 )
{
    if ( !isdefined( var_1 ) )
        return var_0;

    if ( var_1 == "none" )
        return var_0;

    return var_0 + "+camo|" + var_1;
}

getweaponqualitybyid( var_0, var_1 )
{
    if ( !isdefined( var_1 ) || var_1 < 0 )
        return 0;

    var_2 = getweaponloottable( var_0 );
    var_3 = int( tablelookup( var_2, 0, var_1, 4 ) );
    return var_3;
}

buildweaponnamereticle( var_0, var_1 )
{
    if ( !isdefined( var_1 ) )
        return var_0;

    var_2 = int( tablelookup( "mp/reticleTable.csv", 1, var_1, 5 ) );

    if ( !isdefined( var_2 ) || var_2 == 0 )
        return var_0;

    var_0 = var_0 + ( "+scope" + var_2 );
    return var_0;
}

has_zombie_perk( var_0 )
{
    if ( !isdefined( self.zombies_perks ) )
        return 0;

    return istrue( self.zombies_perks[var_0] );
}

drawsphere( var_0, var_1, var_2, var_3 )
{
    if ( !isdefined( var_3 ) )
        var_3 = ( 1, 1, 1 );

    var_4 = int( var_2 * 20 );

    for ( var_5 = 0; var_5 < var_4; var_5++ )
        wait 0.05;
}

has_auto_revive()
{
    return istrue( self.has_auto_revive ) || istrue( self.c130_revive );
}

set_alien_emissive( var_0, var_1 )
{
    var_2 = self.maxemissive - self.defaultemissive;
    var_3 = var_1 * var_2 + self.defaultemissive;
    self emissiveblend( var_0, var_3 );
}

get_adjusted_armor( var_0, var_1 )
{
    if ( var_0 + level.deployablebox_vest_rank[var_1] > level.deployablebox_vest_max )
        return level.deployablebox_vest_max;

    return var_0 + level.deployablebox_vest_rank[var_1];
}

alien_mode_has( var_0 )
{
    var_0 = tolower( var_0 );

    if ( !isdefined( level.alien_mode_feature ) )
        return 0;

    if ( !isdefined( level.alien_mode_feature[var_0] ) )
        return 0;

    return level.alien_mode_feature[var_0];
}

enable_alien_scripted()
{
    self.alien_scripted = 1;
    self notify( "alien_main_loop_restart" );
}

is_normal_upright( var_0 )
{
    var_1 = ( 0, 0, 1 );
    var_2 = 0.85;
    return vectordot( var_0, var_1 ) > var_2;
}

get_synch_direction_list( var_0 )
{
    if ( !isdefined( self.synch_attack_setup ) )
        return [];

    if ( !isdefined( self.synch_attack_setup.synch_directions ) )
        return [];

    if ( !self.synch_attack_setup.type_specific )
        return self.synch_attack_setup.synch_directions;

    var_1 = scripts\cp\cp_agent_utils::get_agent_type( var_0 );

    if ( !isdefined( self.synch_attack_setup.synch_directions[var_1] ) )
        var_2 = "Synch attack on " + self.synch_attack_setup.identifier + " doesn't handle type: " + var_1;

    return self.synch_attack_setup.synch_directions[var_1];
}

getrandomindex( var_0 )
{
    var_1 = 0;

    foreach ( var_3 in var_0 )
        var_1 = var_1 + var_3;

    var_5 = randomintrange( 0, var_1 );
    var_1 = 0;

    foreach ( var_7, var_3 in var_0 )
    {
        var_1 = var_1 + var_3;

        if ( var_5 <= var_1 )
            return var_7;
    }

    return 0;
}

get_closest_living_player( var_0, var_1 )
{
    var_2 = 1073741824;

    if ( isdefined( var_0 ) )
        var_2 = var_0;

    var_3 = undefined;
    var_4 = level.players;

    if ( isdefined( var_1 ) )
        var_4 = var_1;

    foreach ( var_6 in var_4 )
    {
        if ( isdefined( level.ignoredbycheck ) && [[ level.ignoredbycheck ]]( self, var_6 ) )
            continue;

        if ( scripts\cp\cp_laststand::player_in_laststand( var_6 ) )
            continue;

        var_7 = distancesquared( self.origin, var_6.origin );

        if ( var_6 scripts\cp_mp\utility\player_utility::_isalive() && var_7 < var_2 )
        {
            var_3 = var_6;
            var_2 = var_7;
        }
    }

    return var_3;
}

get_array_of_valid_players( var_0, var_1 )
{
    var_2 = [];

    for ( var_3 = 0; var_3 < level.players.size; var_3++ )
    {
        if ( level.players[var_3] is_valid_player() )
            var_2[var_2.size] = level.players[var_3];
    }

    if ( !isdefined( var_0 ) || !var_0 )
        return var_2;

    return scripts\engine\utility::get_array_of_closest( var_1, var_2 );
}

is_valid_player( var_0, var_1 )
{
    if ( !isplayer( self ) )
        return 0;

    if ( !isdefined( self ) )
        return 0;

    if ( !isalive( self ) )
        return 0;

    if ( self.sessionstate == "spectator" )
        return 0;

    if ( !isdefined( var_0 ) && scripts\cp\cp_laststand::player_in_laststand( self ) )
        return 0;

    if ( !isdefined( var_1 ) )
        var_1 = 1;

    if ( !istrue( var_1 ) && ( istrue( self.infreefall ) || istrue( self.inparachute ) ) )
        return 0;

    return 1;
}

any_player_nearby( var_0, var_1 )
{
    foreach ( var_3 in level.players )
    {
        if ( distancesquared( var_3.origin, var_0 ) < var_1 )
            return 1;
    }

    return 0;
}

give_closest_player_nearby( var_0, var_1, var_2 )
{
    var_3 = [];

    foreach ( var_5 in level.players )
    {
        if ( isdefined( var_2 ) && var_5.team != var_2 )
            continue;

        if ( distancesquared( var_5.origin, var_0 ) < var_1 )
            var_3[var_3.size] = var_5;
    }

    if ( var_3.size > 0 )
    {
        var_7 = sortbydistance( var_3, var_0 );
        return var_7[0];
    }

    return undefined;
}

are_all_players_nearby( var_0, var_1 )
{
    foreach ( var_3 in level.players )
    {
        if ( distancesquared( var_3.origin, var_0 ) > var_1 )
            return 0;

        wait 0.05;
    }

    return 1;
}

give_all_players_nearby( var_0, var_1 )
{
    var_2 = [];

    for ( var_3 = 0; var_3 < level.players.size; var_3++ )
    {
        if ( distancesquared( level.players[var_3].origin, var_0 ) < var_1 )
            var_2[var_2.size] = level.players[var_3];
    }

    return var_2;
}

player_pain_vo( var_0 )
{
    self endon( "disconnect" );

    if ( getdvarint( "scr_no_player_pain_vo", 0 ) == 1 )
        return;

    var_1 = 5500;
    var_2 = gettime();

    if ( !isdefined( self.next_pain_vo_time ) )
        self.next_pain_vo_time = var_2 + randomintrange( var_1, var_1 + 2000 );
    else if ( var_2 < self.next_pain_vo_time )
        return;

    while ( scripts\cp\cp_music_and_dialog::vo_is_playing() )
        wait 0.1;

    if ( isdefined( self.vo_prefix ) )
    {
        if ( soundexists( self.vo_prefix + "plr_pain" ) )
            playlocalsound_safe( self.vo_prefix + "plr_pain" );
        else if ( soundexists( self.vo_prefix + "pain" ) )
            playlocalsound_safe( self.vo_prefix + "pain" );
    }

    var_3 = "injured_pain_vocal";

    if ( isdefined( var_0 ) )
    {
        if ( isdefined( var_0.agent_type ) )
        {
            switch ( var_0.agent_type )
            {
                case "skater":
                    var_3 = "injured_pain_skater";
                    break;
                case "ratking":
                    var_3 = scripts\engine\utility::random( [ "injured_pain_ratking1", "injured_pain_ratking2", "injured_pain_ratking3" ] );
                    break;
                default:
                    var_3 = "injured_pain_vocal";
                    break;
            }
        }
    }

    scripts\cp\cp_vo::try_to_play_vo( var_3, "zmb_comment_vo" );
    self.next_pain_vo_time = var_2 + randomintrange( var_1, var_1 + 1500 );
}

player_pain_breathing_sfx()
{
    level endon( "game_ended" );
    self endon( "disconnect" );

    if ( getdvarint( "scr_no_player_pain_vo", 0 ) == 1 )
        return;

    if ( is_playing_pain_breathing_sfx( self ) )
        return;

    if ( above_pain_breathing_sfx_threshold( self ) )
        return;

    set_is_playing_pain_breathing_sfx( self, 1 );
    var_0 = get_pain_breathing_sfx_alias( self );

    if ( isdefined( var_0 ) )
    {
        if ( soundexists( var_0 ) )
        {
            while ( !above_pain_breathing_sfx_threshold( self ) && !level.gameended )
            {
                if ( !istrue( self.vo_system_playing_vo ) )
                    playlocalsound_safe( var_0 );

                wait 1.5;
            }
        }

        set_is_playing_pain_breathing_sfx( self, 0 );
    }
}

is_playing_pain_breathing_sfx( var_0 )
{
    return istrue( var_0.is_playing_pain_breathing_sfx );
}

above_pain_breathing_sfx_threshold( var_0 )
{
    var_1 = 0.3;
    return var_0.health / var_0.maxhealth > var_1;
}

set_is_playing_pain_breathing_sfx( var_0, var_1 )
{
    var_0.is_playing_pain_breathing_sfx = var_1;
}

get_pain_breathing_sfx_alias( var_0 )
{
    if ( !level.gameended )
    {
        if ( var_0.vo_prefix == "p1_" )
            return "p1_plr_pain";
        else if ( var_0.vo_prefix == "p2_" )
            return "p2_plr_pain";
        else if ( var_0.vo_prefix == "p3_" )
            return "p3_plr_pain";
        else if ( var_0.vo_prefix == "p4_" )
            return "p4_plr_pain";
        else if ( var_0.vo_prefix == "p5_" )
            return "p5_plr_pain";
        else
            return "p3_plr_pain";
    }
}

playvoforpillage( var_0 )
{
    var_1 = var_0.vo_prefix + "good_loot";

    if ( scripts\cp\cp_vo::alias_2d_version_exists( var_0, var_1 ) )
        var_0 playlocalsound_safe( scripts\cp\cp_vo::get_alias_2d_version( var_0, var_1 ) );
    else if ( soundexists( var_1 ) )
        var_0 playlocalsound_safe( var_1 );
}

deployable_box_onuse_message( var_0 )
{
    var_1 = "";

    if ( isdefined( var_0 ) && isdefined( var_0.boxtype ) && isdefined( level.boxsettings[var_0.boxtype].eventstring ) )
        var_1 = level.boxsettings[var_0.boxtype].eventstring;

    thread setlowermessage( "deployable_use", var_1, 3 );
}

is_goon( var_0 )
{
    switch ( var_0 )
    {
        case "goon4":
        case "goon3":
        case "goon2":
        case "goon":
            return 1;
        default:
            return 0;
    }
}

mark_dangerous_nodes( var_0, var_1, var_2 )
{

}

healthregeninit( var_0 )
{
    level.healthregendisabled = var_0;
}

alien_health_per_player_init()
{
    level.alien_health_per_player_scalar = [];
    level.alien_health_per_player_scalar[1] = 0.9;
    level.alien_health_per_player_scalar[2] = 1.0;
    level.alien_health_per_player_scalar[3] = 1.3;
    level.alien_health_per_player_scalar[4] = 1.8;
}

playerhealthregen()
{
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "joined_team" );
    self endon( "joined_spectators" );
    self endon( "faux_spawn" );
    level endon( "game_ended" );

    for (;;)
    {
        scripts\engine\utility::_id_12E3F( "damage", "health_perk_upgrade" );

        if ( !canregenhealth() )
            continue;

        var_0 = scripts\cp\cp_laststand::gethealthcap();
        var_1 = self.health / var_0;

        if ( var_1 >= 1 )
        {
            self.health = var_0;
            continue;
        }

        thread healthregen( gettime(), var_1 );
        thread breathingmanager( gettime(), var_1 );
    }
}

get_within_range( var_0, var_1, var_2 )
{
    var_3 = [];

    for ( var_4 = 0; var_4 < var_1.size; var_4++ )
    {
        if ( distance( var_1[var_4].origin, var_0 ) <= var_2 )
            var_3[var_3.size] = var_1[var_4];
    }

    return var_3;
}

healthregen( var_0, var_1 )
{
    self notify( "healthRegeneration" );
    self endon( "healthRegeneration" );
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "joined_team" );
    self endon( "joined_spectators" );
    level endon( "game_ended" );

    while ( isdefined( self.selfdamaging ) && self.selfdamaging )
        wait 0.2;

    if ( ishealthregendisabled() )
        return;

    var_2 = spawnstruct();
    getregendata( var_2 );
    wait( var_2.activatetime );
    var_3 = gettime();

    for (;;)
    {
        var_4 = scripts\cp\cp_laststand::gethealthcap();
        var_2 = spawnstruct();
        getregendata( var_2 );
        var_1 = self.health / self.maxhealth;

        if ( self.health < int( var_4 ) )
        {
            var_5 = int( self.health + var_2.regenamount );

            if ( var_5 > var_4 )
                var_5 = var_4;

            self.health = var_5;
        }
        else
            break;

        scripts\engine\utility::_id_12E53( var_2.waittimebetweenregen, "force_regeneration" );
    }

    self notify( "healed" );

    if ( isdefined( level.playerinitinvulnerability ) )
        self [[ level.playerinitinvulnerability ]]();

    resetattackerlist();
}

breathingmanager( var_0, var_1 )
{
    self notify( "breathingManager" );
    self endon( "breathingManager" );
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "joined_team" );
    self endon( "joined_spectators" );
    level endon( "game_ended" );

    if ( isusingremote() )
        return;

    if ( !isplayer( self ) )
        return;

    self.breathingstoptime = var_0 + 6000 * self.regenduration;
    wait( 6 * self.regenduration );

    if ( !level.gameended )
    {
        if ( !isdefined( self.vo_prefix ) )
            return;

        if ( !istrue( self.vo_system_playing_vo ) )
        {
            if ( isfemale() )
                playlocalsound_safe( "Fem_breathing_better" );
            else
                playlocalsound_safe( "breathing_better" );
        }
    }
}

getregendata( var_0 )
{
    level.longregentime = 5000;
    level.healthoverlaycutoff = 0.2;
    level.invultime_preshield = 0.35;
    level.invultime_onshield = 0.5;
    level.invultime_postshield = 0.3;
    level.playerhealth_regularregendelay = 2400;
    level.worthydamageratio = 0.1;
    self.prestigehealthregennerfscalar = scripts\cp\perks\cp_prestige::prestige_getslowhealthregenscalar();
    var_1 = 1;

    if ( isdefined( self.perk_data ) )
    {
        if ( isdefined( self.perk_data["regen_time_scalar"] ) )
            var_1 = self.perk_data["regen_time_scalar"];
        else
            var_1 = self.perk_data["health"].regen_time_scalar;
    }

    if ( self.prestigehealthregennerfscalar == 1.0 )
    {
        if ( is_consumable_active( "faster_health_regen_upgrade" ) )
        {
            var_0.activatetime = 0.45;
            var_0.waittimebetweenregen = 0.045;
            var_0.regenamount = 0.1;
        }
        else
        {
            var_0.activatetime = 6;
            var_0.waittimebetweenregen = 0.05;
            var_0.regenamount = 6 * var_1;
        }
    }
    else
    {
        var_0.activatetime = 6 * self.prestigehealthregennerfscalar;
        var_0.waittimebetweenregen = 0.05 * self.prestigehealthregennerfscalar;
        var_0.regenamount = 6;
    }
}

resetattackerlist( var_0 )
{
    self endon( "disconnect" );
    self endon( "death" );
    level endon( "game_ended" );
    wait 1.75;
    resetattackerlist_internal();
}

resetattackerlist_internal()
{
    self.attackers = [];
    self.attackerdata = [];
}

canregenhealth()
{
    if ( getdvarint( "scr_disable_regen_health", 0 ) == 1 )
        return 0;

    if ( istrue( self.isjuggernaut ) )
        return 0;

    if ( scripts\cp\cp_laststand::player_in_laststand( self ) )
        return 0;

    if ( istrue( self.fauxdead ) )
        return 0;

    if ( istrue( self.getsolospawnstruct ) )
        return 0;

    if ( istrue( self._id_11991 ) )
        return 0;

    return 1;
}

playerpainbreathingsound()
{
    level endon( "game_ended" );
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "joined_team" );
    self endon( "joined_spectators" );
    wait 2;

    for (;;)
    {
        wait 0.2;

        if ( shouldplaypainbreathingsound() )
        {
            if ( self.vo_prefix == "p1_" )
            {
                if ( soundexists( "Fem_breathing_hurt" ) )
                    playlocalsound_safe( "Fem_breathing_hurt" );
            }
            else
                playlocalsound_safe( "breathing_hurt" );

            wait 0.784;
            wait( 0.1 + randomfloat( 0.8 ) );
        }
    }
}

shouldplaypainbreathingsound()
{
    if ( ishealthregendisabled() || isusingremote() || isdefined( self.breathingstoptime ) && gettime() < self.breathingstoptime || self.health > self.maxhealth * 0.55 || level.gameended )
        return 0;
    else
        return 1;
}

ishealthregendisabled()
{
    return isdefined( level.healthregendisabled ) && level.healthregendisabled || isdefined( self.healthregendisabled ) && self.healthregendisabled;
}

playerarmor()
{
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "joined_team" );
    self endon( "joined_spectators" );
    self endon( "faux_spawn" );
    self endon( "game_ended" );

    if ( !isdefined( self.bodyarmorhp ) )
        self.bodyarmorhp = 0;

    var_0 = self getentitynumber();
    var_1 = 0;
    scripts\cp\cp_persistence::setcoopplayerdata_for_everyone( "EoGPlayer", var_0, "playerArmor", 0 );

    for (;;)
    {
        scripts\engine\utility::_id_12E3F( "player_damaged", "enable_armor" );

        if ( !isdefined( self.bodyarmorhp ) )
        {
            if ( var_1 > 0 )
            {
                scripts\cp\cp_persistence::setcoopplayerdata_for_everyone( "EoGPlayer", var_0, "playerArmor", 0 );
                var_1 = 0;
            }

            continue;
        }

        if ( var_1 != self.bodyarmorhp )
        {
            var_2 = int( self.bodyarmorhp );
            scripts\cp\cp_persistence::setcoopplayerdata_for_everyone( "EoGPlayer", var_0, "playerArmor", var_1 );
            var_1 = self.bodyarmorhp;
        }
    }
}

allow_secondary_offhand_weapons( var_0 )
{
    if ( var_0 )
    {
        if ( !isdefined( self.disabledsecondaryoffhandweapons ) )
            self.disabledsecondaryoffhandweapons = 0;

        self.disabledsecondaryoffhandweapons--;

        if ( !self.disabledsecondaryoffhandweapons )
            self enableoffhandsecondaryweapons();
    }
    else
    {
        if ( !isdefined( self.disabledsecondaryoffhandweapons ) )
            self.disabledsecondaryoffhandweapons = 0;

        self.disabledsecondaryoffhandweapons++;
        self disableoffhandsecondaryweapons();
    }
}

register_physics_collisions()
{
    self endon( "death" );
    self endon( "stop_phys_sounds" );

    for (;;)
    {
        self waittill( "collision", var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7 );
        level notify( "physSnd", self, var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7 );
    }
}

global_physics_sound_monitor()
{
    level notify( "physics_monitor" );
    level endon( "physics_monitor" );

    for (;;)
    {
        level waittill( "physSnd", var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8 );

        if ( isdefined( var_0 ) && isdefined( var_0.phys_sound_func ) )
            level thread [[ var_0.phys_sound_func ]]( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8 );
    }
}

register_physics_collision_func( var_0, var_1 )
{
    var_0.phys_sound_func = var_1;
}

addtotraplist()
{
    if ( !scripts\engine\utility::array_contains( level.placed_crafted_traps, self ) )
        level.placed_crafted_traps = scripts\engine\utility::array_add_safe( level.placed_crafted_traps, self );

    level.placed_crafted_traps = scripts\engine\utility::array_removeundefined( level.placed_crafted_traps );
}

removefromtraplist()
{
    if ( scripts\engine\utility::array_contains( level.placed_crafted_traps, self ) )
        level.placed_crafted_traps = scripts\engine\utility::array_remove( level.placed_crafted_traps, self );

    level.placed_crafted_traps = scripts\engine\utility::array_removeundefined( level.placed_crafted_traps );
}

ent_is_near_equipment( var_0 )
{
    var_1 = 16384;

    if ( level.turrets.size )
    {
        var_2 = sortbydistance( level.turrets, var_0.origin );

        if ( distance2dsquared( var_2[0].origin, var_0.origin ) < var_1 )
            return 1;
    }

    if ( isdefined( level.placed_crafted_traps ) && level.placed_crafted_traps.size )
    {
        foreach ( var_4 in level.placed_crafted_traps )
        {
            if ( !isdefined( var_4 ) )
                continue;

            if ( distance2dsquared( var_4.origin, var_0.origin ) < var_1 )
                return 1;
        }
    }

    if ( isdefined( level.near_equipment_func ) )
        return [[ level.near_equipment_func ]]( var_0 );

    return 0;
}

set_crafted_inventory_item( var_0, var_1, var_2 )
{
    if ( isdefined( var_2.current_crafted_inventory ) )
        var_2.current_crafted_inventory = undefined;

    var_2.current_crafted_inventory = spawnstruct();
    var_2.current_crafted_inventory.item = var_0;
    var_2.current_crafted_inventory.restore_func = var_1;
}

remove_crafted_item_from_inventory( var_0 )
{
    var_0.current_crafted_inventory = undefined;
}

remove_crafted_item_from_dpad( var_0, var_1 )
{
    switch ( var_1 )
    {
        case "up_dpad":
            break;
        case "down_dpad":
            break;
        case "left_dpad":
            break;
        case "right_dpad":
            break;
    }
}

add_crafted_item_to_dpad( var_0, var_1, var_2 )
{
    switch ( var_1 )
    {
        case "up_dpad":
            break;
        case "down_dpad":
            break;
        case "left_dpad":
            break;
        case "right_dpad":
            break;
    }
}

item_handleownerdisconnect( var_0 )
{
    self endon( "death" );
    level endon( "game_ended" );
    self notify( var_0 );
    self endon( var_0 );
    self.owner waittill( "disconnect" );

    foreach ( var_2 in level.players )
    {
        if ( var_2 is_valid_player( 1 ) )
        {
            self.owner = var_2;

            if ( self.classname != "script_model" )
                self setsentryowner( self.owner );

            break;
        }
    }

    thread item_handleownerdisconnect( var_0 );
}

restore_player_perk()
{
    if ( isdefined( self.restoreperk ) )
    {
        giveperk( self.restoreperk );
        self.restoreperk = undefined;
    }
}

wait_restore_player_perk()
{
    self endon( "death" );
    self endon( "disconnect" );
    level endon( "game_ended" );
    wait 0.05;
    restore_player_perk();
}

remove_player_perks()
{
    if ( _hasperk( "specialty_explosivebullets" ) )
    {
        self.restoreperk = "specialty_explosivebullets";
        _unsetperk( "specialty_explosivebullets" );
    }
}

item_timeout( var_0, var_1, var_2 )
{
    self endon( "death" );
    level endon( "game_ended" );

    if ( !isdefined( self.lifespan ) )
        self.lifespan = var_1;

    if ( isdefined( var_0 ) )
        self.lifespan = var_0;

    while ( self.lifespan )
    {
        wait 1.0;
        scripts\cp\cp_hostmigration::waittillhostmigrationdone();

        if ( !isdefined( self.carriedby ) )
            self.lifespan = max( 0, self.lifespan - 1.0 );
    }

    while ( isdefined( self ) && isdefined( self.inuseby ) )
        wait 0.05;

    if ( isdefined( self.zap_model ) )
        self.zap_model delete();

    if ( isdefined( var_2 ) )
        self notify( var_2 );
    else
        self notify( "death" );
}

item_oncarrierdeath( var_0 )
{
    self endon( "placed" );
    self endon( "death" );
    var_0 endon( "disconnect" );
    var_1 = var_0 scripts\engine\utility::_id_12E47( "death", "last_stand" );
    var_0 notify( "force_cancel_placement" );
}

item_oncarrierdisconnect( var_0 )
{
    self endon( "placed" );
    self endon( "death" );
    var_0 endon( "last_stand" );
    var_0 waittill( "disconnect" );

    if ( isdefined( self.carriedgascan ) )
        self.carriedgascan delete();
    else if ( isdefined( self.carriedmedusa ) )
        self.carriedmedusa delete();
    else if ( isdefined( self.carried_trap ) )
        self.carried_trap delete();
    else if ( isdefined( self.carriedboombox ) )
        self.carriedboombox delete();
    else if ( isdefined( self.carried_fireworks_trap ) )
        self.carried_fireworks_trap delete();
    else if ( isdefined( self.carriedrevocator ) )
        self.carriedrevocator delete();

    self delete();
}

item_ongameended( var_0 )
{
    self endon( "placed" );
    self endon( "death" );
    var_0 endon( "last_stand" );
    level waittill( "game_ended" );
    self delete();
}

should_be_affected_by_trap( var_0, var_1, var_2 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    if ( !isalive( var_0 ) )
        return 0;

    if ( !isagent( var_0 ) )
        return 0;

    if ( !isdefined( var_0.agent_type ) )
        return 0;

    if ( !isdefined( var_0.isactive ) || !var_0.isactive )
        return 0;

    if ( !isdefined( var_1 ) && isdefined( var_0.entered_playspace ) && !var_0.entered_playspace )
        return 0;

    if ( istrue( var_0.marked_for_death ) )
        return 0;

    if ( !isdefined( var_0.team ) )
        return 0;

    if ( var_0.agent_type == "zombie_brute" || var_0.agent_type == "zombie_ghost" || var_0.agent_type == "zombie_grey" )
        return 0;

    if ( !istrue( var_2 ) && istrue( var_0.is_suicide_bomber ) )
        return 0;

    if ( istrue( var_0.is_coaster_zombie ) )
        return 0;

    return 1;
}

set_quest_icon( var_0 )
{
    increment_num_of_quest_piece_completed();
    set_quest_icon_internal( var_0 );
}

set_quest_icon_internal( var_0 )
{
    setomnvarbit( "zombie_quest_piece", var_0, 1 );
    setclientmatchdata( "questPieces", "quest_piece_" + var_0, 1 );
}

set_completed_quest_mark( var_0 )
{
    setomnvarbit( "zm_completed_quest_marks", var_0, 1 );
}

increment_num_of_quest_piece_completed()
{
    if ( !isdefined( level.num_of_quest_pieces_completed ) )
        level.num_of_quest_pieces_completed = 0;

    level.num_of_quest_pieces_completed++;

    if ( level.num_of_quest_pieces_completed == level.cp_zmb_number_of_quest_pieces )
    {
        foreach ( var_1 in level.players )
            var_1 scripts\cp\cp_achievement::update_achievement( "STICKER_COLLECTOR", 24 );
    }
}

playplayerandnpcsounds( var_0, var_1, var_2 )
{
    var_0 playlocalsound_safe( var_1 );
    var_0 playsoundtoteam( var_2, "allies", var_0 );
    var_0 playsoundtoteam( var_2, "axis", var_0 );
}

roundup( var_0 )
{
    if ( var_0 - int( var_0 ) >= 0.5 )
        return int( var_0 + 1 );
    else
        return int( var_0 );
}

damage_over_time( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8 )
{
    if ( !should_apply_dot( var_0 ) )
        return;

    var_0 endon( "death" );

    if ( !isdefined( var_3 ) )
        var_3 = 600;

    if ( !isdefined( var_2 ) )
        var_2 = 5;

    if ( !isdefined( var_4 ) )
        var_4 = "MOD_UNKNOWN";

    if ( !isdefined( var_5 ) )
        var_5 = "iw7_dot_zm";

    if ( isdefined( var_7 ) )
    {
        var_0 setscriptablestateflag( var_0, var_7, 1 );

        if ( isdefined( level.scriptablestatefunc ) )
            var_0 thread [[ level.scriptablestatefunc ]]( var_0 );
    }

    var_9 = 0;
    var_10 = 6;
    var_11 = var_2 / var_10;
    var_12 = var_3 / var_10;

    for ( var_13 = 0; var_13 < var_10; var_13++ )
    {
        wait( var_11 );

        if ( isalive( var_0 ) )
        {
            var_0.flame_damage_time = gettime() + 500;

            if ( var_0.health - var_12 <= 0 )
            {
                if ( isdefined( var_8 ) )
                    level notify( var_8 );
            }

            if ( isdefined( var_1 ) )
            {
                var_0 dodamage( var_12, var_0.origin, var_1, var_1, var_4, var_5 );
                continue;
            }

            var_0 dodamage( var_12, var_0.origin, undefined, undefined, var_4, var_5 );
        }
    }

    if ( isdefined( var_7 ) )
        var_0 setscriptablestateflag( var_0, var_7 );

    if ( istrue( var_0.marked_for_death ) )
        var_0.marked_for_death = undefined;

    if ( istrue( var_0.flame_damage_time ) )
        var_0.flame_damage_time = undefined;
}

setscriptablestateflag( var_0, var_1, var_2 )
{
    switch ( var_1 )
    {
        case "combinedArcane":
        case "combinedarcane":
            if ( istrue( var_2 ) )
                var_0.is_afflicted = 1;
            else
                var_0.is_afflicted = undefined;

            break;
        case "burning":
            if ( istrue( var_2 ) )
                var_0.is_burning = var_2;
            else
                var_0.is_burning = undefined;

            break;
        case "electrified":
            if ( istrue( var_2 ) )
            {
                var_0.is_electrified = var_2;
                var_0.allowpain = 1;
                var_0.stun_hit_time = gettime() + 3000;
            }
            else
            {
                var_0.is_electrified = undefined;
                var_0.allowpain = 0;
            }

            break;
        case "shocked":
            if ( istrue( var_2 ) )
                var_0.stunned = var_2;
            else
                var_0.stunned = undefined;

            break;
        case "chemBurn":
        case "chemburn":
            if ( istrue( var_2 ) )
                var_0.is_chem_burning = 1;
            else
                var_0.is_chem_burning = undefined;

            break;
        default:
            break;
    }
}

door_entitylessscriptable_togglelock( var_0, var_1, var_2 )
{
    var_3 = self;
    var_4 = undefined;

    if ( isdefined( var_1 ) )
    {
        var_5 = getentitylessscriptablearrayinradius( undefined, undefined, var_1, 64 );

        if ( var_5.size > 0 )
        {
            var_3 = undefined;

            if ( var_5.size == 1 )
            {
                var_3 = var_5[0];
                var_4 = 1;
            }
            else
            {
                var_6 = var_5.size;
                var_7 = 9999999;

                for ( var_8 = 0; var_8 < var_6; var_8++ )
                {
                    var_9 = distancesquared( var_5[var_8].origin, var_1 );

                    if ( var_9 < var_7 )
                    {
                        var_7 = var_9;
                        var_3 = var_5[var_8];
                        var_4 = 1;
                    }
                }
            }
        }
    }

    if ( isdefined( var_1 ) && !istrue( var_4 ) )
        return;

    if ( istrue( var_2 ) )
        var_3 setscriptablepartstate( "door", "closed" );

    if ( var_0 )
        var_3 scriptabledoorfreeze( 1 );
    else
        var_3 scriptabledoorfreeze( 0 );
}

should_apply_dot( var_0 )
{
    if ( isdefined( var_0.agent_type ) && ( var_0.agent_type == "c6" || var_0.agent_type == "zombie_brute" || var_0.agent_type == "zombie_grey" || var_0.agent_type == "zombie_ghost" ) )
        return 0;

    return 1;
}

update_trap_placement_internal( var_0, var_1, var_2, var_3, var_4 )
{
    self endon( "death" );
    self endon( "disconnect" );
    level endon( "game_ended" );
    var_5 = var_2.carriedtrapoffset;
    var_6 = var_2.carriedtrapangles;
    var_7 = var_2.placementradius;
    var_8 = var_2.placementheighttolerance;
    var_9 = var_2.modelplacement;
    var_10 = var_2.modelplacementfailed;
    var_11 = var_2.placecancelablestring;
    var_12 = var_2.placestring;
    var_13 = var_2.cannotplacestring;
    var_0 endon( "placed" );
    var_0 endon( "death" );
    var_0.canbeplaced = 1;
    var_14 = -1;

    for (;;)
    {
        var_15 = self canplayerplacesentry( 1, var_7 );
        var_0.origin = var_15["origin"];
        var_0.angles = var_15["angles"];
        var_1.origin = var_0.origin + var_5;
        var_1.angles = var_0.angles + var_6;

        if ( isdefined( self.onslide ) )
            var_0.canbeplaced = 0;
        else
            var_0.canbeplaced = self isonground() && var_15["result"] && abs( var_0.origin[2] - self.origin[2] ) < var_8;

        if ( ent_is_near_equipment( var_0 ) )
            var_0.canbeplaced = 0;

        if ( isdefined( var_3 ) && isdefined( level.discotrap_active ) && isdefined( level.dance_floor_volume ) )
        {
            if ( var_0 istouching( level.dance_floor_volume ) )
                var_0.canbeplaced = 0;
        }

        if ( isdefined( var_15["entity"] ) )
            var_0.moving_platform = var_15["entity"];
        else
            var_0.moving_platform = undefined;

        if ( var_0.canbeplaced != var_14 )
        {
            if ( var_0.canbeplaced )
            {
                if ( !isdefined( var_4 ) )
                    var_1 setmodel( var_9 );

                if ( isdefined( var_0.firstplacement ) )
                    self forceusehinton( var_11 );
                else
                    self forceusehinton( var_12 );
            }
            else
            {
                if ( !isdefined( var_4 ) )
                    var_1 setmodel( var_10 );

                self forceusehinton( var_13 );
            }
        }

        var_14 = var_0.canbeplaced;
        wait 0.05;
    }
}

usegrenadegesture( var_0, var_1 )
{
    if ( var_0 cangiveandfireoffhand( var_0 getvalidtakeweapon() ) && !var_0 isgestureplaying() )
    {
        var_0 setweaponammostock( var_1, 1 );
        var_0 giveandfireoffhand( var_1 );
    }
}

is_codxp()
{
    return getdvar( "scr_codxp", "" ) != "";
}

too_close_to_other_interactions( var_0 )
{
    var_1 = sortbydistance( level.current_interaction_structs, var_0 );

    if ( var_1.size >= 1 )
    {
        if ( distancesquared( var_1[0].origin, var_0 ) < 9216 )
            return 1;
    }

    return 0;
}

getweapontoswitchbackto()
{
    var_0 = undefined;

    if ( isdefined( self.last_weapon ) )
        var_0 = self.last_weapon;
    else
        var_0 = self getcurrentweapon();

    var_1 = 0;
    var_2 = level.additional_laststand_weapon_exclusion;

    if ( nullweapon( var_0 ) )
        var_1 = 1;
    else if ( scripts\engine\utility::array_contains( var_2, var_0 ) )
        var_1 = 1;
    else if ( scripts\engine\utility::array_contains( var_2, var_0 getbaseweapon() ) )
        var_1 = 1;
    else if ( is_melee_weapon( var_0, 1 ) )
        var_1 = 1;

    if ( var_1 )
    {
        var_3 = self getweaponslistall();

        for ( var_4 = 0; var_4 < var_3.size; var_4++ )
        {
            if ( nullweapon( var_3[var_4] ) )
                continue;
            else if ( scripts\engine\utility::array_contains( var_2, var_3[var_4] ) )
                continue;
            else if ( scripts\engine\utility::array_contains( var_2, var_3[var_4] getbaseweapon() ) )
                continue;
            else if ( is_melee_weapon( var_3[var_4], 1 ) )
                continue;
            else if ( !scripts\cp\cp_weapon::isprimaryweapon( var_3[var_4] ) )
                continue;
            else
            {
                var_1 = 0;
                var_0 = var_3[var_4];
                break;
            }
        }
    }

    if ( var_1 )
    {
        var_0 = getcompleteweaponname( "iw7_fists_zm" );

        if ( !self hasweapon( var_0 ) )
            _giveweapon( var_0, undefined, undefined, 1 );
    }

    return var_0;
}

getvalidtakeweapon( var_0 )
{
    var_1 = self getcurrentweapon();
    var_2 = 0;
    var_3 = level.additional_laststand_weapon_exclusion;

    if ( isdefined( var_0 ) )
        var_3 = scripts\engine\utility::array_combine( var_0, var_3 );

    if ( nullweapon( var_1 ) )
        var_2 = 1;
    else if ( isdefined( var_1.inventorytype ) && var_1.inventorytype == "model_only" )
        var_2 = 1;
    else if ( scripts\engine\utility::array_contains( var_3, var_1 ) )
        var_2 = 1;
    else if ( scripts\engine\utility::array_contains( var_3, var_1 getbaseweapon() ) )
        var_2 = 1;
    else if ( !preventleave() && is_melee_weapon( var_1, 1 ) )
        var_2 = 1;

    if ( isdefined( self.last_valid_weapon ) && self hasweapon( self.last_valid_weapon ) && var_2 )
    {
        var_1 = self.last_valid_weapon;

        if ( nullweapon( var_1 ) )
            var_2 = 1;
        else if ( isdefined( var_1.inventorytype ) && var_1.inventorytype == "model_only" )
            var_2 = 1;
        else if ( scripts\engine\utility::array_contains( var_3, var_1 ) )
            var_2 = 1;
        else if ( scripts\engine\utility::array_contains( var_3, var_1 getbaseweapon() ) )
            var_2 = 1;
        else if ( is_melee_weapon( var_1, 1 ) )
            var_2 = 1;
        else
            var_2 = 0;
    }

    if ( var_2 )
    {
        var_4 = self getweaponslistall();

        for ( var_5 = 0; var_5 < var_4.size; var_5++ )
        {
            if ( nullweapon( var_4[var_5] ) )
                continue;
            else if ( scripts\engine\utility::array_contains( var_3, var_4[var_5] ) )
                continue;
            else if ( scripts\engine\utility::array_contains( var_3, var_4[var_5] getbaseweapon() ) )
                continue;
            else if ( is_melee_weapon( var_4[var_5], 1 ) )
                continue;
            else if ( isdefined( var_4[var_5].inventorytype ) && var_4[var_5].inventorytype == "model_only" )
                continue;
            else
            {
                var_2 = 0;
                var_1 = var_4[var_5];
                break;
            }
        }
    }

    return var_1;
}

getcurrentcamoname( var_0 )
{
    var_1 = getweaponcamoname( var_0 );

    if ( !isdefined( var_1 ) )
        return undefined;

    switch ( var_1 )
    {
        case "camo0":
            return "camo00";
        case "camo1":
            return "camo01";
        case "camo2":
            return "camo02";
        case "camo3":
            return "camo03";
        case "camo4":
            return "camo04";
        case "camo5":
            return "camo05";
        case "camo6":
            return "camo06";
        case "camo7":
            return "camo07";
        case "camo8":
            return "camo08";
        case "camo9":
            return "camo09";
        default:
            return var_1;
    }

    return undefined;
}

add_to_notify_queue( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8 )
{
    if ( !isdefined( self.notify_queue ) )
        self.notify_queue = [];

    if ( !isdefined( self.notify_queue[var_0] ) )
        self.notify_queue[var_0] = 0;
    else
        self.notify_queue[var_0]++;

    if ( self.notify_queue[var_0] > 0 )
        wait( 0.05 * self.notify_queue[var_0] );

    if ( isdefined( self ) )
        self notify( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8 );

    waittillframeend;

    if ( isdefined( self ) )
    {
        if ( isdefined( self.notify_queue[var_0] ) )
        {
            self.notify_queue[var_0]--;

            if ( self.notify_queue[var_0] < 1 )
                self.notify_queue[var_0] = undefined;
        }
    }
}

take_fists_weapon( var_0 )
{
    foreach ( var_2 in var_0 getweaponslistall() )
    {
        if ( issubstr( var_2.basename, "iw7_fists" ) )
            var_0 takeweapon( var_2 );
    }
}

playlocalsound_safe( var_0 )
{
    if ( soundexists( var_0 ) )
        self playlocalsound( var_0 );
}

stoplocalsound_safe( var_0 )
{
    if ( soundexists( var_0 ) )
        self stoplocalsound( var_0 );
}

playsoundatpos_safe( var_0, var_1 )
{
    if ( soundexists( var_1 ) )
        playsoundatpos( var_0, var_1 );
}

playsoundtoplayer_safe( var_0, var_1 )
{
    if ( soundexists( var_0 ) )
        var_1 playsoundtoplayer( var_0, var_1 );
}

agentcantbeignored()
{
    return isdefined( self.agent_type ) && isdefined( level.ignoreimmune ) && scripts\engine\utility::array_contains( level.ignoreimmune, self.agent_type );
}

agentisfnfimmune()
{
    return isdefined( self.agent_type ) && isdefined( level.fnfimmune ) && scripts\engine\utility::array_contains( level.fnfimmune, self.agent_type );
}

agentisinstakillimmune()
{
    return isdefined( self.agent_type ) && isdefined( level.instakillimmune ) && scripts\engine\utility::array_contains( level.instakillimmune, self.agent_type );
}

agentisspecialzombie()
{
    return isdefined( self.agent_type ) && isdefined( level.specialzombie ) && scripts\engine\utility::array_contains( level.specialzombie, self.agent_type );
}

firegesturegrenade( var_0, var_1 )
{
    var_2 = var_0 getcurrentweapon();

    if ( cangiveandfireoffhand( var_2 ) )
    {
        var_0 setweaponammostock( var_1, 1 );
        var_0 giveandfireoffhand( var_1 );
    }
}

cangiveandfireoffhand( var_0 )
{
    if ( !isdefined( var_0 ) )
        return 1;

    if ( isdefined( level.invalid_gesture_weapon ) )
    {
        if ( isdefined( level.invalid_gesture_weapon[getweaponbasename( var_0 )] ) )
            return 0;
        else
            return 1;
    }
    else
        return 1;
}

play_interaction_gesture( var_0 )
{
    if ( !isdefined( var_0 ) )
        var_0 = "iw7_powerlever_zm";

    if ( getweaponbasename( self getcurrentweapon() ) != "iw7_penetrationrail_mp" )
        thread firegesturegrenade( self, var_0 );
}

playerplaypickupanim( var_0 )
{
    self notify( "playerPlayPickupAnim" );
    self endon( "playerPlayPickupAnim" );
    self endon( "death" );
    self endon( "disconnect" );

    if ( self isswitchingweapon() || self isreloading() || self ismantling() || self isthrowinggrenade() || self israisingweapon() || self ismeleeing() || isplayerads() )
        return;

    if ( !isdefined( var_0 ) )
        var_0 = "iw8_ges_pickup";

    var_1 = getcompleteweaponname( "none" );
    var_2 = self getcurrentprimaryweapon();

    if ( isnullweapon( var_2, var_1 ) )
        return;

    if ( self isgestureplaying( var_0 ) )
    {
        self stopgestureviewmodel( var_0, 0, 1 );
        wait 0.05;
    }

    self forceplaygestureviewmodel( var_0 );
}

playerplaytakephotoanim()
{
    var_0 = "intel_take_photo";
    var_1 = self getcurrentweapon();
    var_2 = getcompleteweaponname( var_0 );
    thread _freeze_until_phototaken();
    _giveweapon( var_2 );
    self switchtoweapon( var_2 );
    self setclientomnvar( "ui_tablet_usb", 7 );
    var_3 = 3;
    wait( var_3 );

    if ( isplayer( self ) )
    {
        self takeweapon( var_2 );
        self switchtoweapon( var_1 );
        self setclientomnvar( "ui_tablet_usb", 0 );
        return 1;
    }

    return 0;
}

_freeze_until_phototaken()
{
    var_0 = self getstance();
    _togglecellphoneallows( 1 );
    restrict_player_stance_to_this( 1, var_0 );
    var_1 = 1.6;
    wait( var_1 );
    _togglecellphoneallows( 0 );
    restrict_player_stance_to_this( 0, var_0 );
}

_togglecellphoneallows( var_0 )
{
    _freezelookcontrols( var_0 );
    scripts\common\utility::allow_movement( !var_0 );
    scripts\common\utility::allow_jump( !var_0 );
    scripts\common\utility::allow_usability( !var_0 );
    scripts\common\utility::allow_melee( !var_0 );
    scripts\common\utility::allow_offhand_weapons( !var_0 );
    scripts\common\utility::allow_weapon_switch( !var_0 );
    scripts\common\utility::allow_sprint( !var_0 );
}

restrict_player_stance_to_this( var_0, var_1 )
{
    if ( istrue( var_0 ) )
        _player_allowed_stances( 1, var_1 );
    else
        _player_allowed_stances( 0, var_1 );
}

_player_allowed_stances( var_0, var_1 )
{
    if ( istrue( var_0 ) )
    {
        switch ( var_1 )
        {
            case "stand":
                scripts\common\utility::allow_crouch( 0 );
                scripts\common\utility::allow_prone( 0 );
                break;
            case "crouch":
                scripts\common\utility::allow_stand( 0 );
                scripts\common\utility::allow_prone( 0 );
                break;
            case "prone":
                scripts\common\utility::allow_crouch( 0 );
                scripts\common\utility::allow_stand( 0 );
                break;
        }
    }
    else
    {
        switch ( var_1 )
        {
            case "stand":
                scripts\common\utility::allow_crouch( 1 );
                scripts\common\utility::allow_prone( 1 );
                break;
            case "crouch":
                scripts\common\utility::allow_stand( 1 );
                scripts\common\utility::allow_prone( 1 );
                break;
            case "prone":
                scripts\common\utility::allow_crouch( 1 );
                scripts\common\utility::allow_stand( 1 );
                break;
        }
    }
}

deactivatebrushmodel( var_0, var_1 )
{
    var_0 notsolid();

    if ( istrue( var_1 ) )
        var_0 hide();
}

rankingenabled()
{
    if ( !isplayer( self ) )
        return 0;

    return level.onlinegame && !self.usingonlinedataoffline;
}

debugprintline( var_0 )
{

}

ent_createheadicon( var_0, var_1, var_2, var_3, var_4 )
{
    if ( !level.teambased )
        return undefined;

    if ( !isdefined( var_2 ) )
        var_2 = "allies";

    var_5 = deleteheadicon( var_0 );
    setheadiconenemyimage( var_5, var_3 );
    addclienttoheadiconmask( var_5, var_1 );
    setheadiconmaxdistance( var_5, 0 );
    setheadiconsnaptoedges( var_5, 2250 );
    setheadiconowner( var_5, var_2 );

    if ( isdefined( var_4 ) )
        setheadiconzoffset( var_5, var_4 );

    removeclientfromheadiconmask( var_5, var_2 );
    hideheadiconfromplayersinmask( var_5 );
    thread watchheadicon( var_0, var_5 );
    return var_5;
}

watchheadicon( var_0, var_1 )
{
    var_0 endon( "head_icon_deleted_" + var_1 );
    var_0 waittill( "death" );
    thread ent_deleteheadicon( var_0, var_1 );
}

ent_deleteheadicon( var_0, var_1 )
{
    var_0 notify( "head_icon_deleted_" + var_1 );

    if ( isdefined( var_1 ) && var_1 != -1 )
        setheadiconimage( var_1 );
}

getlastweapon()
{
    return self.lastweaponobj;
}

isnmlactive()
{
    return istrue( level.nml_proto );
}

addtostructarray( var_0, var_1, var_2 )
{
    if ( !isdefined( level.struct_class_names[var_0][var_1] ) )
        level.struct_class_names[var_0][var_1] = [];

    level.struct_class_names[var_0][var_1][level.struct_class_names[var_0][var_1].size] = var_2;
}

is_in_active_volume( var_0 )
{
    if ( !isdefined( level.active_spawn_volumes ) )
        return 1;

    var_1 = sortbydistance( level.active_spawn_volumes, var_0 );

    foreach ( var_3 in var_1 )
    {
        if ( ispointinvolume( var_0, var_3 ) )
            return 1;
    }

    return 0;
}

give_max_ammo_to_player( var_0 )
{
    var_1 = var_0 getweaponslistprimaries();

    foreach ( var_3 in var_1 )
    {
        var_0 givemaxammo( var_3 );

        if ( weaponmaxammo( var_3 ) == weaponclipsize( var_3 ) )
            var_0 setweaponammoclip( var_3, weaponclipsize( var_3 ) );
    }

    var_5 = getarraykeys( var_0.powers );

    foreach ( var_7 in var_5 )
    {
        if ( var_0.powers[var_7].slot == "secondary" )
            continue;

        var_0 thread recharge_power( var_7 );
    }
}

recharge_power( var_0 )
{
    var_1 = self.powers[var_0].slot;

    if ( istrue( self.powers[var_0].active ) )
    {
        while ( istrue( self.powers[var_0].active ) )
            wait 0.05;
    }

    if ( istrue( self.powers[var_0].updating ) )
    {
        while ( istrue( self.powers[var_0].updating ) )
            wait 0.05;
    }

    thread scripts\cp\cp_powers::givepower( var_0, var_1, undefined, undefined, undefined, undefined, 1 );

    if ( istrue( level.secondary_power ) )
    {
        if ( isdefined( level.power_modifycooldownrate ) )
            self [[ level.power_modifycooldownrate ]]( 10, "secondary" );
    }

    if ( istrue( level.infinite_grenades ) )
    {
        if ( isdefined( level.power_modifycooldownrate ) )
            self [[ level.power_modifycooldownrate ]]( 100 );
    }
}

objective_update( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7 )
{
    scripts\cp\cp_objectives::objective_update_internal( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7 );
}

obj( var_0 )
{
    if ( !isdefined( level.objectives ) )
        level.objectives = [];

    if ( !isdefined( level.objectives[var_0] ) )
        level.objectives[var_0] = level.objectives.size + 1;

    return level.objectives[var_0];
}

objective_complete( var_0 )
{
    scripts\cp\cp_objectives::delete_objective( var_0 );
    var_1 = scripts\cp\cp_objectives::get_objective_type( var_0 );

    if ( isdefined( var_1 ) )
    {
        if ( var_1 == "global" )
            return;
    }

    scripts\cp\cp_objectives::reset_objective_omnvars( var_0 );
}

hint_prompt( var_0, var_1, var_2 )
{
    if ( istrue( var_1 ) )
        var_3 = int( tablelookup( "cp/cp_hints.csv", 1, var_0, 0 ) );
    else
        var_3 = 0;

    self setclientomnvar( "zm_hint_index", var_3 );

    if ( isdefined( var_2 ) )
    {
        wait( var_2 );
        self setclientomnvar( "zm_hint_index", 0 );
    }
}

lastgunkilltime( var_0 )
{
    var_1 = tablelookup( "cp/carry_items.csv", 1, var_0, 0 );

    if ( isdefined( var_1 ) )
        return var_1;
    else
        return 0;
}

_id_11DD8( var_0, var_1 )
{
    var_2 = lastgunkilltime( var_1 );
    var_3 = 1;

    if ( !isdefined( var_0.determinewinnertype ) || var_0.determinewinnertype == 0 )
        var_0.determinewinnertype = int( var_2 );
    else
    {
        var_0.determinetrackingcircleoffset = int( var_2 );
        var_3 = 2;
    }

    var_4 = spawnstruct();
    var_4.detachriotshield = var_1;
    var_4.slot = var_3;
    scripts\cp\cp_globallogic::collorigin2( var_0 );
    return var_4;
}

_id_119E5( var_0, var_1 )
{
    if ( !isdefined( var_1 ) )
        var_1 = 1;

    if ( var_1 == 1 )
        var_0.determinewinnertype = 0;
    else if ( var_1 == 2 )
        var_0.determinetrackingcircleoffset = 0;

    scripts\cp\cp_globallogic::collorigin2( var_0 );
}

addentrytodevgui( var_0 )
{
    level thread addentrytodevgui_internal( var_0 );
}

addentrytodevgui_internal( var_0 )
{
    if ( !isdefined( var_0 ) )
        return;

    level endon( "game_ended" );

    if ( scripts\engine\utility::flag_exist( "ready_for_devgui" ) )
        scripts\engine\utility::flag_wait( "ready_for_devgui" );

    if ( scripts\engine\utility::flag_exist( "strike_init_done" ) )
        scripts\engine\utility::flag_wait( "strike_init_done" );

    if ( scripts\engine\utility::flag_exist( "introscreen_over" ) )
        scripts\engine\utility::flag_wait( "introscreen_over" );

    wait 2;
    var_1 = "";
    var_2 = strtok( var_0, "/" );
    var_3 = " ";
    var_4 = 0;

    foreach ( var_6 in var_2 )
    {
        var_7 = strtok( var_6, " " );
        var_8 = 1;
        var_9 = var_7.size;

        foreach ( var_11 in var_7 )
        {
            if ( var_8 < var_9 )
                var_1 = var_1 + var_11 + var_3;
            else
                var_1 = var_1 + var_11;

            var_8++;
        }

        var_4++;

        if ( var_4 < var_2.size )
            var_1 = var_1 + "/";
    }
}

array_sort_by_handler( var_0, var_1, var_2 )
{
    if ( !isdefined( var_1 ) )
        var_1 = ::defaultsortfunc;

    var_2 = istrue( var_2 );

    for ( var_3 = 0; var_3 < var_0.size - 1; var_3++ )
    {
        for ( var_4 = var_3 + 1; var_4 < var_0.size; var_4++ )
        {
            if ( var_2 )
            {
                if ( var_0[var_4] [[ var_1 ]]() > var_0[var_3] [[ var_1 ]]() )
                {
                    var_5 = var_0[var_4];
                    var_0[var_4] = var_0[var_3];
                    var_0[var_3] = var_5;
                }

                continue;
            }

            if ( var_0[var_4] [[ var_1 ]]() < var_0[var_3] [[ var_1 ]]() )
            {
                var_5 = var_0[var_4];
                var_0[var_4] = var_0[var_3];
                var_0[var_3] = var_5;
            }
        }
    }

    return var_0;
}

array_compare( var_0, var_1 )
{
    if ( var_0.size != var_1.size )
        return 0;

    foreach ( var_5, var_3 in var_0 )
    {
        if ( !isdefined( var_1[var_5] ) )
            return 0;

        var_4 = var_1[var_5];

        if ( var_4 != var_3 )
            return 0;
    }

    return 1;
}

defaultsortfunc( var_0, var_1 )
{
    return randomint( 100 );
}

set_segmented_health_regen_parameters( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    var_6 = spawnstruct();
    var_6.max_health_cap = var_0 / 100;
    var_6.min_health_cap = var_1 / 100;
    var_6.segment_size = var_2 / 100;
    var_6.pre_regen_wait = var_3;
    var_6.per_regen_amount = var_4 / 100;
    var_6.between_regen_wait = var_5;
    level.segmented_health_regen_parameters = var_6;
}

segmented_health_regen( var_0 )
{
    level endon( "game_ended" );
    var_0 endon( "disconnect" );
    var_0 notify( "one_instance_of_segmented_health" );
    var_0 endon( "one_instance_of_segmented_health" );
    var_0 waittill( "spawned_player" );
    var_1 = level.segmented_health_regen_parameters;
    var_0.max_health_cap = int( var_0.maxhealth * var_1.max_health_cap );
    var_0.min_health_cap = int( var_0.maxhealth * var_1.min_health_cap );
    var_0.segment_size = int( var_0.maxhealth * var_1.segment_size );
    var_0.pre_regen_wait = var_1.pre_regen_wait;
    var_0.per_regen_amount = int( var_0.maxhealth * var_1.per_regen_amount );
    var_0.between_regen_wait = var_1.between_regen_wait;
    set_current_health_regen_segment( var_0, var_0.max_health_cap );

    for (;;)
    {
        var_0 scripts\engine\utility::_id_12E47( "damage", "revive" );
        update_current_health_regen_segment( var_0 );

        if ( !can_do_segmented_health_regen( var_0 ) )
            continue;

        var_0 thread segmented_health_regen_internal( var_0 );
    }
}

segmented_health_regen_internal( var_0 )
{
    var_0 notify( "segmented_health_regen_internal" );
    level endon( "game_ended" );
    var_0 endon( "segmented_health_regen_internal" );
    var_0 endon( "disconnect" );
    var_0 endon( "damage" );
    var_0 endon( "last_stand" );
    wait( var_0.pre_regen_wait );

    for (;;)
    {
        var_0.health = int( min( int( min( var_0.health + var_0.per_regen_amount, var_0.current_health_regen_segment_ceiling ) ), var_0.maxhealth ) );

        if ( var_0.health == var_0.current_health_regen_segment_ceiling )
            return;

        wait( var_0.between_regen_wait );
    }
}

set_current_health_regen_segment( var_0, var_1 )
{
    var_0.current_health_regen_segment_ceiling = int( var_1 );
    var_0.current_health_regen_segment_floor = int( var_1 - var_0.segment_size );
}

update_current_health_regen_segment( var_0 )
{
    if ( var_0.current_health_regen_segment_ceiling == var_0.min_health_cap )
        return;

    if ( var_0.health < var_0.current_health_regen_segment_floor )
        set_current_health_regen_segment( var_0, find_new_health_regen_segment_ceiling( var_0 ) );
}

find_new_health_regen_segment_ceiling( var_0 )
{
    var_1 = int( ( var_0.max_health_cap - var_0.min_health_cap ) / var_0.segment_size );

    for ( var_2 = 0; var_2 <= var_1 + 1; var_2++ )
    {
        var_3 = var_0.min_health_cap + var_2 * var_0.segment_size;

        if ( var_3 >= var_0.health )
            return int( min( var_3, var_0.maxhealth ) );
    }
}

can_do_segmented_health_regen( var_0 )
{
    if ( is_segmented_health_regen_disabled( var_0 ) )
        return 0;

    if ( scripts\cp\cp_laststand::player_in_laststand( var_0 ) )
        return 0;

    return 1;
}

is_segmented_health_regen_disabled( var_0 )
{
    return istrue( var_0.segmented_health_regen_disabled );
}

disable_segmented_health_regen( var_0 )
{
    var_0.segmented_health_regen_disabled = 1;
}

enable_segmented_health_regen( var_0 )
{
    var_0.segmented_health_regen_disabled = 0;
}

is_friendly_damage( var_0, var_1 )
{
    if ( isdefined( var_1 ) )
    {
        if ( isdefined( var_1.team ) && var_1.team == var_0.team )
            return 1;

        if ( isdefined( var_1.owner ) && isdefined( var_1.owner.team ) && var_1.owner.team == var_0.team )
            return 1;
    }

    return 0;
}

draw_debug_rectangle( var_0, var_1 )
{
    var_2 = var_0[0];
    var_3 = var_1[0];
    var_4 = var_0[1];
    var_5 = var_1[1];
    var_6 = max( var_0[2], var_1[2] );
    var_7 = ( var_2, var_5, var_6 );
    var_8 = ( var_3, var_4, var_6 );
}

vehicle_createhealthbar( var_0 )
{
    var_1 = spawn( "script_model", var_0.origin );
    var_2 = var_0 gettagorigin( "tag_origin", 1 );

    if ( isdefined( var_2 ) )
        var_1 linkto( var_0, "tag_origin", ( 0, 0, 190 ), ( 0, 0, 0 ) );
    else
        var_1 linkto( var_0 );

    var_3 = vehicle_gethealthbarid();

    if ( !isdefined( var_3 ) )
        return;

    var_0.healthbarid = var_3;
    var_4 = 1;

    if ( !isdefined( level.healthbars ) )
        level.healthbars = [];

    level.healthbars[var_0.healthbarid] = var_1;
    setomnvar( "ui_ingame_light_tank_ent_" + var_0.healthbarid, var_1 );
    setomnvar( "ui_ingame_light_tank_team_" + var_0.healthbarid, var_4 );
    setomnvar( "ui_ingame_light_tank_health_" + var_0.healthbarid, 1 );
}

vehicle_gethealthbarid()
{
    if ( !isdefined( level.healthbars ) )
        level.healthbars = [];

    var_0 = undefined;

    for ( var_1 = 0; var_1 < 7; var_1++ )
    {
        if ( !isdefined( level.healthbars[var_1] ) )
        {
            var_0 = var_1;
            break;
        }
    }

    return var_0;
}

vehicle_freehealthbarui()
{
    if ( isdefined( self.healthbarid ) )
    {
        var_0 = level.healthbars[self.healthbarid];
        var_0 delete();
        setomnvar( "ui_ingame_light_tank_ent_" + self.healthbarid, undefined );
        setomnvar( "ui_ingame_light_tank_health_" + self.healthbarid, 0 );
        setomnvar( "ui_ingame_light_tank_team_" + self.healthbarid, 0 );
        level.healthbars[self.healthbarid] = undefined;
        self.healthbarid = undefined;
    }
}

vehile_updatehealthbar( var_0 )
{
    if ( isdefined( self.healthbarid ) )
        setomnvar( "ui_ingame_light_tank_health_" + self.healthbarid, var_0 );
}

create_waypoint( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    if ( !isdefined( var_5 ) )
        var_5 = 1.0;

    var_6 = undefined;

    if ( var_2 != "all" )
        var_6 = newteamhudelem( var_2 );
    else
        var_6 = newhudelem();

    var_6.id = var_0;
    var_6.x = var_1[0];
    var_6.y = var_1[1];
    var_6.z = var_1[2];
    var_6.team = var_2;
    var_6.isflashing = 0;
    var_6.isshown = 1;

    if ( issplitscreen() )
        var_6 setshader( var_3, 8, 8 );
    else
        var_6 setshader( var_3, 15, 15 );

    var_6 setwaypoint( 0, 1, 1 );

    if ( isdefined( var_4 ) )
        var_6.alpha = var_4;
    else
        var_6.alpha = 0.75;

    var_6.basealpha = var_6.alpha;
    return var_6;
}

waypoint_delete( var_0 )
{
    var_0 destroy();
}

_freezecontrols( var_0, var_1, var_2 )
{
    if ( !isdefined( self.pers ) )
        return;

    if ( !isdefined( self.pers["controllerFreezeStack"] ) )
        self.pers["controllerFreezeStack"] = 0;

    if ( var_0 )
        self.pers["controllerFreezeStack"]++;
    else if ( istrue( var_1 ) )
        self.pers["controllerFreezeStack"] = 0;
    else
        self.pers["controllerFreezeStack"]--;

    if ( self.pers["controllerFreezeStack"] <= 0 )
    {
        self.pers["controllerFreezeStack"] = 0;
        self freezecontrols( 0 );
        self.controlsfrozen = 0;
    }
    else
    {
        self freezecontrols( 1 );
        self.controlsfrozen = 1;
    }
}

_freezelookcontrols( var_0, var_1 )
{
    if ( !isdefined( self.pers ) )
        return;

    if ( !isdefined( self.pers["controllerLookFreezeStack"] ) )
        self.pers["controllerLookFreezeStack"] = 0;

    if ( var_0 )
        self.pers["controllerLookFreezeStack"]++;
    else if ( istrue( var_1 ) )
        self.pers["controllerLookFreezeStack"] = 0;
    else
        self.pers["controllerLookFreezeStack"]--;

    if ( self.pers["controllerLookFreezeStack"] <= 0 )
    {
        self.pers["controllerLookFreezeStack"] = 0;
        self freezelookcontrols( 0 );
        self.lookcontrolsfrozen = 0;
    }
    else
    {
        self freezelookcontrols( 1 );
        self.lookcontrolsfrozen = 1;
    }
}

_setdof_internal( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    if ( !isdefined( self ) )
        return;

    var_0 = max( var_0, 0.0 );
    var_1 = clamp( var_1, 1.0, 9994.0 );
    var_2 = clamp( var_2, 2.0, 9998.0 );
    var_3 = clamp( var_3, 3.0, 9999 );

    if ( var_2 > 9994.0 )
        var_5 = 0.0;

    self setdepthoffield( var_0, var_1, var_2, var_3, var_4, var_5 );
}

setdof_dynamic()
{
    self endon( "disconnect" );
    self endon( "death" );
    setdof_default();

    if ( isai( self ) )
        return;

    var_0 = [ "physicscontents_clipshot", "physicscontents_missileclip", "physicscontents_solid", "physicscontents_vehicle", "physicscontents_player", "physicscontents_actor", "physicscontents_glass", "physicscontents_itemclip" ];
    var_1 = physics_createcontents( var_0 );
    var_2 = [ "physicscontents_player" ];
    var_3 = physics_createcontents( var_2 );
    var_4 = 1;
    var_5 = 1;
    var_6 = cos( 27 );
    var_7 = 1;
    var_8 = 0;
    var_9 = [];
    var_9["geo"] = spawnstruct();
    var_9["geo"].nearstartfactor = getdvarfloat( "dof_nearStart_geo", 0.01 );
    var_9["geo"].nearendfactor = getdvarfloat( "dof_nearEnd_geo", 0.95 );
    var_9["geo"].farstartfactor = getdvarfloat( "dof_farStart_geo", 1.5 );
    var_9["geo"].farendfactor = getdvarfloat( "dof_farEnd_geo", 2.5 );
    var_9["geo"].nearblur = getdvarfloat( "dof_nearBlur_geo", 3.9 );
    var_9["geo"].farblur = getdvarfloat( "dof_farBlur_geo", 2.25 );
    var_9["interest"] = spawnstruct();
    var_9["interest"].nearstartfactor = getdvarfloat( "dof_nearStart", 0.01 );
    var_9["interest"].nearendfactor = getdvarfloat( "dof_nearEnd", 0.95 );
    var_9["interest"].farstartfactor = getdvarfloat( "dof_farStart", 1.5 );
    var_9["interest"].farendfactor = getdvarfloat( "dof_farEnd", 2.5 );
    var_9["interest"].nearblur = getdvarfloat( "dof_nearBlur", 7.0 );
    var_9["interest"].farblur = getdvarfloat( "dof_farBlur", 3.5 );

    for (;;)
    {
        waitframe();
        var_10 = "geo";

        if ( istrue( self.usingcustomdof ) )
            continue;

        var_11 = self playerads() > 0.9;

        if ( var_7 && !var_11 )
        {
            if ( var_8 )
            {
                var_8 = 0;
                _setdof_internal( 0, 0, 512, 512, 4, 0 );
            }

            continue;
        }

        var_12 = self geteye();
        var_13 = self getplayerangles();
        var_14 = anglestoforward( var_13 );
        var_15 = -1;
        var_16 = undefined;
        var_17 = undefined;
        var_18 = undefined;
        var_19 = undefined;

        if ( var_4 )
        {
            var_20 = 0;

            foreach ( var_22 in level.players )
            {
                if ( !scripts\cp_mp\utility\player_utility::playersareenemies( self, var_22 ) )
                    continue;

                if ( !var_22 scripts\cp_mp\utility\player_utility::_isalive() )
                    continue;

                var_23 = var_22 geteye();
                var_24 = vectordot( var_14, vectornormalize( var_23 - var_12 ) );

                if ( var_24 < var_6 )
                    continue;

                var_25 = distance( var_12, var_23 );

                if ( !isdefined( var_16 ) || var_25 < var_16 )
                {
                    if ( var_22 sightconetrace( var_12, self ) > 0 )
                        var_16 = var_25;
                }

                if ( !isdefined( var_17 ) || var_25 > var_17 )
                {
                    if ( var_22 sightconetrace( var_12, self ) > 0 )
                        var_17 = var_25;
                }
            }
        }

        var_27 = var_12 + var_14 * 10000;
        var_28 = scripts\engine\trace::sphere_trace( var_12, var_27, 0.1, self, var_1, 0 );
        var_19 = distance( var_12, var_28["position"] );
        var_29 = scripts\engine\trace::sphere_trace( var_12, var_27, 20.0, self, var_3, 0 );
        var_30 = var_29["entity"];
        var_31 = isdefined( var_30 ) && isplayer( var_30 ) && scripts\cp_mp\utility\player_utility::playersareenemies( self, var_30 );
        var_32 = var_31 && var_30 sightconetrace( var_12, self ) > 0;

        if ( !isdefined( var_16 ) || var_19 < var_16 )
            var_16 = var_19;

        if ( !isdefined( var_17 ) || var_19 > var_17 )
            var_17 = var_19;

        var_8 = 1;
        var_33 = max( abs( var_16 - var_17 ) * 0.5, 300.0 );
        var_34 = 0.0;
        var_35 = max( var_16 - 50.0, 1.0 );
        var_36 = var_17 + 50.0;
        var_37 = var_36 + var_33;
        var_38 = scripts\engine\utility::ter_op( var_32, 6.0, 4.0 );
        var_39 = scripts\engine\utility::ter_op( var_32, 2.5, 1.25 );
        _setdof_internal( var_34, var_35, var_36, var_37, var_38, var_39 );
    }
}

setdof_killer()
{
    self endon( "disconnect" );
    self.usingcustomdof = 1;
    setdof_killer_update();
    setdof_default();
}

setdof_killer_update()
{
    self endon( "disconnect" );
    self endon( "death_delay_finished" );
    var_0 = [ "physicscontents_clipshot", "physicscontents_missileclip", "physicscontents_solid", "physicscontents_vehicle", "physicscontents_player", "physicscontents_actor", "physicscontents_glass", "physicscontents_itemclip" ];
    var_1 = physics_createcontents( var_0 );
    var_2 = vectornormalize( self.origin - self.lastkilledby.origin );
    var_3 = self.origin + ( 0, 0, 42 );
    var_4 = var_3 + var_2 * 120.0;
    var_5 = scripts\engine\trace::sphere_trace( var_3, var_4, 2.0, self, var_1, 0 );
    var_6 = var_5["position"];

    while ( istrue( self.usingcustomdof ) )
    {
        if ( !isdefined( self.lastkilledby ) )
            break;

        var_7 = distance( var_6, self.lastkilledby.origin );
        var_8 = 0.0;
        var_9 = max( var_7 - 12.0, 1.0 );
        var_10 = var_7 + 12.0;
        var_11 = var_10 + 50.0;
        var_12 = 8.0;
        var_13 = 4.5;
        _setdof_internal( var_8, var_9, var_10, var_11, var_12, var_13 );
        waitframe();
    }
}

setdof_default()
{
    self.usingcustomdof = 0;
    _setdof_internal( 0, 0, 512, 512, 4, 0 );
}

setdof_spectator()
{
    self.usingcustomdof = 1;
    _setdof_internal( 0, 128, 512, 4000, 6, 1.8 );
}

setdof_infil()
{
    self.usingcustomdof = 1;
    _setdof_internal( 0, 128, 512, 4000, 6, 1.8 );
}

setdof_apache()
{
    self.usingcustomdof = 1;
    _setdof_internal( 10, 80, 1000, 6500, 7, 3.5 );
}

setdof_cruisethird()
{
    self.usingcustomdof = 1;
    _setdof_internal( 10, 80, 1000, 6500, 7, 3.5 );
}

setdof_cruisefirst()
{
    self.usingcustomdof = 1;
    _setdof_internal( 10, 80, 1000, 1000, 7, 0 );
}

setdof_tank()
{
    self.usingcustomdof = 1;
    _setdof_internal( 10, 120, 1000, 6500, 7, 3.5 );
}

setdof_thirdperson()
{
    self.usingcustomdof = 1;
    _setdof_internal( 0, 110, 512, 4096, 6, 1.8 );
}

draw_line_until_endons( var_0, var_1, var_2, var_3, var_4, var_5 )
{
    self endon( "death" );

    if ( isdefined( var_4 ) )
    {
        if ( isarray( var_4 ) )
        {
            foreach ( var_7 in var_4 )
                self endon( var_7 );
        }
        else
            self endon( var_4 );
    }

    if ( !isdefined( var_5 ) )
        var_5 = var_0 + ( 0, 0, 256 );

    for (;;)
        waitframe();
}

play_sound_on_tag( var_0, var_1 )
{
    if ( isdefined( var_1 ) )
        playsoundatpos( self gettagorigin( var_1 ), var_0 );
    else
        playsoundatpos( self.origin, var_0 );
}

get_point_in_local_ent_space( var_0, var_1 )
{
    var_2 = var_0.origin;
    var_3 = anglestoup( var_0.angles );
    var_4 = anglestoleft( var_0.angles );
    var_5 = anglestoforward( var_0.angles );
    var_6 = var_1[0] * var_5[0] + var_1[1] * var_4[0] + var_1[2] * var_3[0] + var_2[0];
    var_7 = var_1[0] * var_5[1] + var_1[1] * var_4[1] + var_1[2] * var_3[1] + var_2[1];
    var_8 = var_1[0] * var_5[2] + var_1[1] * var_4[2] + var_1[2] * var_3[2] + var_2[2];
    var_9 = ( var_6, var_7, var_8 );
    return var_9;
}

_scriptnoteworthycheck( var_0, var_1 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    if ( !isdefined( var_1 ) )
        return 0;

    if ( !isdefined( var_0.script_noteworthy ) )
        return 0;

    if ( var_0.script_noteworthy != var_1 )
        return 0;

    return 1;
}

show_self_pressed_buttons()
{
    for (;;)
    {
        var_0 = "";

        if ( self buttonpressed( "BUTTON_Y" ) )
            var_0 = var_0 + ",y";

        if ( self buttonpressed( "BUTTON_BACK" ) )
            var_0 = var_0 + ",guide";

        if ( self stancebuttonpressed() )
            var_0 = var_0 + ",stance";

        if ( self usebuttonpressed() )
            var_0 = var_0 + ",use";

        if ( self fragbuttonpressed() )
            var_0 = var_0 + ",frag";

        if ( self meleebuttonpressed() )
            var_0 = var_0 + ",melee";

        if ( self jumpbuttonpressed() )
            var_0 = var_0 + ",jump";

        if ( self attackbuttonpressed() )
            var_0 = var_0 + ",attack";

        if ( self secondaryoffhandbuttonpressed() )
            var_0 = var_0 + ",secondary";

        if ( self adsbuttonpressed() )
            var_0 = var_0 + ",ADS";

        self iprintln( var_0 );
        wait 0.05;
    }
}

remove_cursor_hint()
{
    var_0 = self;

    if ( isdefined( self.cursor_hint_ent ) )
    {
        var_0 = self.cursor_hint_ent;
        var_0 scripts\engine\utility::delaycall( 0.5, ::delete );
    }

    if ( isdefined( var_0 ) && !isstruct( var_0 ) )
        var_0 makeunusable();

    if ( isdefined( self ) )
        notify_delay( "hint_destroyed", 0.05 );
}

notify_delay( var_0, var_1 )
{
    self endon( "death" );

    if ( var_1 > 0 )
        wait( var_1 );

    if ( !isdefined( self ) )
        return;

    self notify( var_0 );
}

create_cursor_hint( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9, var_10, var_11, var_12, var_13 )
{
    var_14 = self;

    if ( isstruct( var_14 ) || var_14.classname == "script_origin" || isdefined( var_1 ) )
    {
        var_14 = spawn( "script_origin", self.origin );
        self.cursor_hint_ent = var_14;
        thread hint_ent_notify_trigger();
    }

    if ( isdefined( var_1 ) )
    {
        var_15 = "tag_origin";

        if ( isdefined( var_0 ) )
        {
            var_15 = var_0;
            var_14.origin = self gettagorigin( var_15 );
        }

        if ( isdefined( self.model ) && self.classname == "script_model" && scripts\engine\utility::hastag( self.model, var_15 ) )
            var_14 linkto( self, var_15, var_1, ( 0, 0, 0 ) );
        else if ( isdefined( var_0 ) )
            var_14 linkto( self, var_15, var_1, ( 0, 0, 0 ) );
        else if ( isdefined( self.angles ) )
        {
            var_14.origin = var_14.origin + rotatevector( var_1, self.angles );

            if ( isent( self ) )
                var_14 linkto( self );
        }
        else
        {
            var_14.origin = var_14.origin + var_1;

            if ( isent( self ) )
                var_14 linkto( self );
        }
    }
    else if ( isdefined( var_0 ) )
        var_14 sethinttag( var_0 );

    if ( isdefined( var_8 ) && var_8 )
        var_14 setcursorhint( "HINT_NOICON" );
    else
        var_14 setcursorhint( "HINT_BUTTON" );

    if ( isdefined( var_2 ) )
        var_14 sethintstring( var_2 );

    var_16 = 360;

    if ( isdefined( var_3 ) )
        var_16 = var_3;

    var_14 sethintdisplayfov( var_16 );
    var_17 = 65;

    if ( isdefined( var_13 ) )
        var_17 = var_13;

    var_14 setusefov( var_17 );
    var_18 = 500;

    if ( isdefined( var_4 ) )
        var_18 = var_4;

    var_14 sethintdisplayrange( var_18 );
    var_19 = 80;

    if ( isdefined( var_5 ) )
        var_19 = var_5;

    var_14 setuserange( var_19 );

    if ( isdefined( var_6 ) && var_6 )
        var_14 sethintonobstruction( "show" );
    else
        var_14 sethintonobstruction( "hide" );

    if ( isdefined( var_7 ) && var_7 )
        var_14 sethintrequiresmashing( var_7 );

    if ( !isdefined( var_10 ) )
        var_10 = "duration_short";

    var_14 setuseholdduration( var_10 );

    if ( var_10 == "duration_medium" || var_10 == "duration_long" )
        var_14 sethintrequiresholding( 1 );

    thread hint_delete_on_trigger();

    if ( isdefined( var_9 ) )
        var_14 sethinticon( var_9 );

    if ( isdefined( var_11 ) )
        var_14 setusecommand( var_11 );

    if ( isdefined( var_12 ) )
        var_14 sethintlockplayermovement( 1 );
    else
        var_14 sethintlockplayermovement( 0 );

    var_14 makeusable();
    return var_14;
}

hint_ent_notify_trigger()
{
    self endon( "death" );
    self endon( "hint_destroyed" );
    self.cursor_hint_ent waittill( "trigger", var_0 );
    self notify( "trigger", var_0 );
}

hint_delete_on_trigger()
{
    self endon( "hint_destroyed" );
    var_0 = self;

    if ( isdefined( self.cursor_hint_ent ) )
        var_0 = self.cursor_hint_ent;

    hint_delete_on_trigger_waittill( var_0 );
    thread remove_cursor_hint();
}

hint_delete_on_trigger_waittill( var_0 )
{
    self endon( "entitydeleted" );
    var_0 waittill( "trigger" );
}

outline_fade_alpha_for_index( var_0, var_1, var_2 )
{
    thread outline_fade_alpha_for_index_internal( var_0, var_1, var_2 );
}

outline_fade_alpha_for_index_internal( var_0, var_1, var_2 )
{
    level notify( "hud_outline_alpha_fade_" + var_0 );
    level endon( "hud_outline_alpha_fade_" + var_0 );
    var_0++;
    var_3 = "cg_hud_outline_colors_" + var_0;
    var_4 = getdvar( var_3 );
    var_4 = strtok( var_4, " " );
    var_5 = var_4[0] + " " + var_4[1] + " " + var_4[2] + " ";
    var_6 = float( var_4[3] );
    var_7 = var_1 - var_6;
    var_8 = 0.05;
    var_9 = int( var_2 / var_8 );

    if ( var_9 > 0 )
    {
        for ( var_10 = var_7 / var_9; var_9; var_9-- )
        {
            var_6 = var_6 + var_10;
            var_6 = clamp( var_6, 0, 1 );
            setsaveddvar( var_3, var_5 + var_6 );
            wait( var_8 );
        }
    }

    setsaveddvar( var_3, var_5 + var_1 );
}

add_wait( var_0, var_1, var_2, var_3 )
{
    init_waits();
    var_4 = spawnstruct();
    var_4.caller = self;
    var_4.func = var_0;
    var_4.parms = [];

    if ( isdefined( var_1 ) )
        var_4.parms[var_4.parms.size] = var_1;

    if ( isdefined( var_2 ) )
        var_4.parms[var_4.parms.size] = var_2;

    if ( isdefined( var_3 ) )
        var_4.parms[var_4.parms.size] = var_3;

    if ( !isdefined( level.waits.wait_any_func_array ) )
        level.waits.wait_any_func_array = [ var_4 ];
    else
        level.waits.wait_any_func_array[level.waits.wait_any_func_array.size] = var_4;
}

init_waits()
{
    if ( !scripts\engine\utility::add_init_script( "waits", ::init_waits ) )
        return;

    level.waits = spawnstruct();
    level.waits.wait_any_func_array = [];
    level.waits.run_func_after_wait_array = [];
    level.waits.run_call_after_wait_array = [];
    level.waits.run_noself_call_after_wait_array = [];
    level.waits.do_wait_endons_array = [];
    level.waits.abort_wait_any_func_array = [];
}

add_wait_asserter()
{
    level notify( "kill_add_wait_asserter" );
    level endon( "kill_add_wait_asserter" );

    for ( var_0 = 0; var_0 < 20; var_0++ )
        waittillframeend;
}

do_wait_any()
{
    init_waits();
    do_wait( level.waits.wait_any_func_array.size - 1 );
}

do_wait( var_0 )
{
    init_waits();

    if ( !isdefined( var_0 ) )
        var_0 = 0;

    var_1 = spawnstruct();
    var_2 = level.waits.wait_any_func_array;
    var_3 = level.waits.do_wait_endons_array;
    var_4 = level.waits.run_func_after_wait_array;
    var_5 = level.waits.run_call_after_wait_array;
    var_6 = level.waits.run_noself_call_after_wait_array;
    var_7 = level.waits.abort_wait_any_func_array;
    level.waits.wait_any_func_array = [];
    level.waits.run_func_after_wait_array = [];
    level.waits.do_wait_endons_array = [];
    level.waits.abort_wait_any_func_array = [];
    level.waits.run_call_after_wait_array = [];
    level.waits.run_noself_call_after_wait_array = [];
    var_1.count = var_2.size;
    var_1 scripts\engine\utility::array_levelthread( var_2, ::waittill_func_ends, var_3 );
    var_1 thread do_abort( var_7 );
    var_1 endon( "any_funcs_aborted" );

    for (;;)
    {
        if ( var_1.count <= var_0 )
            break;

        var_1 waittill( "func_ended" );
    }

    var_1 notify( "all_funcs_ended" );
    scripts\engine\utility::array_levelthread( var_4, ::exec_func, [] );
    scripts\engine\utility::array_levelthread( var_5, ::exec_call );
    scripts\engine\utility::array_levelthread( var_6, ::exec_call_noself );
}

exec_call( var_0 )
{
    if ( var_0.parms.size == 0 )
        var_0.caller call [[ var_0.func ]]();
    else if ( var_0.parms.size == 1 )
        var_0.caller call [[ var_0.func ]]( var_0.parms[0] );
    else if ( var_0.parms.size == 2 )
        var_0.caller call [[ var_0.func ]]( var_0.parms[0], var_0.parms[1] );
    else if ( var_0.parms.size == 3 )
        var_0.caller call [[ var_0.func ]]( var_0.parms[0], var_0.parms[1], var_0.parms[2] );

    if ( var_0.parms.size == 4 )
        var_0.caller call [[ var_0.func ]]( var_0.parms[0], var_0.parms[1], var_0.parms[2], var_0.parms[3] );

    if ( var_0.parms.size == 5 )
        var_0.caller call [[ var_0.func ]]( var_0.parms[0], var_0.parms[1], var_0.parms[2], var_0.parms[3], var_0.parms[4] );
}

exec_call_noself( var_0 )
{
    if ( var_0.parms.size == 0 )
        call [[ var_0.func ]]();
    else if ( var_0.parms.size == 1 )
        call [[ var_0.func ]]( var_0.parms[0] );
    else if ( var_0.parms.size == 2 )
        call [[ var_0.func ]]( var_0.parms[0], var_0.parms[1] );
    else if ( var_0.parms.size == 3 )
        call [[ var_0.func ]]( var_0.parms[0], var_0.parms[1], var_0.parms[2] );

    if ( var_0.parms.size == 4 )
        call [[ var_0.func ]]( var_0.parms[0], var_0.parms[1], var_0.parms[2], var_0.parms[3] );

    if ( var_0.parms.size == 5 )
        call [[ var_0.func ]]( var_0.parms[0], var_0.parms[1], var_0.parms[2], var_0.parms[3], var_0.parms[4] );
}

exec_func( var_0, var_1 )
{
    if ( !isdefined( var_0.caller ) )
        return;

    for ( var_2 = 0; var_2 < var_1.size; var_2++ )
        var_1[var_2].caller endon( var_1[var_2].ender );

    if ( var_0.parms.size == 0 )
        var_0.caller [[ var_0.func ]]();
    else if ( var_0.parms.size == 1 )
        var_0.caller [[ var_0.func ]]( var_0.parms[0] );
    else if ( var_0.parms.size == 2 )
        var_0.caller [[ var_0.func ]]( var_0.parms[0], var_0.parms[1] );
    else if ( var_0.parms.size == 3 )
        var_0.caller [[ var_0.func ]]( var_0.parms[0], var_0.parms[1], var_0.parms[2] );

    if ( var_0.parms.size == 4 )
        var_0.caller [[ var_0.func ]]( var_0.parms[0], var_0.parms[1], var_0.parms[2], var_0.parms[3] );

    if ( var_0.parms.size == 5 )
        var_0.caller [[ var_0.func ]]( var_0.parms[0], var_0.parms[1], var_0.parms[2], var_0.parms[3], var_0.parms[4] );
}

do_abort( var_0 )
{
    self endon( "all_funcs_ended" );

    if ( !var_0.size )
        return;

    var_1 = 0;
    self.abort_count = var_0.size;
    var_2 = [];
    scripts\engine\utility::array_levelthread( var_0, ::waittill_abort_func_ends, var_2 );

    for (;;)
    {
        if ( self.abort_count <= var_1 )
            break;

        self waittill( "abort_func_ended" );
    }

    self notify( "any_funcs_aborted" );
}

waittill_abort_func_ends( var_0, var_1 )
{
    self endon( "all_funcs_ended" );
    self endon( "any_funcs_aborted" );
    exec_func( var_0, var_1 );
    self.abort_count--;
    self notify( "abort_func_ended" );
}

waittill_func_ends( var_0, var_1 )
{
    self endon( "all_funcs_ended" );
    self endon( "any_funcs_aborted" );
    exec_func( var_0, var_1 );
    self.count--;
    self notify( "func_ended" );
}

waittill_msg( var_0 )
{
    self waittill( var_0 );
}

create_client_overlay( var_0, var_1, var_2 )
{
    if ( isdefined( var_2 ) )
        var_3 = newclienthudelem( var_2 );
    else
        var_3 = newhudelem();

    var_3.x = 0;
    var_3.y = 0;
    var_3 setshader( var_0, 640, 480 );
    var_3.alignx = "left";
    var_3.aligny = "top";
    var_3.sort = 1;
    var_3.horzalign = "fullscreen";
    var_3.vertalign = "fullscreen";
    var_3.alpha = var_1;
    var_3.foreground = 1;
    return var_3;
}

createhintobject( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9, var_10, var_11 )
{
    var_12 = undefined;

    if ( isdefined( var_11 ) )
        var_12 = var_11;
    else
        var_12 = spawn( "script_model", var_0 );

    var_12 sethintobject( undefined, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9, var_10 );

    if ( !isdefined( var_4 ) )
        var_12 setusepriority( 0 );

    if ( !isdefined( var_11 ) )
        return var_12;
}

clearhintobject( var_0 )
{

}

get_actual_time_from_civil( var_0, var_1, var_2 )
{
    level endon( "game_ended" );

    if ( isdefined( var_1 ) )
        var_3 = var_1;
    else
    {
        var_3 = getsystemtime();

        if ( isdefined( level.isdaylightsavings ) && level.isdaylightsavings )
            var_3 = var_3 + 3600;
    }

    if ( isdefined( var_0 ) )
        var_3 = var_3 - 3600 * var_0;

    var_4 = 1970;
    var_5 = floor( var_3 / 31536000 );

    if ( var_5 != 0 )
        var_6 = floor( ( var_5 + 2 ) / 4 );
    else
        var_6 = 0;

    var_3 = var_3 - var_5 * 31536000;
    var_3 = var_3 - var_6 * 86400;
    var_4 = var_4 + var_5;

    if ( !is_divisible_by( var_4, 4 ) )
    {
        var_7 = floor( var_5 / 4 );
        var_8 = var_5 / 4;
        var_9 = var_8 - var_7;

        if ( var_9 >= 0.75 )
            var_10 = 1;
        else
            var_10 = 0;
    }
    else
        var_10 = 0;

    if ( var_3 != 0 )
    {
        var_11 = floor( var_3 / 86400 );
        var_3 = var_3 - var_11 * 86400;
    }
    else
        var_11 = 0;

    if ( var_3 != 0 )
    {
        var_12 = floor( var_3 / 3600 );
        var_3 = var_3 - var_12 * 3600;
    }
    else
        var_12 = 0;

    if ( var_3 != 0 )
    {
        var_13 = floor( var_3 / 60 );
        var_3 = var_3 - var_13 * 60;
    }
    else
        var_13 = 0;

    var_14 = determine_correct_month( var_11 + 1, var_10 );
    var_14["year"] = var_4;
    var_14["hours"] = var_12;
    var_14["minutes"] = var_13;
    var_14["seconds"] = var_3;

    if ( isdefined( var_2 ) )
        return var_14;

    if ( isdefined( level.isdaylightsavings ) )
    {
        level notify( "time_check", var_4, var_14["month_string"], var_14["days"], var_12, var_13, var_3 );
        return var_14;
    }
    else
    {
        var_14 = is_daylight_savings( var_14, var_0, var_1 );
        level notify( "time_check", var_4, var_14["month_string"], var_14["days"], var_12, var_13, var_3 );
        return var_14;
    }
}

is_daylight_savings( var_0, var_1, var_2 )
{
    var_3 = 0;

    if ( var_0["month_string"] == "March" && var_0["year"] == 2017 )
        var_3 = 1;
    else if ( var_0["month_string"] == "December" || var_0["month_string"] == "January" || var_0["month_string"] == "February" )
        var_3 = 0;
    else if ( var_0["month_string"] != "March" && var_0["month_string"] != "April" )
        var_3 = 1;
    else if ( var_0["month_string"] == "March" && var_0["days"] >= 14 )
        var_3 = 1;
    else if ( var_0["month_string"] == "November" && var_0["days"] <= 6 )
        var_3 = 0;
    else
        var_3 = 0;

    if ( var_3 )
    {
        level.isdaylightsavings = 1;
        var_0 = get_actual_time_from_civil( var_1, var_2, 1 );
    }
    else
        level.isdaylightsavings = 0;

    return var_0;
}

does_day_fit_in_current_month( var_0, var_1, var_2 )
{
    var_3 = 30;

    switch ( var_1 )
    {
        case "January":
            var_3 = 31;
            break;
        case "February":
            if ( var_2 )
                var_3 = 29;
            else
                var_3 = 28;

            break;
        case "March":
            var_3 = 31;
            break;
        case "April":
            var_3 = 30;
            break;
        case "May":
            var_3 = 31;
            break;
        case "June":
            var_3 = 30;
            break;
        case "July":
            var_3 = 31;
            break;
        case "August":
            var_3 = 31;
            break;
        case "September":
            var_3 = 30;
            break;
        case "October":
            var_3 = 31;
            break;
        case "November":
            var_3 = 30;
            break;
        case "December":
            var_3 = 31;
            break;
        default:
            break;
    }

    if ( var_0 > var_3 )
        return 1;
    else
        return 0;
}

determine_correct_month( var_0, var_1 )
{
    var_2 = [];
    var_2["month"] = undefined;
    var_2["month_string"] = undefined;
    var_2["days"] = undefined;
    var_3 = int( istrue( var_1 ) );

    if ( var_0 <= 31 )
    {
        var_2["month"] = 1;
        var_2["month_string"] = "January";
        var_2["days"] = var_0;
        return var_2;
    }
    else if ( var_0 <= 59 + var_3 )
    {
        var_2["month"] = 2;
        var_2["month_string"] = "February";
        var_2["days"] = var_0 - 31;
        return var_2;
    }
    else if ( var_0 <= 90 + var_3 )
    {
        var_2["month"] = 3;
        var_2["month_string"] = "March";
        var_2["days"] = var_0 - ( 59 + var_3 );
        return var_2;
    }
    else if ( var_0 <= 120 + var_3 )
    {
        var_2["month"] = 4;
        var_2["month_string"] = "April";
        var_2["days"] = var_0 - ( 90 + var_3 );
        return var_2;
    }
    else if ( var_0 <= 151 + var_3 )
    {
        var_2["month"] = 5;
        var_2["month_string"] = "May";
        var_2["days"] = var_0 - ( 120 + var_3 );
        return var_2;
    }
    else if ( var_0 <= 182 + var_3 )
    {
        var_2["month"] = 6;
        var_2["month_string"] = "June";
        var_2["days"] = var_0 - ( 151 + var_3 );
        return var_2;
    }
    else if ( var_0 <= 212 + var_3 )
    {
        var_2["month"] = 7;
        var_2["month_string"] = "July";
        var_2["days"] = var_0 - ( 182 + var_3 );
        return var_2;
    }
    else if ( var_0 <= 243 + var_3 )
    {
        var_2["month"] = 8;
        var_2["month_string"] = "August";
        var_2["days"] = var_0 - ( 212 + var_3 );
        return var_2;
    }
    else if ( var_0 <= 273 + var_3 )
    {
        var_2["month"] = 9;
        var_2["month_string"] = "September";
        var_2["days"] = var_0 - ( 243 + var_3 );
        return var_2;
    }
    else if ( var_0 <= 304 + var_3 )
    {
        var_2["month"] = 10;
        var_2["month_string"] = "Octobor";
        var_2["days"] = var_0 - ( 273 + var_3 );
        return var_2;
    }
    else if ( var_0 <= 335 + var_3 )
    {
        var_2["month"] = 11;
        var_2["month_string"] = "November";
        var_2["days"] = var_0 - ( 304 + var_3 );
        return var_2;
    }
    else
    {
        var_2["month"] = 12;
        var_2["month_string"] = "December";
        var_2["days"] = var_0 - ( 335 + var_3 );
        return var_2;
    }
}

set_friendlyfire_warnings( var_0 )
{
    if ( var_0 )
        self.friendlyfire_warnings_disable = undefined;
    else
        self.friendlyfire_warnings_disable = 1;
}

battlechatter_on( var_0 )
{
    thread battlechatter_on_thread( var_0 );
}

battlechatter_on_thread( var_0 )
{
    level endon( "battlechatter_off_thread" );
    scripts\cp\cp_battlechatter::bcs_setup_chatter_toggle_array();

    while ( !isdefined( anim.chatinitialized ) )
        waitframe();

    anim.bcs_enabled = 1;
    wait 1.5;

    if ( isdefined( var_0 ) )
    {
        scripts\cp\cp_battlechatter::set_battlechatter_variable( var_0, 1 );
        var_1 = getaiarray( var_0 );
    }
    else
    {
        foreach ( var_0 in anim.teams )
            scripts\cp\cp_battlechatter::set_battlechatter_variable( var_0, 1 );

        var_1 = getaiarray();
    }

    if ( isdefined( level.jackal ) && isdefined( level.jackal.active_jackals ) )
        var_1 = scripts\engine\utility::array_combine( var_1, level.jackal.active_jackals );

    for ( var_4 = 0; var_4 < var_1.size; var_4++ )
        var_1[var_4] set_battlechatter( 1 );
}

set_battlechatter( var_0 )
{
    if ( !isdefined( anim.chatinitialized ) || !anim.chatinitialized )
        return;

    if ( istrue( self.battlechatter_removed ) )
        return;

    if ( var_0 )
    {
        if ( isdefined( self.script_bcdialog ) && !self.script_bcdialog )
            self.battlechatterallowed = 0;
        else
            self.battlechatterallowed = 1;
    }
    else
    {
        self.battlechatterallowed = 0;

        if ( isdefined( self.battlechatter ) && istrue( self.battlechatter.isspeaking ) )
            self waittill( "done speaking" );
    }
}

getvehiclearray()
{
    return vehicle_getarray();
}

get_player_from_self()
{
    if ( isdefined( self ) )
    {
        if ( !scripts\engine\utility::array_contains( level.players, self ) )
            return level.player;
        else
            return self;
    }
    else
        return level.players[0];
}

player_looking_at( var_0, var_1, var_2, var_3 )
{
    if ( !isdefined( var_1 ) )
        var_1 = 0.8;

    var_4 = get_player_from_self();
    var_5 = var_4 geteye();
    var_6 = vectortoangles( var_0 - var_5 );
    var_7 = anglestoforward( var_6 );
    var_8 = var_4 getplayerangles();
    var_9 = anglestoforward( var_8 );
    var_10 = vectordot( var_7, var_9 );

    if ( var_10 < var_1 )
        return 0;

    if ( isdefined( var_2 ) )
        return 1;

    return scripts\engine\trace::ray_trace_detail_passed( var_0, var_5, var_3, scripts\engine\trace::create_default_contents( 1 ) );
}

is_divisible_by( var_0, var_1 )
{
    if ( floor( var_0 / var_1 ) > var_0 / var_1 )
        return 1;
    else
        return 0;
}

array_merge( var_0, var_1 )
{
    if ( var_0.size == 0 )
        return var_1;

    if ( var_1.size == 0 )
        return var_0;

    var_2 = var_0;

    foreach ( var_4 in var_1 )
    {
        var_5 = 0;

        foreach ( var_7 in var_0 )
        {
            if ( var_7 == var_4 )
            {
                var_5 = 1;
                break;
            }
        }

        if ( var_5 )
            continue;
        else
            var_2[var_2.size] = var_4;
    }

    return var_2;
}

create_sunflare_setting( var_0 )
{
    if ( !isdefined( level.sunflare_settings ) )
        level.sunflare_settings = [];

    var_1 = spawnstruct();
    var_1.name = var_0;
    level.sunflare_settings[var_0] = var_1;
    return var_1;
}

vectortoanglessafe( var_0, var_1 )
{
    var_2 = vectorcross( var_0, var_1 );
    var_1 = vectorcross( var_2, var_0 );
    var_3 = axistoangles( var_0, var_2, var_1 );
    return var_3;
}

createuseent( var_0 )
{
    var_1 = spawn( "script_origin", var_0 );
    var_1.curprogress = 0;
    var_1.usetime = 0;
    var_1.userate = 8000;
    var_1.inuse = 0;
    return var_1;
}

getinteractionbynoteworthy( var_0 )
{
    foreach ( var_2 in level.current_interaction_structs )
    {
        if ( var_2.script_noteworthy == var_0 )
            return var_2;
    }

    return undefined;
}

quicksort( var_0, var_1 )
{
    return quicksortmid( var_0, 0, var_0.size - 1, var_1 );
}

quicksortmid( var_0, var_1, var_2, var_3 )
{
    var_4 = var_1;
    var_5 = var_2;

    if ( !isdefined( var_3 ) )
        var_3 = ::quicksort_compare;

    if ( var_2 - var_1 >= 1 )
    {
        var_6 = var_0[var_1];

        while ( var_5 > var_4 )
        {
            while ( [[ var_3 ]]( var_0[var_4].patrolscore, var_6.patrolscore ) && var_4 <= var_2 && var_5 > var_4 )
                var_4++;

            while ( ![[ var_3 ]]( var_0[var_5].patrolscore, var_6.patrolscore ) && var_5 >= var_1 && var_5 >= var_4 )
                var_5--;

            if ( var_5 > var_4 )
                var_0 = swap( var_0, var_4, var_5 );
        }

        var_0 = swap( var_0, var_1, var_5 );
        var_0 = quicksortmid( var_0, var_1, var_5 - 1, var_3 );
        var_0 = quicksortmid( var_0, var_5 + 1, var_2, var_3 );
    }
    else
        return var_0;

    return var_0;
}

quicksort_compare( var_0, var_1 )
{
    return var_0 <= var_1;
}

swap( var_0, var_1, var_2 )
{
    var_3 = var_0[var_1];
    var_0[var_1] = var_0[var_2];
    var_0[var_2] = var_3;
    return var_0;
}

hideminimap( var_0 )
{
    if ( !isdefined( self.minimapstatetracker ) )
        self.minimapstatetracker = 0;

    var_1 = self.minimapstatetracker;
    self.minimapstatetracker--;

    if ( self.minimapstatetracker < 0 )
        self.minimapstatetracker = 0;

    if ( istrue( var_0 ) || self.minimapstatetracker == 0 && var_1 > self.minimapstatetracker )
    {
        self setclientomnvar( "ui_hide_minimap", 1 );

        if ( istrue( var_0 ) )
            self.minimapstatetracker = 0;
    }
}

showminimap()
{
    if ( postspawn_trucks() )
        return;

    if ( !isdefined( self.minimapstatetracker ) )
        self.minimapstatetracker = 0;

    var_0 = self.minimapstatetracker;
    self.minimapstatetracker++;

    if ( self.minimapstatetracker == 1 && var_0 < self.minimapstatetracker )
        self setclientomnvar( "ui_hide_minimap", 0 );
}

getplayerdataloadoutgroup()
{
    if ( getdvarint( "LPSPMQSNPQ" ) )
        return "privateloadouts";
    else
        return "rankedloadouts";
}

disableplayerminimap()
{
    self endon( "death" );
    self endon( "disconnect" );
    level endon( "game_ended" );

    for (;;)
    {
        self waittill( "giveLoadout" );
        hideminimap( 1 );
    }
}

allow_change_stance( var_0 )
{
    var_1 = self getstance();

    switch ( var_1 )
    {
        case "stand":
            scripts\common\utility::allow_crouch( var_0 );
            scripts\common\utility::allow_prone( var_0 );
            break;
        case "crouch":
            scripts\common\utility::allow_stand( var_0 );
            scripts\common\utility::allow_prone( var_0 );
            break;
        case "prone":
            scripts\common\utility::allow_stand( var_0 );
            scripts\common\utility::allow_crouch( var_0 );
            break;
    }
}

getplayersinteam( var_0 )
{
    if ( !isdefined( var_0 ) )
        var_0 = "allies";

    var_1 = [];

    foreach ( var_3 in level.players )
    {
        if ( var_3.team == var_0 )
            var_1[var_1.size] = var_3;
    }

    return var_1;
}

teleportallplayersinteamtostructs( var_0, var_1, var_2 )
{
    var_3 = scripts\engine\utility::getstructarray( var_1, "targetname" );

    if ( !isdefined( var_3 ) || var_3.size < 4 )
        return;

    scripts\engine\utility::flag_wait( "player_spawned_with_loadout" );
    var_4 = 0;

    foreach ( var_6 in getplayersinteam( var_0 ) )
    {
        var_3[var_4].angles = scripts\engine\utility::ter_op( isdefined( var_3[var_4].angles ), var_3[var_4].angles, ( 0, 0, 0 ) );
        var_6 setorigin( var_3[var_4].origin );
        var_6 setplayerangles( var_3[var_4].angles );
        var_6 dontinterpolate();
        var_4++;
    }

    if ( !istrue( var_2 ) )
        return;

    level thread thread_teleportplayertoteamstructs_latejoin( var_0, var_1 );
}

thread_teleportplayertoteamstructs_latejoin( var_0, var_1 )
{
    level endon( "game_ended" );
    level notify( "waiting_for_team_teleports_" + var_0 );
    level endon( "waiting_for_team_teleports_" + var_0 );

    for (;;)
    {
        level waittill( "connected", var_2 );
        level thread teleportplayertoteamstructs_latejoin( var_2, var_1 );
    }
}

teleportplayertoteamstructs_latejoin( var_0, var_1 )
{
    var_0 endon( "disconnect" );
    var_0 waittill( "spawned_player" );
    waitframe();
    teleportplayertoteamstructs( var_0, var_1 );
}

teleportplayertoteamstructs( var_0, var_1 )
{
    var_2 = scripts\engine\utility::getstructarray( var_1, "targetname" );

    if ( !isdefined( var_2 ) || var_2.size < 4 )
        return;

    var_3 = randomintrange( 0, var_2.size );
    var_2[var_3].angles = scripts\engine\utility::ter_op( isdefined( var_2[var_3].angles ), var_2[var_3].angles, ( 0, 0, 0 ) );
    var_0 setorigin( var_2[var_3].origin );
    var_0 setplayerangles( var_2[var_3].angles );
    var_0 dontinterpolate();
}

string_is_single_digit_integer( var_0 )
{
    if ( var_0.size > 1 )
        return 0;

    var_1 = [];
    var_1["0"] = 1;
    var_1["1"] = 1;
    var_1["2"] = 1;
    var_1["3"] = 1;
    var_1["4"] = 1;
    var_1["5"] = 1;
    var_1["6"] = 1;
    var_1["7"] = 1;
    var_1["8"] = 1;
    var_1["9"] = 1;

    if ( isdefined( var_1[var_0] ) )
        return 1;

    return 0;
}

init_vehicle_omnvars()
{
    self setclientomnvar( "ui_veh_vehicle", -1 );
    self setclientomnvar( "ui_veh_occupant_0", -1 );
    self setclientomnvar( "ui_veh_occupant_1", -1 );
    self setclientomnvar( "ui_veh_occupant_2", -1 );
    self setclientomnvar( "ui_veh_occupant_3", -1 );
    self setclientomnvar( "ui_veh_occupant_4", -1 );
}

printgameaction( var_0, var_1 )
{
    if ( getdvarint( "scr_suppress_game_actions", 0 ) == 1 )
        return;

    var_2 = "";

    if ( isdefined( var_1 ) )
        var_2 = "[" + var_1 getentitynumber() + ":" + var_1.name + "] ";
}

isplayerads()
{
    return self playerads() > 0.5;
}

isairdenied()
{
    if ( isai( self ) )
        return 0;

    if ( self.team == "spectator" )
        return 0;

    return 0;
}

get_center_point_of_array( var_0 )
{
    var_1 = ( 0, 0, 0 );

    for ( var_2 = 0; var_2 < var_0.size; var_2++ )
        var_1 = ( var_1[0] + var_0[var_2].origin[0], var_1[1] + var_0[var_2].origin[1], var_1[2] + var_0[var_2].origin[2] );

    return ( var_1[0] / var_0.size, var_1[1] / var_0.size, var_1[2] / var_0.size );
}

sethintobject( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8, var_9, var_10 )
{
    self makeusable();

    if ( isdefined( var_0 ) )
        self sethinttag( var_0 );

    if ( isdefined( var_1 ) )
        self setcursorhint( var_1 );
    else
        self setcursorhint( "HINT_NOICON" );

    if ( isdefined( var_2 ) )
        self sethinticon( var_2 );

    if ( isdefined( var_3 ) )
        self sethintstring( var_3 );

    if ( isdefined( var_4 ) )
    {
        var_4 = int( clamp( var_4, -10, 1 ) );
        self setusepriority( var_4 );
    }
    else
        self setusepriority( -10 );

    if ( isdefined( var_5 ) )
    {
        self setuseholdduration( var_5 );

        if ( var_5 == "duration_medium" || var_5 == "duration_long" )
            self sethintrequiresholding( 1 );
    }
    else
        self setuseholdduration( "duration_short" );

    if ( isdefined( var_6 ) )
        self sethintonobstruction( var_6 );
    else
        self sethintonobstruction( "hide" );

    if ( isdefined( var_7 ) )
        self sethintdisplayrange( var_7 );
    else
        self sethintdisplayrange( 200 );

    if ( isdefined( var_8 ) )
        self sethintdisplayfov( var_8 );
    else
        self sethintdisplayfov( 160 );

    if ( isdefined( var_9 ) )
        self setuserange( var_9 );
    else
        self setuserange( 50 );

    if ( isdefined( var_10 ) )
        self setusefov( var_10 );
    else
        self setusefov( 120 );
}

is_indoors( var_0 )
{
    var_1 = 0;
    var_2 = ( 0, 0, 0 );

    if ( isent( var_0 ) )
        var_2 = var_0.origin;
    else if ( isvector( var_0 ) )
        var_2 = var_0;
    else if ( isstruct( var_0 ) )
        var_2 = var_0.origin;

    var_3 = scripts\engine\trace::create_contents( 0, 1, 1, 1, 1, 1, 1, 1, 1 );

    if ( !scripts\engine\trace::ray_trace_passed( var_2, var_2 + ( 0, 0, 10000 ), undefined, var_3 ) )
        var_1 = 1;

    return var_1;
}

is_indoors_vehicleignored( var_0 )
{
    var_1 = 0;
    var_2 = ( 0, 0, 0 );

    if ( isent( var_0 ) )
        var_2 = var_0.origin;
    else if ( isvector( var_0 ) )
        var_2 = var_0;
    else if ( isstruct( var_0 ) )
        var_2 = var_0.origin;

    var_3 = scripts\engine\trace::create_contents( 0, 1, 1, 1, 1, 0, 1, 1, 1 );

    if ( !scripts\engine\trace::ray_trace_passed( var_2, var_2 + ( 0, 0, 10000 ), undefined, var_3 ) )
        var_1 = 1;

    return var_1;
}

isgesture( var_0 )
{
    var_1 = undefined;

    if ( issameweapon( var_0 ) )
        var_1 = var_0.basename;
    else
        var_1 = var_0;

    if ( issubstr( var_1, "ges_plyr" ) )
        return 1;
    else if ( issubstr( var_1, "devilhorns_mp" ) )
        return 1;
    else
        return 0;
}

actionslotoverride( var_0, var_1, var_2, var_3 )
{
    self setweaponhudiconoverride( "actionslot" + var_0, var_1 );

    if ( isdefined( var_2 ) )
        setactionslotoverrideammo( var_0, var_2 );

    if ( isdefined( var_3 ) )
        thread actionslotoverridecallback( var_0, var_3 );
}

actionslotoverridecallback( var_0, var_1 )
{
    self endon( "death" );
    self endon( "removeActionslot" + var_0 );
    self notifyonplayercommand( "actionslot" + var_0, "+actionslot " + var_0 );

    for (;;)
    {
        self waittill( "actionslot" + var_0 );
        self thread [[ var_1 ]]();
    }
}

actionslotoverrideremove( var_0 )
{
    self notify( "removeActionslot" + var_0 );
    self setweaponhudiconoverrideammo( "actionslot" + var_0, -1 );
    self setweaponhudiconoverride( "actionslot" + var_0, "none" );
}

setactionslotoverrideammo( var_0, var_1 )
{
    self setweaponhudiconoverrideammo( "actionslot" + var_0, var_1 );
}

demo_button_combo_debug_watcher()
{
    self endon( "disconnect" );

    if ( !isdefined( self.debug_button_combos ) )
        setup_debug_button_combos_for_player();

    self notifyonplayercommand( "up", "+actionslot 1" );
    self notifyonplayercommand( "up_release", "-actionslot 1" );
    self notifyonplayercommand( "down", "+actionslot 2" );
    self notifyonplayercommand( "down_release", "-actionslot 2" );
    self notifyonplayercommand( "use", "+usereload" );
    self notifyonplayercommand( "use", "+activate" );
    self notifyonplayercommand( "use_release", "-usereload" );
    self notifyonplayercommand( "use_release", "-activate" );
    self notifyonplayercommand( "stance", "+stance" );
    self notifyonplayercommand( "stance_release", "-stance" );
    self notifyonplayercommand( "ads", "+speed_throw" );
    self notifyonplayercommand( "ads_release", "-speed_throw" );
    self notifyonplayercommand( "attack", "+attack" );
    self notifyonplayercommand( "attack_release", "-attack" );
    self notifyonplayercommand( "touchpad", "+focus" );
    self notifyonplayercommand( "touchpad", "+togglescores" );
    self notifyonplayercommand( "touchpad", "togglescores" );
    self notifyonplayercommand( "touchpad_release", "-focus" );
    self notifyonplayercommand( "touchpad_release", "-togglescores" );
    self notifyonplayercommand( "swap_weapon", "+weapnext" );
    self notifyonplayercommand( "swap_weapon_release", "-weapnext" );
    self notifyonplayercommand( "A", "+gostand" );
    self notifyonplayercommand( "A_release", "-gostand" );
    self notifyonplayercommand( "RIGHT", "+actionslot 4" );
    var_0 = [ "up", "up_release", "down", "down_release", "use", "use_release", "stance", "stance_release", "A", "A_release", "right", "ads", "ads_release", "attack", "attack_release", "touchpad", "touchpad_release", "swap_weapon", "swap_weapon_release" ];
    var_1 = [];
    var_2 = 2;
    var_3 = undefined;

    for (;;)
    {
        var_4 = level.demo_button_combos;
        var_5 = scripts\engine\utility::waittill_any_in_array_return_no_endon_death( var_0 );

        if ( getdvarint( "scr_demo_debug", 0 ) )
        {
            var_6 = gettime();

            if ( !isdefined( var_3 ) )
                var_3 = var_6 + var_2 * 1000;

            var_1[var_1.size] = var_5;

            if ( var_6 >= var_3 )
            {
                var_3 = undefined;
                var_1 = [];
                continue;
            }
            else
            {
                var_3 = var_6 + var_2 * 1000;
                var_1 = validate_button_combo( var_1 );

                if ( var_1.size < 1 )
                    var_3 = undefined;
            }
        }
    }
}

setup_debug_button_combos_for_player()
{

}

add_demo_button_combo( var_0, var_1, var_2, var_3 )
{
    var_4 = spawnstruct();
    var_4.button_combo = var_0;
    var_4.func = var_1;
    var_4.message = var_2;
    var_4.timeout = var_3;
    level.demo_button_combos[level.demo_button_combos.size] = var_4;
}

validate_button_combo( var_0 )
{
    var_1 = [];

    for ( var_2 = 0; var_2 < level.demo_button_combos.size; var_2++ )
    {
        var_3 = level.demo_button_combos[var_2];
        var_4 = level.demo_button_combos[var_2].button_combo;

        if ( var_0.size <= var_4.size )
        {
            if ( var_0[var_0.size - 1] == var_4[var_0.size - 1] )
            {
                if ( var_0.size == var_4.size )
                {
                    if ( isdefined( var_3.message ) )
                        announcement( var_3.message );

                    var_0 = [];
                    self thread [[ var_3.func ]]();
                }

                var_1 = var_0;
                break;
            }
        }
    }

    return var_1;
}

getenemyteams( var_0 )
{
    var_1 = level.teamnamelist;
    var_1 = scripts\engine\utility::array_remove( var_1, var_0 );
    return var_1;
}

isfemale()
{
    return isdefined( self.operatorcustomization ) && isdefined( self.operatorcustomization.gender ) && self.operatorcustomization.gender == "female";
}

getgametype()
{
    return level.gametype;
}

register_create_script( var_0, var_1, var_2, var_3 )
{
    if ( isdefined( var_0 ) )
        level.scripted_spawner_func_strings[level.scripted_spawner_func_strings.size] = var_0;

    if ( isdefined( var_1 ) )
        level.scripted_spawner_map_strings[level.scripted_spawner_func_strings.size] = var_1;

    if ( isdefined( var_2 ) )
        level.create_script_file_ids[var_0] = "cs" + var_2;

    if ( isdefined( var_3 ) )
        level.scripted_spawner_func[level.scripted_spawner_func.size] = var_3;
}

array_notify( var_0, var_1, var_2 )
{
    foreach ( var_5, var_4 in var_0 )
        var_4 notify( var_1, var_2 );
}

addtoactivekillstreaklist( var_0, var_1, var_2, var_3, var_4, var_5, var_6 )
{
    if ( istrue( var_4 ) )
    {
        var_7 = 0;

        if ( var_2 isusingremote() )
            var_7 = 1;

        var_8 = undefined;

        if ( level.teambased )
            var_8 = thread scripts\cp_mp\entityheadicons::setheadicon_factionimage( 0, var_5, 1, 10000, undefined, undefined, 1, var_7 );
        else
            var_8 = thread scripts\cp_mp\entityheadicons::setheadicon_singleimage( var_2, "hud_icon_head_equipment_friendly", var_5, 1, 10000, undefined, undefined, 1 );

        thread removeteamheadicononnotify( var_8, var_6 );
    }
}

removeteamheadicononnotify( var_0, var_1 )
{
    var_2 = [ "death" ];

    if ( isdefined( var_1 ) )
        var_2[var_2.size] = var_1;

    scripts\engine\utility::waittill_any_in_array_return_no_endon_death( var_2 );
    scripts\cp_mp\entityheadicons::setheadicon_deleteicon( var_0 );
}

killstreak_make_vehicle( var_0, var_1, var_2, var_3, var_4 )
{
    self.vehiclename = var_0;
    self.scorepopup = var_1;
    self.vodestroyed = var_2;
    self.votimeout = var_3;
    self.destroyedsplash = var_4;
    self enableplayermarks( "killstreak" );
    self filteroutplayermarks( self.team );
    scripts\cp_mp\vehicles\vehicle_damage::vehicle_damage_enableownerdamage( self );

    if ( isdefined( self.owner ) )
        self.owner notify( "killstreak_vehicle_made", self );
}

killstreak_set_pre_mod_damage_callback( var_0, var_1 )
{
    killstreak_vehicle_callback_init();
    scripts\cp\vehicles\damage_cp::set_pre_mod_damage_callback( var_0, level.kspremoddamagecallback );
    self.kspremoddamagecallback = var_1;
}

killstreak_set_post_mod_damage_callback( var_0, var_1 )
{
    killstreak_vehicle_callback_init();
    scripts\cp\vehicles\damage_cp::set_post_mod_damage_callback( var_0, level.kspostmoddamagecallback );
    self.kspostmoddamagecallback = var_1;
}

killstreak_set_death_callback( var_0, var_1 )
{
    killstreak_vehicle_callback_init();
    scripts\cp\vehicles\damage_cp::set_death_callback( var_0, level.ksdeathcallback );
    self.ksdeathcallback = var_1;
}

killstreak_vehicle_callback_init()
{
    if ( !istrue( level.kscallbackinitcomplete ) )
    {
        level.kscallbackinitcomplete = 1;
        level.kspremoddamagecallback = ::killstreak_pre_mod_damage_callback;
        level.kspostmoddamagecallback = ::killstreak_post_mod_damage_callback;
        level.ksdeathcallback = ::killstreak_death_callback;
    }
}

killstreak_pre_mod_damage_callback( var_0 )
{
    var_1 = var_0.damage;
    var_2 = var_0.attacker;

    if ( !istrue( self.killoneshot ) )
    {
        if ( isdefined( var_2 ) && isdefined( self.owner ) && var_2 == self.owner )
            var_1 = int( ceil( var_1 * 0.5 ) );

        var_0.damage = var_1;
    }

    var_3 = 1;
    var_4 = self.kspremoddamagecallback;

    if ( isdefined( var_4 ) )
        var_3 = self [[ var_4 ]]( var_0 );

    return var_3;
}

killstreak_post_mod_damage_callback( var_0 )
{
    killstreakhit( var_0.attacker, var_0.objweapon, self, var_0.meansofdeath, var_0.damage );
    var_1 = 1;
    var_2 = self.kspostmoddamagecallback;

    if ( isdefined( var_2 ) )
        var_1 = self [[ var_2 ]]( var_0 );

    return var_1;
}

killstreak_death_callback( var_0 )
{
    onkillstreakkilled( self.streakname, var_0.attacker, var_0.objweapon, var_0.meansofdeath, var_0.damage, self.scorepopup, self.vodestroyed, self.destroyedsplash );
    var_1 = 1;
    var_2 = self.ksdeathcallback;

    if ( isdefined( var_2 ) )
        var_1 = self [[ var_2 ]]( var_0 );

    return var_1;
}

killstreakhit( var_0, var_1, var_2, var_3, var_4 )
{
    if ( isdefined( var_1 ) && isplayer( var_0 ) && isdefined( var_2.owner ) && isdefined( var_2.owner.team ) )
    {
        if ( scripts\cp_mp\utility\player_utility::playersareenemies( var_0, var_2.owner ) )
        {
            if ( iskillstreakweapon( var_1.basename ) )
                return;

            var_5 = createheadicon( var_1 );

            if ( !isdefined( var_0.lasthittime[var_5] ) )
                var_0.lasthittime[var_5] = 0;

            if ( var_0.lasthittime[var_5] == gettime() )
                return;

            var_0.lasthittime[var_5] = gettime();

            if ( onlinestatsenabled() )
            {

            }

            if ( isdefined( var_3 ) && scripts\engine\utility::isbulletdamage( var_3 ) || isprojectiledamage( var_3 ) )
            {
                var_0.lastdamagetime = gettime();
                var_6 = scripts\cp\cp_weapon::getweapongroup( var_1.basename );

                if ( var_6 == "weapon_lmg" )
                {
                    if ( !isdefined( var_0.shotslandedlmg ) )
                        var_0.shotslandedlmg = 1;
                    else
                        var_0.shotslandedlmg++;
                }
            }
        }
    }
}

isprojectiledamage( var_0 )
{
    var_1 = "MOD_PROJECTILE MOD_IMPACT MOD_GRENADE MOD_HEAD_SHOT";

    if ( issubstr( var_1, var_0 ) )
        return 1;

    return 0;
}

onkillstreakkilled( var_0, var_1, var_2, var_3, var_4, var_5, var_6, var_7, var_8 )
{
    var_9 = 0;
    var_10 = undefined;

    if ( isdefined( var_1 ) && isdefined( self.owner ) )
    {
        if ( isdefined( var_1.owner ) && isplayer( var_1.owner ) )
            var_1 = var_1.owner;
    }
    else if ( isdefined( var_1 ) && isdefined( self.team ) && isdefined( var_1.team ) )
    {
        if ( isenemy( var_1 ) && isplayer( var_1 ) )
            var_10 = var_1;
    }

    if ( isdefined( var_10 ) )
    {
        if ( isdefined( var_7 ) )
            var_10 scripts\cp\cp_player_battlechatter::killstreakdestroyed( var_0 );

        thread scripts\cp_mp\challenges::killedkillstreak( var_0, var_10, var_2 );

        if ( !prematchintiallandingcomplete() )
            thread scripts\cp\so_trigger::killstreakkilled( var_0, self.owner, self, var_10, var_4, var_3, var_2, var_5 );

        scripts\cp_mp\gestures::processcalloutdeath( self, var_10 );
        var_9 = 1;
    }

    if ( isdefined( self.owner ) && isdefined( var_6 ) )
    {

    }

    if ( !istrue( var_8 ) )
        self notify( "death" );

    return var_9;
}

onmatchstartbr( var_0 )
{
    onmatchplacement();
    onmaprestart( var_0 + "_heli_entrance", var_0 + "_heli_goal" );
}

onmaprestart( var_0, var_1 )
{
    if ( !isdefined( level.heli_structs_entrances ) )
        level.heli_structs_entrances = [];

    if ( !isdefined( level.heli_structs_goals ) )
        level.heli_structs_goals = [];

    var_2 = scripts\engine\utility::getstruct( var_0, "script_noteworthy" );
    var_3 = scripts\engine\utility::getstruct( var_1, "script_noteworthy" );
    level.heli_structs_entrances[level.heli_structs_entrances.size] = var_2;
    level.heli_structs_goals[level.heli_structs_goals.size] = var_3;
}

onmatchplacement()
{
    if ( isdefined( level.heli_structs_entrances ) && level.heli_structs_entrances.size >= 1 )
        level.heli_structs_entrances = [];

    if ( isdefined( level.heli_structs_goals ) && level.heli_structs_goals.size >= 1 )
        level.heli_structs_goals = [];
}

precomputedropbagpositions()
{
    if ( getdvarint( "scr_fake_raid_mode", 0 ) )
        return 1;

    return level.script == "cp_raid_complex" || level.script == "cp_dntsk_raid" || level.script == "cp_trap_room" || level.script == "cp_raid_phase1";
}

preventleave()
{
    if ( level.gametype == "cp_wave_sv" )
        return 1;

    return 0;
}

prematchintiallandingcomplete()
{
    return level.gametype == "cp_specops";
}

ppkflagcarrier()
{
    if ( level.gametype == "cp_survival" )
        return 1;

    return 0;
}

plundervar()
{
    var_0 = getdvar( "NSQLTTMRMP" );

    if ( var_0 == "cp_raid_complex" || var_0 == "cp_dntsk_raid" )
        return 1;

    return 0;
}

issimultaneouskillenabled()
{
    if ( !isdefined( level.simultaneouskillenabled ) )
        level.simultaneouskillenabled = getdvarint( "MRSNQSMSPL", 0 ) == 0;

    return level.simultaneouskillenabled;
}

onlinestatsenabled()
{
    if ( !isplayer( self ) )
        return 0;

    return level.onlinestatsenabled && !self.usingonlinedataoffline;
}

privatematch()
{
    return level.onlinegame && getdvarint( "LSTLQTSSRM" );
}

getenemycount( var_0, var_1 )
{
    var_2 = 0;
    var_3 = getenemyteams( var_0 );

    foreach ( var_5 in var_3 )
        var_2 = var_2 + getteamcount( var_5, istrue( var_1 ) );

    return var_2;
}

getteamcount( var_0, var_1 )
{
    if ( istrue( var_1 ) )
        return level.teamdata[var_0]["alivePlayers"].size;
    else
        return level.teamdata[var_0]["players"].size;
}

getenemyplayers( var_0, var_1 )
{
    var_2 = [];
    var_3 = getenemyteams( var_0 );

    foreach ( var_5 in var_3 )
    {
        if ( istrue( var_1 ) )
        {
            foreach ( var_7 in level.teamdata[var_5]["alivePlayers"] )
            {
                if ( isdefined( var_7 ) && isalive( var_7 ) && !isdefined( var_7.fauxdead ) )
                    var_2[var_2.size] = var_7;
            }

            continue;
        }

        foreach ( var_7 in level.teamdata[var_5]["players"] )
            var_2[var_2.size] = var_7;
    }

    return var_2;
}

trial_retrieve_persistent_values( var_0, var_1 )
{
    var_2 = level.players;

    if ( isdefined( var_1 ) )
    {
        if ( !isarray( var_1 ) )
            var_2 = [ var_1 ];
        else
            var_2 = var_1;
    }

    foreach ( var_4 in var_2 )
        var_4 setplayermusicstate( var_0 );
}

_id_12ECF( var_0 )
{
    level endon( "game_ended" );
    self endon( "death" );
    self endon( "disconnect" );
    self endon( "dropped_hostage" );
    self endon( "stop_hostagecarrier_watching_for_doors" );
    var_1 = self;
    var_0 = scripts\engine\utility::ter_op( isdefined( var_0 ), var_0, 64 );
    var_2 = 1.5;
    var_3 = [ "scriptable_door_wooden_panel_mp_01", "scriptable_door_wooden_hollow_mp_01" ];

    for (;;)
    {
        var_4 = [];
        var_5 = getentitylessscriptablearrayinradius( undefined, undefined, var_1.origin, var_0 );

        for ( var_6 = 0; var_6 < var_5.size; var_6++ )
        {
            if ( var_5[var_6] scriptableisdoor() )
                var_4[var_4.size] = var_5[var_6];
        }

        for ( var_7 = 0; var_7 < var_4.size; var_7++ )
            var_4[var_7] setscriptablepartstate( "door", "left_30", 0 );

        wait( var_2 );
    }
}

light_tank_monitorgunnerturretfire()
{
    var_0 = 0;

    foreach ( var_2 in level.players )
    {
        if ( var_2 is_valid_player() )
            var_0++;
    }

    return var_0;
}

_id_127CC( var_0, var_1 )
{
    self endon( "death" );
    self notify( "track_last_good_position" );
    self endon( "track_last_good_position" );

    if ( !isdefined( var_1 ) )
        var_1 = 0.1;

    for (;;)
    {
        wait( var_1 );

        if ( !isdefined( self ) )
            continue;

        if ( !isdefined( self.origin ) )
            continue;

        if ( isdefined( self.last_good_pos ) && self.origin == self.last_good_pos )
            continue;

        if ( !isalive( self ) )
            continue;

        if ( self isjumping() )
            continue;

        if ( self isparachuting() )
            continue;

        if ( self isonladder() )
            continue;

        if ( !self isonground() )
            continue;

        if ( scripts\cp\cp_laststand::player_in_laststand( self ) )
            continue;

        if ( isdefined( level.outofboundstriggers ) )
        {
            foreach ( var_3 in level.outofboundstriggers )
            {
                if ( self istouching( var_3 ) )
                    continue;
            }
        }

        if ( isdefined( level.landmine_trig ) && self istouching( level.landmine_trig ) )
            continue;

        if ( istrue( self.spectating ) )
            continue;

        if ( istrue( self.picking_up_minigun ) )
            continue;

        if ( istrue( self.landmine_active ) )
            continue;

        if ( istrue( var_0 ) && !ispointonnavmesh( self.origin ) )
            continue;

        self.last_good_pos = self.origin;
    }
}
