// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

traversal_assist_init()
{
    if ( !istrue( level.teambased ) )
        return;

    level.usequickrope = getdvarint( "scr_buddyboost_rope", 1 ) == 1;
    level.pullbothup = getdvarint( "scr_buddyboost_both", 1 ) == 1;
    level.traversalassist = [];
    level.traversalassistmode = 3;

    if ( getdvarint( "scr_buddyboost_enabled", 1 ) == 0 )
        return;

    add_traversalassist_array();
    add_contextualwalltraversal_array();

    if ( getdvarint( "scr_buddyboost_debug", 0 ) == 1 )
        thread debug_loopbuddyboostanims();
}

#using_animtree("script_model");

create_player_rig( var_0, var_1, var_2 )
{
    if ( !isdefined( var_0 ) || isdefined( var_0.player_rig ) )
        return;

    var_0.animname = var_1;

    if ( !isdefined( var_2 ) )
        var_2 = "viewhands_base_iw8";

    if ( getdvarint( "scr_buddyboost_force", 2 ) != 0 )
    {
        if ( isdefined( self.p1.wallscenenodepos ) )
        {
            self.initialorg.origin = self.p1.wallscenenodepos;
            self.initialorg.angles = self.p1.wallscenenodeang;
        }

        var_0 setorigin( self.initialorg.origin );
        var_0 setplayerangles( self.initialorg.angles );
    }

    var_0 predictstreampos( self.initialorg.origin );
    var_3 = spawn( "script_arms", self.initialorg.origin, 0, 0, var_0 );
    var_3.player = var_0;
    var_0.player_rig = var_3;
    var_0.player_rig hide();
    var_0.player_rig.animname = var_1;
    var_0.player_rig useanimtree( #animtree );
    var_0 playerlinktodelta( var_0.player_rig, "tag_player", 1, 0, 0, 0, 0, 0, 0 );
    var_0 watch_remove_rig( self );
    remove_player_rig( var_0 );
}

remove_player_rig( var_0 )
{
    if ( !isdefined( var_0 ) || !isdefined( var_0.player_rig ) )
        return;

    var_0 unlink();
    var_0.player_rig delete();
    var_0.player_rig = undefined;
}

watch_remove_rig( var_0 )
{
    thread actioncancellation( var_0 );
    thread playercancellation();
    self waittill( "can_remove_rig" );
}

actioncancellation( var_0 )
{
    var_0 waittill( "traverseassist_cancelled" );
    self notify( "can_remove_rig" );
}

playercancellation()
{
    scripts\engine\utility::_id_12E40( "remove_rig", "death", "disconnect" );
    self notify( "can_remove_rig" );
}

add_traversalassist_array()
{
    var_0 = getentarray( "traversalassist", "targetname" );

    foreach ( var_2 in var_0 )
    {
        var_3 = spawnstruct();
        add_traversalassist( var_3, var_2 );
        var_3 thread setup_traversalassist();
        level.traversalassist[level.traversalassist.size] = var_3;
    }
}

disable_traversalassists()
{
    foreach ( var_1 in level.traversalassist )
    {
        var_1.initialtrigger makeunusable();
        var_1.boosttrigger makeunusable();
        var_1.toptrigger makeunusable();
        var_1.pulluptrigger makeunusable();

        if ( isdefined( var_1.topwatchtrigger ) )
            var_1.topwatchtrigger makeunusable();
    }
}

add_traversalassist( var_0, var_1 )
{
    if ( !isdefined( var_0.ents ) )
        var_0.ents = [];

    switch ( var_1.classname )
    {
        case "trigger_use_touch":
            var_0.use_trigger = var_1;
            break;
    }

    if ( isdefined( var_1.script_noteworthy ) )
    {
        switch ( var_1.script_noteworthy )
        {
            case "initialOrg":
                var_0.initialorg = var_1;
                break;
            case "finalOrg":
                var_0.finalorg = var_1;
                break;
        }
    }

    var_0.ents[var_0.ents.size] = var_1;

    if ( isdefined( var_1.target ) )
    {
        var_2 = getentarray( var_1.target, "targetname" );

        if ( isdefined( var_2 ) && var_2.size > 0 )
        {
            foreach ( var_4 in var_2 )
                add_traversalassist( var_0, var_4 );
        }
    }
}

setup_traversalassist( var_0 )
{
    spawnhintobjects( var_0 );
    self.phase = 0;
    setphase( 0 );
    thread handlephasecancellation();
}

assist_onbeginuse( var_0 )
{
    self.parent.p1 = var_0;
    self.parent thread setphase( 1 );
}

assist_onenduse( var_0, var_1, var_2 )
{
    if ( !var_2 && ( self.parent.phase == 1 || self.parent.phase == 2 ) )
        self.parent notify( "traverseassist_cancelled" );
}

watchdeath( var_0 )
{
    self endon( "traverseassist_cancelled" );
    var_1 = var_0.name;
    var_0 waittill( "death" );
    self notify( "traverseassist_cancelled" );
}

watchdisconnect( var_0 )
{
    self endon( "traverseassist_cancelled" );
    var_1 = var_0.name;
    var_0 waittill( "disconnect" );
    self notify( "traverseassist_cancelled" );
}

setphase( var_0 )
{
    var_1 = self.phase;
    self.phase = var_0;

    switch ( var_1 )
    {
        case 0:
            break;
        case 1:
            break;
        case 2:
            break;
        case 3:
            break;
        case 4:
            break;
        case 5:
            break;
        case 6:
            break;
        case 7:
            break;
    }

    switch ( var_0 )
    {
        case 0:
            self notify( "traverseassist_cancelled" );

            if ( isdefined( self.p1 ) )
            {
                self.p1 thread scripts\cp\cp_infilexfil::takegunlesscp();
                self.p1.blockupdatewalldata = 0;

                if ( var_1 != 4 )
                    self.p1 setorigin( self.p1 getdroptofloorposition( self.p1.origin ) );
            }

            if ( isdefined( self.p2 ) )
            {
                self.p2 thread scripts\cp\cp_infilexfil::takegunlesscp();
                self.p2.blockupdatewalldata = 0;
            }

            remove_player_rig( self.p1 );
            remove_player_rig( self.p2 );

            if ( !istrue( self.quickavailable ) )
                self.initialtrigger enabletrigger();

            self.boosttrigger disabletrigger();
            self.toptrigger disabletrigger();
            self.pulluptrigger disabletrigger();

            if ( isdefined( self.topwatchtrigger ) )
            {
                self.topwatchtrigger delete();
                self.topwatchtrigger = undefined;
            }

            break;
        case 1:
            if ( var_1 == 0 )
            {
                if ( istrue( self.p1.hassolobuddyboost ) || level.players.size == 1 )
                    thread dosoloboost();
                else
                    thread preparetohoist();
            }
            else if ( var_1 == 2 )
                remove_player_rig( self.p2 );

            break;
        case 2:
            break;
        case 3:
            self.boosttrigger disabletrigger();
            giveboostscore( self.p1 );
            self notify( "SetPhase3" );
            thread dohoist();
            break;
        case 4:
            self.toptrigger disabletrigger();
            self.pulluptrigger disabletrigger();

            if ( isdefined( self.topwatchtrigger ) )
            {
                self.topwatchtrigger delete();
                self.topwatchtrigger = undefined;
            }

            remove_player_rig( self.p1 );
            remove_player_rig( self.p2 );
            thread createtoptrigger();
            thread toptriggertrackplayer();
            break;
        case 5:
            thread preparetograb();
            break;
        case 6:
            break;
        case 7:
            self notify( "SetPhase7" );
            giveboostscore( self.p2 );
            dograb();
            break;
    }
}

handlephasecancellation()
{
    for (;;)
    {
        self waittill( "traverseassist_cancelled" );

        switch ( self.phase )
        {
            case 0:
                break;
            case 1:
                thread setphase( 0 );
                break;
            case 2:
                if ( isdefined( self.p1 ) && self.p1 scripts\cp_mp\utility\player_utility::_isalive() )
                    thread setphase( 1 );
                else
                    thread setphase( 0 );

                break;
            case 3:
                if ( isdefined( self.p1 ) && self.p1 scripts\cp_mp\utility\player_utility::_isalive() )
                    thread setphase( 1 );
                else
                    thread setphase( 0 );

                break;
            case 4:
                if ( isdefined( self.p2 ) && self.p2 scripts\cp_mp\utility\player_utility::_isalive() && isdefined( self.topwatchtrigger ) && self.p2 istouching( self.topwatchtrigger ) )
                    thread setphase( 4 );
                else
                    thread setphase( 0 );

                break;
            case 5:
                if ( isdefined( self.p2 ) && self.p2 scripts\cp_mp\utility\player_utility::_isalive() && isdefined( self.topwatchtrigger ) && self.p2 istouching( self.topwatchtrigger ) )
                    thread setphase( 4 );
                else
                    thread setphase( 0 );

                break;
            case 6:
                if ( isdefined( self.p2 ) && self.p2 scripts\cp_mp\utility\player_utility::_isalive() && isdefined( self.topwatchtrigger ) && self.p2 istouching( self.topwatchtrigger ) )
                    thread setphase( 4 );
                else
                    thread setphase( 0 );

                break;
            case 7:
                if ( isdefined( self.p2 ) && self.p2 scripts\cp_mp\utility\player_utility::_isalive() && isdefined( self.topwatchtrigger ) && self.p2 istouching( self.topwatchtrigger ) )
                    thread setphase( 4 );
                else
                    thread setphase( 0 );

                break;
        }
    }
}

usetriggerholdloop( var_0, var_1 )
{
    while ( usetest( var_0, var_1 ) )
    {
        var_0.curprogress = var_0.curprogress + 50 * var_0.userate;

        if ( var_0.curprogress >= var_0.usetime )
            return var_1 scripts\cp_mp\utility\player_utility::_isalive();

        waitframe();
    }

    return 0;
}

usetest( var_0, var_1 )
{
    if ( !isdefined( var_0 ) )
        return 0;

    if ( !var_1 scripts\cp_mp\utility\player_utility::_isalive() )
        return 0;

    if ( !var_1 usebuttonpressed() )
        return 0;

    if ( var_1 scripts\cp\cp_weapon::grenadeinpullback() )
        return 0;

    if ( var_1 meleebuttonpressed() )
        return 0;

    if ( var_0.curprogress >= var_0.usetime )
        return 0;

    return 1;
}

preparetohoist()
{
    self.initialtrigger disabletrigger();
    self endon( "traverseassist_cancelled" );
    thread watchplayerusebuttonpressed( self.p1 );
    thread cancelonuserelease( self.p1, "SetPhase3" );
    thread create_player_rig( self.p1, "hoister" );
    var_0 = thread playeranimsingle( self.p1, "hoist_ready" );
    wait( var_0 );
    createboosttrigger();
    thread watchdeath( self.p1 );
    thread watchdisconnect( self.p1 );
    thread playeranimlooping( self.p1, "hoist_ready_idle", "SetPhase3" );
}

dosoloboost()
{
    self endon( "traverseassist_cancelled" );
    thread create_player_rig( self.p1, "climber" );
    var_0 = thread playeranimsingle( self.p1, "hoist" );
    wait( var_0 );
    var_0 = playeranimsingle( self.p1, "hoist_n_go" );
    wait( var_0 );

    if ( level.usequickrope == 1 )
        thread quicktriggertimeout();

    thread setphase( 0 );
}

dohoist()
{
    self.p2.blockupdatewalldata = 1;
    self endon( "traverseassist_cancelled" );
    thread playeranimsingle( self.p1, "hoist" );
    thread watchplayerusebuttonpressed( self.p1, 2.0 );
    thread create_player_rig( self.p2, "climber" );
    var_0 = thread playeranimsingle( self.p2, "hoist" );
    thread watchplayerusebuttonpressed( self.p2, 2.0 );
    wait( var_0 );

    if ( !level.pullbothup )
    {
        var_1 = thread playeranimsingle( self.p1, "hoist_n_go" );
        var_2 = thread playeranimsingle( self.p2, "hoist_n_go" );
        wait( var_1 );
        self.p1 thread scripts\cp\cp_infilexfil::takegunlesscp();
        self.p2 thread scripts\cp\cp_infilexfil::takegunlesscp();
        self.p1.blockupdatewalldata = 0;
        self.p2.blockupdatewalldata = 0;
        thread setphase( 4 );
    }
    else
    {
        var_1 = thread playeranimsingle( self.p1, "hoist_n_grab" );
        var_2 = thread playeranimsingle( self.p2, "hoist_n_grab" );
        wait( var_1 );
        self.p1 thread scripts\cp\cp_infilexfil::takegunlesscp();
        self.p2 thread scripts\cp\cp_infilexfil::takegunlesscp();
        self.p1.blockupdatewalldata = 0;
        self.p2.blockupdatewalldata = 0;
        thread setphase( 4 );
    }

    if ( level.usequickrope == 1 )
        thread quicktriggertimeout();
}

preparetograb()
{
    thread create_player_rig( self.p2, "climber" );
    var_0 = thread playeranimsingle( self.p2, "grab_ready" );
    wait( var_0 );
    thread createpulluptrigger();
    thread playeranimlooping( self.p2, "grab_ready_idle", "SetPhase7" );
}

dograb()
{
    self endon( "traverseassist_cancelled" );
    thread create_player_rig( self.p1, "hoister" );
    thread playeranimsingle( self.p1, "grab" );
    var_0 = thread playeranimsingle( self.p2, "grab" );
    wait( var_0 );
    remove_player_rig( self.p1 );
    remove_player_rig( self.p2 );
    thread setphase( 4 );
}

initialtriggerthink()
{
    while ( isdefined( self.initialtrigger ) )
    {
        self.initialtrigger waittill( "trigger", var_0 );

        if ( istrue( var_0.takinggunless ) )
            continue;

        self.initialtrigger disabletrigger();

        if ( var_0 scripts\cp\cp_infilexfil::givegunlesscp() )
        {
            self.p1 = var_0;
            thread setphase( 1 );
            continue;
        }

        self.initialtrigger enabletrigger();
    }
}

cancelonuserelease( var_0, var_1 )
{
    self endon( "traverseassist_cancelled" );

    if ( isdefined( var_1 ) )
        self endon( var_1 );

    while ( !var_0.releasedusebutton )
        waitframe();

    thread setphase( 0 );
}

createboosttrigger()
{
    self.boosttrigger enabletrigger();
    var_0 = self.p1 gettagorigin( "J_Wrist_RI" );
    self.boosttrigger.origin = var_0;
    self.boosttrigger linkto( self.p1, "J_Wrist_RI", ( 0, 0, 10 ), ( 0, 0, 0 ) );

    foreach ( var_2 in level.players )
    {
        if ( var_2 == self.p1 )
        {
            self.boosttrigger disableplayeruse( var_2 );
            continue;
        }

        self.boosttrigger enableplayeruse( var_2 );
    }
}

boosttriggerthink()
{
    while ( isdefined( self.boosttrigger ) )
    {
        self.boosttrigger waittill( "trigger", var_0 );

        if ( istrue( var_0.takinggunless ) )
            continue;

        if ( var_0 == self.p1 )
            continue;

        self.boosttrigger disabletrigger();

        if ( var_0 scripts\cp\cp_infilexfil::givegunlesscp() )
        {
            self.p2 = var_0;
            thread setphase( 3 );
            continue;
        }

        self.boosttrigger enabletrigger();
    }
}

giveboostscore( var_0 )
{
    var_1 = "buddy_boost";
}

createtoptrigger()
{
    self.toptrigger enabletrigger();
    var_0 = self.p2 gettagorigin( "J_Wrist_RI" );
    self.toptrigger.origin = var_0;
    self.toptrigger linkto( self.p2, "J_Wrist_RI", ( 0, 0, 0 ), ( 0, 0, 0 ) );

    foreach ( var_2 in level.players )
    {
        if ( var_2 != self.p2 )
        {
            self.toptrigger disableplayeruse( var_2 );
            continue;
        }

        self.toptrigger enableplayeruse( var_2 );
    }

    thread watchdeath( self.p2 );
    thread watchdisconnect( self.p2 );
}

toptriggertrackplayer()
{
    if ( isdefined( self.topwatchtrigger ) )
        return;

    self endon( "traverseassist_cancelled" );
    self.topwatchtrigger = spawn( "trigger_radius", self.p2.origin, 0, 48, 72 );

    for (;;)
    {
        if ( !self.p2 istouching( self.topwatchtrigger ) )
            break;

        waitframe();
    }

    self notify( "traverseassist_cancelled" );
}

toptriggerthink()
{
    while ( isdefined( self.toptrigger ) )
    {
        self.toptrigger waittill( "trigger", var_0 );

        if ( var_0 != self.p2 )
            continue;

        thread setphase( 5 );
        self.toptrigger.curprogress = 0;
        self.toptrigger.inuse = 1;
        self.toptrigger.userate = 0;
        self.toptrigger.usetime = 9999;
        var_1 = usetriggerholdloop( self.toptrigger, var_0 );
        self.toptrigger.inuse = 0;
        self.toptrigger.curprogress = 0;

        if ( !var_1 || !isdefined( var_0 ) )
        {
            self notify( "traverseassist_cancelled" );
            break;
        }
    }
}

createpulluptrigger()
{
    self.pulluptrigger enabletrigger();
    var_0 = self.p2 gettagorigin( "J_Wrist_RI" );
    self.pulluptrigger.origin = var_0;
    self.pulluptrigger linkto( self.p2, "J_Wrist_RI", ( 0, 0, 0 ), ( 0, 0, 0 ) );

    foreach ( var_2 in level.players )
    {
        if ( var_2 == self.p2 )
        {
            self.pulluptrigger disableplayeruse( var_2 );
            continue;
        }

        self.pulluptrigger enableplayeruse( var_2 );
    }
}

pulluptriggerthink()
{
    while ( isdefined( self.pulluptrigger ) )
    {
        self.pulluptrigger waittill( "trigger", var_0 );

        if ( var_0 == self.p2 )
            continue;

        self.p1 = var_0;
        thread setphase( 6 );
        self.pulluptrigger.curprogress = 0;
        self.pulluptrigger.inuse = 1;
        self.pulluptrigger.userate = 1;
        self.pulluptrigger.usetime = 100;
        var_1 = usetriggerholdloop( self.pulluptrigger, var_0 );
        self.pulluptrigger.inuse = 0;
        self.pulluptrigger.curprogress = 0;

        if ( !var_1 || !isdefined( var_0 ) )
        {
            thread setphase( 5 );
            continue;
        }

        thread setphase( 7 );
        break;
    }
}

playeranimsingle( var_0, var_1 )
{
    if ( getdvarint( "scr_buddyboost_force", 2 ) == 2 )
    {
        var_0 setorigin( self.initialorg.origin );
        var_0 setplayerangles( self.initialorg.angles );
    }

    var_0 thread scripts\cp\cp_anim::anim_player_solo( var_0, var_0.player_rig, var_1 );
    var_2 = getanimlength( level.scr_anim[var_0.animname][var_1] );
    var_3 = getdvarfloat( "scr_buddyboost_shave", 0.2 );
    return var_2 - var_3;
}

playeranimlooping( var_0, var_1, var_2 )
{
    self endon( "traverseassist_cancelled" );

    if ( isdefined( var_2 ) )
        self endon( var_2 );

    for (;;)
    {
        var_3 = playeranimsingle( var_0, var_1 );
        wait( var_3 );
    }
}

debug_loopbuddyboostanims()
{
    var_0 = undefined;
    var_1 = undefined;
    var_2 = undefined;

    while ( level.players.size < 5 )
        waitframe();

    wait 5.0;
    var_3 = undefined;
    var_4 = level.players[0].origin;

    if ( getdvarint( "scr_buddyboost_school", 0 ) == 1 )
        var_4 = ( 700, -1600, 70 );

    for ( var_5 = 0; var_5 < level.traversalassist.size; var_5++ )
    {
        var_6 = distance2d( var_4, level.traversalassist[var_5].initialorg.origin );

        if ( !isdefined( var_3 ) || var_6 < var_3 )
        {
            var_3 = var_6;
            var_0 = level.traversalassist[var_5];
        }
    }

    for (;;)
    {
        debug_assignroles( var_0 );
        var_0 thread create_player_rig( var_0.hoister, "hoister" );
        var_0 thread create_player_rig( var_0.climber, "climber" );
        var_7 = gettime();
        iprintlnbold( "Anim: hoist_ready" );
        var_8 = var_0 thread playeranimsingle( var_0.hoister, "hoist_ready" );
        wait( var_8 );
        iprintlnbold( "Anim: hoist" );
        var_8 = var_0 thread playeranimsingle( var_0.hoister, "hoist" );
        var_9 = var_0 thread playeranimsingle( var_0.climber, "hoist" );
        wait( var_9 );

        switch ( getdvarint( "scr_buddyboost_flow", 0 ) )
        {
            case 0:
                iprintlnbold( "Anim: hoist_n_grab" );
                var_8 = var_0 thread playeranimsingle( var_0.hoister, "hoist_n_grab" );
                var_9 = var_0 thread playeranimsingle( var_0.climber, "hoist_n_grab" );
                wait( var_9 );
                break;
            case 1:
                iprintlnbold( "Anim: hoist_n_go" );
                var_8 = var_0 thread playeranimsingle( var_0.hoister, "hoist_n_go" );
                var_9 = var_0 thread playeranimsingle( var_0.climber, "hoist_n_go" );
                wait( var_9 );
                iprintlnbold( "Anim: grab_ready" );
                var_9 = var_0 thread playeranimsingle( var_0.climber, "grab_ready" );
                wait( var_9 );
                iprintlnbold( "Anim: Grab" );
                var_8 = var_0 thread playeranimsingle( var_0.hoister, "grab" );
                var_9 = var_0 thread playeranimsingle( var_0.climber, "grab" );
                wait( var_8 );
                break;
        }

        var_10 = gettime();
        remove_player_rig( var_0.hoister );
        remove_player_rig( var_0.climber );
        iprintlnbold( "Anim Duration: " + ( var_10 - var_7 ) / 1000 );
        wait 3.0;
    }
}

debug_assignroles( var_0 )
{
    var_0.hoister = undefined;
    var_0.climber = undefined;

    for ( var_1 = 1; var_1 < level.players.size; var_1++ )
    {
        if ( level.players[var_1].team == level.players[0].team )
        {
            if ( !isdefined( var_0.hoister ) )
            {
                var_0.hoister = level.players[var_1];
                continue;
            }

            if ( !isdefined( var_0.climber ) )
            {
                var_0.climber = level.players[var_1];
                break;
            }
        }
    }

    if ( getdvarint( "scr_buddyboost_hoister", 0 ) != 0 )
        var_0.hoister = level.players[0];

    if ( getdvarint( "scr_buddyboost_climber", 0 ) != 0 )
        var_0.climber = level.players[0];
}

watchplayerusebuttonpressed( var_0, var_1 )
{
    var_0 notify( "watchPlayerUseButtonPressed" );
    var_0 endon( "watchPlayerUseButtonPressed" );
    var_0.releasedusebutton = 0;
    var_2 = gettime();

    if ( !isdefined( var_1 ) )
        var_3 = undefined;
    else
        var_3 = var_2 + var_1 * 1000;

    while ( !isdefined( var_3 ) || gettime() < var_3 )
    {
        if ( !var_0 usebuttonpressed() )
        {
            var_0.releasedusebutton = 1;
            break;
        }

        waitframe();
    }
}

quicktriggerthink()
{
    self.quicktrigger disabletrigger();

    while ( isdefined( self.quicktrigger ) )
    {
        self.quicktrigger waittill( "trigger", var_0 );

        if ( istrue( var_0.takinggunless ) )
            continue;

        self.quicktrigger disabletrigger();

        if ( var_0 scripts\cp\cp_infilexfil::givegunlesscp() )
        {
            thread create_player_rig( var_0, "hoister" );
            var_1 = thread playeranimsingle( var_0, "grab" );
            wait( var_1 );
            var_0 thread scripts\cp\cp_infilexfil::takegunlesscp();
            remove_player_rig( var_0 );
        }

        thread quicktriggertimeout();
    }
}

quicktriggertimeout()
{
    self.quicktrigger enabletrigger();
    self.initialtrigger disabletrigger();
    self.quickavailable = 1;
    self notify( "quickTriggerTimeout" );
    self endon( "quickTriggerTimeout" );
    self.quicktrigger setscriptablepartstate( "marker", "contested" );
    self.quicktrigger playloopsound( "mp_flare_burn_lp" );
    wait 20.0;
    self.quicktrigger disabletrigger();
    self.initialtrigger enabletrigger();
    self.quickavailable = 0;
    self.quicktrigger setscriptablepartstate( "marker", "off" );
    self.quicktrigger stoploopsound();
}

spawnhintobjects( var_0 )
{
    if ( isdefined( var_0 ) )
    {
        self.initialorg = spawnstruct();
        self.initialorg.origin = var_0.wallscenenodepos;
        self.initialorg.angles = var_0.wallscenenodeang;
    }

    var_1 = anglestoforward( self.initialorg.angles );
    var_2 = anglestoright( self.initialorg.angles );
    var_3 = anglestoup( self.initialorg.angles );

    if ( isdefined( var_0 ) )
        self.initialtrigger = var_0.wallprompt;
    else
    {
        var_4 = self.initialorg.origin + var_1 * -22 + var_3 * 48;
        self.initialtrigger = scripts\cp\utility::createhintobject( var_4, "HINT_BUDDY_BOOST", undefined, &"MP/TRAVERSAL_ASSIST_PRE_BOOST", -10000, undefined, undefined, 400, 160, 100, 120 );
    }

    thread initialtriggerthink();
    var_4 = self.initialorg.origin + var_1 * -10 + var_2 * -50 + var_3 * 120;
    self.boosttrigger = scripts\cp\utility::createhintobject( var_4, "HINT_BUDDY_BOOST", undefined, &"MP/TRAVERSAL_ASSIST_BOOST", -10000, undefined, undefined, 400, 160, 100, 120 );
    thread boosttriggerthink();
    var_4 = self.initialorg.origin + var_1 * -10 + var_2 * 50 + var_3 * 120;
    self.toptrigger = scripts\cp\utility::createhintobject( var_4, "HINT_BUDDY_BOOST", undefined, &"MP/TRAVERSAL_ASSIST_PRE_PULL_UP", -10000, undefined, undefined, 400, 160, 100, 120 );
    thread toptriggerthink();
    var_4 = self.initialorg.origin + var_1 * -10 + var_2 * -50 + var_3 * 150;
    self.pulluptrigger = scripts\cp\utility::createhintobject( var_4, "HINT_BUDDY_BOOST", undefined, &"MP/TRAVERSAL_ASSIST_PULL_UP", -10000, undefined, undefined, 400, 160, 100, 120 );
    thread pulluptriggerthink();
    var_4 = self.initialorg.origin + var_1 * -3 + var_3 * 70;
    self.quicktrigger = scripts\cp\utility::createhintobject( var_4, "HINT_BUDDY_BOOST", undefined, &"MP/TRAVERSAL_ASSIST_PULL_UP", -10000, undefined, undefined, 400, 160, 100, 120 );
    self.quicktrigger setmodel( "cop_marker_scriptable" );
    thread quicktriggerthink();
}

enabletrigger()
{
    self show();
    self makeusable();
}

disabletrigger()
{
    self hide();
    self makeunusable();

    if ( self islinked() )
        self unlink();
}

add_contextualwalltraversal_array()
{
    level.contextualwalltraversals = [];
    var_0 = scripts\engine\utility::getstructarray( "contextualwalltraversal", "targetname" );

    foreach ( var_2 in var_0 )
    {
        var_3 = spawnstruct();
        var_3.point0 = var_2.origin;
        var_3.angles = var_2.angles;

        if ( isdefined( var_2.target ) )
        {
            var_4 = scripts\engine\utility::getstruct( var_2.target, "targetname" );

            if ( isdefined( var_4 ) )
            {
                var_3.point1 = var_4.origin;
                var_3.linesegment = var_3.point1 - var_3.point0;
                var_3.linelengthsq = vectordot( var_3.linesegment, var_3.linesegment );
            }
        }

        var_3.normal = vectornormalize( anglestoforward( var_2.angles ) * -1 );
        var_5 = var_3.point0 + var_3.normal * 23.5;
        var_6 = scripts\engine\utility::drop_to_ground( var_5, 50.0, -200.0 );
        var_3.usehigh = var_5[2] - var_6[2] > 150;
        var_3.index = level.contextualwalltraversals.size;
        level.contextualwalltraversals[level.contextualwalltraversals.size] = var_3;
    }

    level thread updatecontextuawalltraversals();
}

updatecontextuawalltraversals()
{
    var_0 = level.framedurationseconds;

    for (;;)
    {
        foreach ( var_2 in level.players )
        {
            if ( istrue( var_2.blockupdatewalldata ) )
                continue;

            var_3 = undefined;

            foreach ( var_5 in level.contextualwalltraversals )
            {
                if ( isdefined( var_2.laddertracking ) && istrue( var_2.laddertracking[var_5.index] ) )
                    continue;

                var_6 = closestpointtowall( var_2, var_5 );

                if ( !isdefined( var_3 ) || var_6.distsq < var_3.distsq )
                    var_3 = var_6;
            }

            var_8 = var_2 scripts\cp\utility::_hasperk( "specialty_breacher" );

            if ( !isdefined( var_3 ) || var_3.distsq > 490000 )
            {
                if ( isdefined( var_2.wallprompt ) )
                    var_2.wallprompt hidefromplayer( var_2 );

                if ( var_8 && isdefined( var_2.ladderpreviewmodel ) )
                    var_2.ladderpreviewmodel hidefromplayer( var_2 );

                continue;
            }

            var_9 = var_3.closestpoint + var_3.wall.normal * 23.5;
            var_10 = scripts\engine\utility::drop_to_ground( var_9, 50.0, -200.0 );
            var_11 = var_9[2] - var_10[2] > 150;
            var_9 = var_10 + ( 0, 0, 48 );

            if ( !var_8 )
                var_10 = var_10 + var_3.wall.normal * -23.5;

            var_2.wallscenenodepos = var_10;
            var_2.wallscenenodeang = var_3.wall.angles;
            var_2.bestwall = var_3;
        }

        waitframe();
    }
}

closestpointtowall( var_0, var_1 )
{
    if ( !isdefined( var_1.point1 ) )
        var_2 = var_1.point0;
    else
    {
        var_3 = var_0.origin - var_1.point0;
        var_4 = vectordot( var_3, var_1.linesegment ) / var_1.linelengthsq;
        var_4 = clamp( var_4, 0.0, 1.0 );
        var_2 = var_1.point0 + var_4 * var_1.linesegment;
    }

    var_5 = var_0.origin - var_2;
    var_6 = vectordot( var_5, var_5 );
    var_7 = spawnstruct();
    var_7.closestpoint = var_2;
    var_7.distsq = var_6;
    var_7.wall = var_1;
    return var_7;
}

spawnwallprompt( var_0, var_1, var_2 )
{
    if ( var_2 )
        var_3 = scripts\cp\utility::createhintobject( var_1, "HINT_BUDDY_BOOST", undefined, &"MP/PLACE_LADDER", -10000, "duration_none", undefined, 400, 160, 100, 120 );
    else
        var_3 = scripts\cp\utility::createhintobject( var_1, "HINT_BUDDY_BOOST", undefined, &"MP/TRAVERSAL_ASSIST_PRE_BOOST", -10000, undefined, undefined, 400, 160, 100, 120 );

    var_3 dontinterpolate();
    var_3.owner = var_0;
    var_3 hide();
    return var_3;
}

createactivecontextualwalltraversal( var_0, var_1 )
{
    if ( !isdefined( level.activecontextualwalltraversals ) )
        level.activecontextualwalltraversals = [];

    var_2 = spawnstruct();
    var_2.type = var_1;
    var_2.player = var_0;

    if ( var_1 == "buddyBoost" )
        var_2 setup_traversalassist( var_0 );
    else if ( var_1 == "ladder" )
        var_2 scripts\cp\cp_ladder::setupdynamicladders();

    level.activecontextualwalltraversals[level.activecontextualwalltraversals.size] = var_2;
}

updatecontextualwallpromptforplayer( var_0 )
{
    if ( !isdefined( var_0.wallprompt ) )
        return;

    var_0.wallprompt delete();
    var_0.wallprompt = undefined;

    foreach ( var_2 in level.activecontextualwalltraversals )
    {
        if ( var_2.player == var_0 )
        {
            var_2 = undefined;
            break;
        }
    }

    var_4 = var_0 scripts\cp\utility::_hasperk( "specialty_breacher" );
    level createactivecontextualwalltraversal( var_0, scripts\engine\utility::ter_op( var_4, "ladder", "buddyBoost" ) );
}
