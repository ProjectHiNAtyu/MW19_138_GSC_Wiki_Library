// IW8 GSC SOURCE
// Generated by https://github.com/xensik/gsc-tool

main()
{
    init_settings();
    init_flags();
    scripts\stealth\group::addtogroup( self.script_stealthgroup, self );
    setpatrolstyle_base();
    scripts\stealth\event::event_init_entity();
    thread monitor_damage_thread( level.stealth.damage_auto_range, level.stealth.damage_sight_range );
    set_alert_level( "reset" );
    bt_set_stealth_state( "idle" );
    stealth_init_goal_radius();

    if ( isdefined( level.stealth.fninitenemygame ) )
        self thread [[ level.stealth.fninitenemygame ]]();
}

init_flags()
{
    scripts\engine\utility::ent_flag_init( "stealth_enabled" );
    scripts\engine\utility::ent_flag_set( "stealth_enabled" );
    scripts\engine\utility::ent_flag_init( "stealth_override_goal" );
    scripts\engine\utility::ent_flag_init( "stealth_hold_position" );
    scripts\engine\utility::ent_flag_init( "stealth_attack" );
    scripts\engine\utility::ent_flag_init( "stealth_cover_blown" );
    scripts\engine\utility::ent_flag_init( "stealth_local_investigation_only" );
    scripts\engine\utility::ent_flag_init( "stealth_disable_unresponsive_ai_check" );
    scripts\engine\utility::ent_flag_init( "stealth_non_player_combat" );
    scripts\stealth\utility::group_flag_init( "stealth_spotted" );
    scripts\stealth\utility::group_flag_init( "stealth_cover_blown" );
    scripts\stealth\utility::group_flag_init( "stealth_combat_hunting" );
    scripts\stealth\utility::group_flag_init( "stealth_disable_unresponsive_ai_check" );
}

stealth_init_goal_radius()
{
    if ( isdefined( self.script_radius ) )
    {
        self.goalradius = self.script_radius;
        return;
    }

    if ( !isdefined( self getgoalvolume() ) )
        self.goalradius = level.default_goalradius;
}

init_settings()
{
    self.stealth = spawnstruct();
    self.stealth.funcs = [];
    self.stealth.max_warnings = 2;
    self.stealth.reachedinvestigate = 0;
    self.newenemyreactiondistsq = squared( level.stealth.ai_event["ai_eventDistFootstepSprint"]["hidden"] );
    scripts\stealth\corpse::corpse_init_entity();
    self.stealth.event_escalation_scalar = 0.0;

    if ( !isdefined( level.stealth.damage_auto_range ) )
        level.stealth.damage_auto_range = 175;

    if ( !isdefined( level.stealth.damage_sight_range ) )
        level.stealth.damage_sight_range = 600;

    self.grenadeawareness = 0.0;
    self.canacquirenearbytacvisenemies = 0;
    self.stealth.bsmstate = -1;
}

death_cleanup()
{
    if ( isdefined( self ) )
        scripts\stealth\threat_sight::threat_sight_set_state( "death" );
    else
    {
        foreach ( var_1 in level.players )
        {
            foreach ( var_4, var_3 in var_1.stealth.threat_entities )
            {
                if ( !isdefined( var_3 ) )
                    var_1.stealth.threat_entities[var_4] = undefined;
            }

            foreach ( var_4, var_3 in var_1.stealth.threat_sighted )
            {
                if ( !isdefined( var_3 ) )
                    var_1.stealth.threat_sighted[var_4] = undefined;
            }
        }
    }

    if ( isdefined( self.stealth_vo_ent ) )
        self.stealth_vo_ent thread death_vo_cleanup();
}

death_vo_cleanup()
{
    self stopsounds();
    waitframe();
    self delete();
}

add_active_sense_function( var_0 )
{
    if ( !isdefined( self.stealth.active_sense_funcs ) )
        self.stealth.active_sense_funcs = [];

    self.stealth.active_sense_funcs[self.stealth.active_sense_funcs.size] = var_0;
}

proximity_check()
{
    if ( self.ignoreall )
        return;

    if ( !isdefined( level.stealth ) )
        return;

    var_0 = self getapproxeyepos();
    var_1 = ( self.origin + var_0 ) / 2;
    var_2 = ( 0, 0, 35 );

    if ( isdefined( self.proximity_bump_dist_sqr_override ) )
        var_3 = self.proximity_bump_dist_sqr_override;
    else
        var_3 = 1764;

    var_4 = 11025;
    var_5 = undefined;
    var_6 = undefined;

    foreach ( var_8 in level.players )
    {
        var_9 = 0;
        var_10 = 0;

        if ( !isalive( var_8 ) )
            continue;

        if ( issentient( var_8 ) && ( var_8.ignoreme || var_8.notarget ) )
            continue;

        var_11 = distancesquared( var_1, var_8.origin + var_2 );

        if ( distance2dsquared( self.origin, var_8.origin ) < var_3 )
        {
            var_12 = self.origin[2] - var_8.origin[2];

            if ( var_12 * var_12 < 5184 )
            {
                var_10 = 1;
                var_9 = 1;
            }
        }

        if ( !var_9 && isdefined( level.stealth.proximity_combat_radius_fake_sight ) && level.stealth.proximity_combat_radius_fake_sight > 0 )
        {
            if ( var_11 < level.stealth.proximity_combat_radius_fake_sight * level.stealth.proximity_combat_radius_fake_sight )
            {
                if ( !isdefined( self.stealth.blind ) )
                {
                    var_13 = var_8.origin - self.origin;
                    var_13 = ( var_13[0], var_13[1], 0 );
                    var_14 = anglestoforward( ( 0, self.angles[1], 0 ) );

                    if ( vectordot( var_14, var_13 ) > 0 )
                    {
                        var_10 = 1;
                        var_9 = 1;
                    }
                }
            }
        }

        if ( !var_9 && isdefined( level.stealth.proximity_combat_radius_bump ) && level.stealth.proximity_combat_radius_bump > 0 )
        {
            if ( var_11 < level.stealth.proximity_combat_radius_bump * level.stealth.proximity_combat_radius_bump )
            {
                var_15 = length2dsquared( var_8 getvelocity() );

                if ( var_15 > var_4 )
                {
                    var_10 = 1;
                    var_9 = 1;
                }
            }
        }

        if ( !var_9 && isdefined( level.stealth.proximity_combat_radius_sight ) && level.stealth.proximity_combat_radius_sight > 0 )
        {
            if ( var_11 < level.stealth.proximity_combat_radius_sight * level.stealth.proximity_combat_radius_sight )
            {
                if ( self cansee( var_8, 0 ) )
                    var_9 = 1;
            }
        }

        if ( var_9 && var_10 )
            var_9 = scripts\engine\trace::ray_trace_passed( self geteye(), var_8 geteye(), [ self, var_8 ] );

        if ( var_9 )
        {
            self aieventlistenerevent( "proximity", var_8, var_8.origin );
            scripts\engine\utility::delaycall( 0.05, ::getenemyinfo, var_8 );
            return;
        }
    }
}

set_blind( var_0, var_1 )
{
    if ( !isdefined( self.stealth ) )
        return;

    if ( !var_0 && !isdefined( self.stealth.blind ) )
        return;

    var_2 = isdefined( self.fnisinstealthcombat ) && self [[ self.fnisinstealthcombat ]]();
    var_3 = isdefined( self.fnisinstealthhunt ) && self [[ self.fnisinstealthhunt ]]();
    var_4 = var_2 || var_3;

    if ( var_0 && ( !var_4 || istrue( var_1 ) ) )
    {
        self.stealth.blind = 1;
        set_sight_state( "blind" );
    }
    else
    {
        self.stealth.blind = undefined;

        if ( var_4 )
            set_sight_state( "spotted" );
        else
            set_sight_state( "hidden" );
    }
}

set_sight_state( var_0 )
{
    switch ( var_0 )
    {
        case "blind":
            scripts\stealth\threat_sight::threat_sight_set_state( "blind" );
            self.fovcosine = 0.98;
            self.fovcosinebusy = 0.98;
            self.fovcosinez = 0;
            self.fovground = 0;
            self.fovcosineperiph = 0.99;
            self.fovcosineperiphmaxdistsq = 1;
            break;
        case "unaware":
        case "hidden":
        case "idle":
            scripts\stealth\threat_sight::threat_sight_set_state( "hidden" );
            self.fovcosine = 0.7;
            self.fovcosinebusy = 0.86;
            self.fovcosinez = 0.97;
            self.fovground = 1;
            self.fovcosineperiph = 0.01;
            self.fovcosineperiphmaxdistsq = 90000;
            break;
        case "investigate":
            scripts\stealth\threat_sight::threat_sight_set_state( "investigate" );
            self.fovcosine = 0.7;
            self.fovcosinebusy = 0.86;
            self.fovcosinez = 0.97;
            self.fovground = 1;
            self.fovcosineperiph = 0.01;
            self.fovcosineperiphmaxdistsq = 90000;
            break;
        case "combat_hunt":
        case "hunt":
            scripts\stealth\threat_sight::threat_sight_set_state( "combat_hunt" );
            self.fovcosine = 0.7;
            self.fovcosinebusy = 0.86;
            self.fovcosinez = 0.97;
            self.fovground = 1;
            self.fovcosineperiph = 0.01;
            self.fovcosineperiphmaxdistsq = 90000;
            break;
        case "spotted":
        case "combat":
            scripts\stealth\threat_sight::threat_sight_set_state( "spotted" );
            self.fovcosine = 0.01;
            self.fovcosinebusy = 0.574;
            self.fovcosinez = 0;
            self.fovground = 0;
            self.fovcosineperiph = 0.01;
            self.fovcosineperiphmaxdistsq = 16384;
            break;
        case "flashlight_in_dark":
            break;
        case "townhouse":
            break;
        case "elevated":
            break;
    }
}

alertlevel_normal( var_0 )
{
    thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce5", "alertreset" );
    set_alert_level( "reset" );
    bt_set_stealth_state( "idle" );
    scripts\stealth\utility::goto_last_goal();
}

set_alert_level( var_0 )
{
    if ( !scripts\engine\utility::ent_flag( "stealth_enabled" ) )
        return;

    if ( isdefined( self.alertlevelscript ) && self.alertlevelscript == var_0 )
        return;

    self notify( "set_alert_level" );
    self endon( "set_alert_level" );
    self endon( "death" );
    self.alertlevelscript = var_0;

    while ( isdefined( self.syncedmeleetarget ) )
        wait 0.05;

    scripts\stealth\utility::set_stealth_state( var_0 );
    self notify( "stealth_alertlevel_change", var_0 );
    self.alertlevel = scripts\stealth\utility::alertlevel_script_to_exe( var_0 );
    var_1 = self.alertlevelint > 2;
    scripts\stealth\event::event_entity_core_set_enabled( !var_1 );
    self.ignoreexplosionevents = !var_1;
}

set_default_stealth_funcs()
{
    level scripts\stealth\utility::set_stealth_func( "go_to_node_wait", ::go_to_node_wait );
    level scripts\stealth\utility::set_stealth_func( "go_to_node_arrive", ::go_to_node_arrived );
    level scripts\stealth\utility::set_stealth_func( "go_to_node_post_wait", ::go_to_node_post_wait );
    level scripts\stealth\utility::set_stealth_func( "reset", ::alertlevel_normal );
    level scripts\stealth\utility::set_stealth_func( "set_patrol_style", scripts\stealth\utility::set_patrol_style );
    level scripts\stealth\utility::set_stealth_func( "trigger_cover_blown", ::trigger_cover_blown );
    level scripts\stealth\utility::set_stealth_func( "set_blind", ::set_blind );
    level scripts\stealth\utility::set_stealth_func( "investigate", ::bt_event_handler_severity );
    level scripts\stealth\utility::set_stealth_func( "cover_blown", ::bt_event_handler_severity );
    level scripts\stealth\utility::set_stealth_func( "combat", ::bt_event_handler_severity );
}

monitor_damage_thread( var_0, var_1 )
{
    var_2 = undefined;
    var_3 = self.team;

    for (;;)
    {
        if ( !isalive( self ) )
            return;

        self waittill( "damage", var_4, var_5, var_6, var_7 );
        check_kill_damage( var_4, var_5, var_7 );
        var_8 = self.origin;

        if ( isalive( self ) && !scripts\engine\utility::ent_flag( "stealth_enabled" ) )
            continue;

        if ( isalive( var_5 ) )
            var_2 = var_5;

        if ( !isdefined( var_2 ) )
            continue;

        self aieventlistenerevent( "damage", var_2, var_2.origin );

        if ( isplayer( var_2 ) || isdefined( var_2.team ) && var_2.team != var_3 )
            break;

        if ( isdefined( var_2.classname ) && var_2.classname == "script_model" )
        {
            if ( var_2.isbarrel )
                break;
        }
    }

    if ( !isdefined( self ) )
        return;

    if ( isdefined( self.stealth.override_damage_auto_range ) )
        var_0 = self.stealth.override_damage_auto_range;
    else if ( isdefined( level.stealth.override_damage_auto_range ) )
        var_0 = level.stealth.override_damage_auto_range;

    if ( isdefined( self.stealth.override_damage_sight_range ) )
        var_1 = self.stealth.override_damage_sight_range;
    else if ( isdefined( level.stealth.override_damage_sight_range ) )
        var_1 = level.stealth.override_damage_sight_range;

    if ( isalive( self ) )
        scripts\stealth\event::event_broadcast_axis( "ally_damaged", "ally_hurt_peripheral", var_2, var_0, var_1 );
    else
        scripts\stealth\event::event_broadcast_axis( "ally_killed", "ally_hurt_peripheral", var_2, var_0, var_1 );
}

check_kill_damage( var_0, var_1, var_2 )
{
    if ( isdefined( self.disableeasystealthheadshot ) )
        return;

    if ( var_0 > 0 && self.damagemod != "MOD_MELEE" && self.alertlevelscript != "attack" && self.alertlevelscript != "combat" )
    {
        var_3 = self geteye();

        if ( distancesquared( var_2, var_3 ) < squared( level.stealth.head_shot_dist ) )
            self dodamage( self.health, var_2, var_1, var_1, "MOD_HEAD_SHOT" );
    }
}

shotisreasonablysafe( var_0 )
{
    var_1 = getaiunittypearray( "bad_guys", "all" );
    var_2 = [];
    var_3 = squared( level.stealth.damage_auto_range );
    var_4 = squared( level.stealth.damage_sight_range );

    foreach ( var_6 in var_1 )
    {
        if ( var_6 == var_0 )
            continue;

        var_7 = distancesquared( var_0.origin, var_6.origin );

        if ( var_7 < var_3 )
            return 0;

        if ( var_7 < var_4 )
        {
            if ( var_6 getthreatsight( self ) > 0 )
                return 0;

            if ( var_6 scripts\engine\math::point_in_fov( var_0.origin, 0 ) && var_6 hastacvis( var_0 ) )
                return 0;

            var_2[var_2.size] = var_6;
        }
    }

    foreach ( var_6 in var_2 )
    {
        if ( var_6 cansee( var_0 ) )
            return 0;
    }

    return 1;
}

shotisbadidea( var_0 )
{
    var_1 = getaiunittypearray( "bad_guys", "all" );
    var_2 = [];
    var_3 = squared( level.stealth.damage_auto_range );
    var_4 = squared( level.stealth.damage_sight_range );

    foreach ( var_6 in var_1 )
    {
        if ( var_6 == var_0 )
            continue;

        var_7 = distancesquared( var_0.origin, var_6.origin );

        if ( var_7 < var_3 )
            return 1;

        if ( var_7 < var_4 )
        {
            if ( var_6 getthreatsight( self ) > 0 )
                return 1;

            if ( var_6 scripts\engine\math::point_in_fov( var_0.origin, 0 ) )
            {
                if ( var_6 hastacvis( var_0 ) )
                    return 1;

                var_2[var_2.size] = var_6;
            }
        }
    }

    foreach ( var_6 in var_2 )
    {
        if ( var_6 cansee( var_0 ) )
            return 1;
    }

    return 0;
}

headtrack_player_toggle( var_0 )
{
    if ( var_0 )
    {
        if ( !isdefined( self.stealth.allowplayerheadtracking ) )
            self.stealth.allowplayerheadtracking = 1;
        else if ( !self.stealth.allowplayerheadtracking )
            return;

        if ( !isdefined( self.stealth.looking_at_entity ) )
            self.stealth.looking_at_entity = level.player;

        scripts\common\utility::lookatentity( level.player );
    }
    else if ( isdefined( self.stealth.looking_at_entity ) )
    {
        self.stealth.looking_at_entity = undefined;
        scripts\common\utility::lookatentity();
    }
}

lock_player_headtracking_off( var_0 )
{
    self endon( "death" );
    self notify( "lock_headtracking_off" );
    self endon( "lock_headtracking_off" );
    disable_player_headtracking();
    wait( var_0 );
    enable_player_headtracking();
}

disable_player_headtracking()
{
    self.stealth.allowplayerheadtracking = 0;
    headtrack_player_toggle( 0 );
}

enable_player_headtracking()
{
    self.stealth.allowplayerheadtracking = 1;
}

event_handler_should_ignore( var_0 )
{
    var_1 = self.stealth.event_severity_min;

    if ( !isdefined( var_1 ) )
        var_1 = level.stealth.event_severity_min;

    if ( isdefined( var_1 ) )
    {
        var_2 = scripts\stealth\event::event_severity_compare( var_1, var_0.type );

        if ( var_2 > 0 )
            return 1;
    }

    if ( istrue( level.stealth.disguised ) && event_override_disguise( var_0 ) )
        return 1;

    if ( var_0.typeorig == "explode" )
    {
        if ( isdefined( var_0.entity ) && isdefined( var_0.entity.team ) && var_0.entity.team == self.team )
            return 1;
    }

    if ( var_0.typeorig == "footstep_sprint" )
    {
        if ( should_ignore_sprint_footstep( var_0 ) )
            return 1;
    }

    if ( var_0.typeorig == "silenced_shot" )
    {
        if ( isplayer( var_0.entity ) && distancesquared( var_0.entity geteye(), var_0.origin ) > 1296 )
            return 1;
    }

    if ( var_0.typeorig == "gunshot" || var_0.typeorig == "gunshot_teammate" || var_0.typeorig == "bulletwhizby" )
    {
        if ( isai( var_0.entity ) && var_0.entity isinscriptedstate() )
            return 1;
    }

    if ( istrue( scripts\stealth\callbacks::stealth_call( "event_should_ignore", var_0 ) ) )
        return 1;

    var_3 = scripts\stealth\callbacks::stealth_get_func( "event_" + var_0.type );

    if ( isdefined( var_3 ) )
        return scripts\stealth\callbacks::stealth_call( "event_" + var_0.type, var_0 );

    return 0;
}

should_ignore_sprint_footstep( var_0 )
{
    var_1 = ( 0, 0, 18 );
    var_2 = level.stealth.cantracetoaiignoreents;

    if ( isdefined( self.stealth.cantracetoaiignoreents ) )
        var_2 = scripts\engine\utility::array_combine( var_2, self.stealth.cantracetoaiignoreents );

    if ( isplayer( var_0.entity ) && scripts\engine\utility::can_trace_to_ai( var_0.origin + var_1, self, var_2 ) )
    {
        var_3 = distancesquared( self.origin, var_0.origin );
        var_4 = 250;

        if ( isdefined( self.sprintfootstepradius ) )
            var_4 = self.sprintfootstepradius;

        if ( var_3 < var_4 * var_4 )
            return 0;

        var_5 = self cansee( var_0.entity );

        if ( !var_5 && var_0.entity scripts\stealth\threat_sight::player_is_sprinting_at_me( self ) )
            return 0;
    }

    return 1;
}

event_override_disguise( var_0 )
{
    if ( issentient( var_0.entity ) )
    {
        switch ( var_0.typeorig )
        {
            case "footstep_walk":
            case "footstep_sprint":
            case "proximity":
            case "footstep":
                thread scripts\stealth\threat_sight::threat_sight_force_visible( var_0.entity, 1.0 );
                return 1;
        }
    }

    return 0;
}

event_override_controlling_robot( var_0 )
{
    if ( issentient( var_0.entity ) )
    {
        switch ( var_0.typeorig )
        {
            case "proximity":
                return 1;
            case "projectile_impact":
            case "gunshot":
            case "silenced_shot":
            case "bulletwhizby":
            case "grenade danger":
            case "explode":
                var_0.type = "combat";
                return 0;
        }
    }

    if ( var_0.type != "combat" )
        return 1;

    return 0;
}

event_anyone_within_radius( var_0, var_1 )
{
    var_2 = var_1 * var_1;
    var_3 = getaiunittypearray( "bad_guys", "all" );

    foreach ( var_5 in var_3 )
    {
        if ( distancesquared( var_0, var_5.origin ) <= var_2 )
            return 1;
    }

    return 0;
}

event_handler_translate_severity( var_0 )
{
    if ( !isdefined( var_0 ) || !isdefined( var_0.typeorig ) )
        return;

    if ( self [[ self.fnisinstealthhunt ]]() )
    {
        if ( var_0.type == "investigate" )
            var_0.type = "cover_blown";
    }

    switch ( var_0.typeorig )
    {
        case "sight":
            if ( self.subclass == "dog" )
                var_0.type = "investigate";
            else if ( isdefined( self.stealth.threat_sight_lost ) && self.stealth.threat_sight_lost == 0 )
            {
                if ( isdefined( var_0.entity ) && issentient( var_0.entity ) )
                    self getenemyinfo( var_0.entity );

                var_0.type = "combat";
            }

            break;
        case "grenade danger":
            if ( event_anyone_within_radius( var_0.origin, 128 ) )
                var_0.type = "combat";

            break;
        case "explode":
            if ( event_anyone_within_radius( var_0.origin, 192 ) )
                var_0.type = "combat";
            else if ( distancesquared( var_0.origin, self.origin ) <= 1048576 )
                var_0.type = "combat";

            break;
        case "gunshot":
            if ( distancesquared( var_0.origin, self.origin ) < 640000 )
                var_0.type = "combat";

            break;
        case "glass_destroyed":
            if ( self hastacvis( var_0.origin, 0 ) && distance2dsquared( var_0.origin, self.origin ) < 36864 )
                var_0.type = "combat";

            break;
    }
}

trigger_cover_blown( var_0, var_1 )
{
    if ( !isdefined( self.stealth ) )
        return;

    self.stealth.bcoverhasbeenblown = 1;
    self.stealth.bdocoverblownreaction = var_1;
}

react_announce( var_0 )
{
    self endon( "death" );
    var_1 = randomfloatrange( 0.5, 1.1 );

    switch ( var_0.type )
    {
        case "investigate":
            thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce5", "investigate", var_1 );
            return 1;
        case "cover_blown":
            thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce5", "coverblown", var_1 );
            return 1;
        case "combat":
            thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce2", "combat", 1 );
            return 1;
    }

    return 0;
}

react_announce_specific( var_0 )
{
    self endon( "death" );

    if ( isdefined( var_0.typeorig ) )
    {
        var_1 = randomfloatrange( 0.5, 1.0 );

        switch ( var_0.typeorig )
        {
            case "sight":
                if ( istrue( level.player.is_using_blackhornet ) )
                {
                    thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce2", "drone_spotted", var_1 );
                    return 1;
                }
                else
                {
                    thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce2", "sight", var_1 );
                    return 1;
                }
            case "explode":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce1", "explosion", var_1 );
                return 1;
            case "grenade danger":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce2", "grenade_danger", var_1 );
                return 1;
            case "seek_backup":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce4", "seek_backup", randomfloatrange( 2, 2.5 ), var_0 );
                return 1;
            case "saw_corpse":
            case "found_corpse":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce4", var_0.typeorig, var_1 );
                return 1;
            case "unresponsive_teammate":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce4", "unresponsive_teammate" );
                return 1;
            case "bulletwhizby":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce2", "bulletwhizby", 0.2, var_0 );
                return 1;
            case "silenced_shot":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce2", "silenced_shot", randomfloatrange( 0.8, 1.3 ), var_0 );
                return 1;
            case "gunshot":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce1", "gunshot", 0.2, var_0 );
                return 1;
            case "gunshot_teammate":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce1", "gunshot_teammate", 0.2, var_0 );
                return 1;
            case "ally_damaged":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce1", "gunshot", randomfloatrange( 0.8, 1.3 ), var_0 );
                return 1;
            case "ally_killed":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce1", "ally_killed", 0.5 );
                return 1;
            case "proximity":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce1", "proximity", 0.5 );
                return 1;
            case "footstep":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce5", "footstep", var_1 );
                return 1;
            case "footstep_sprint":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce5", "footstep_sprint", var_1 );
                return 1;
            case "light_killed":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce4", "light_killed", var_1 );
                return 1;
            case "glass_destroyed":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce4", "glass_destroyed", var_1 );
                return 1;
            case "window_open":
                thread scripts\stealth\utility::addeventplaybcs( "stealth", "announce4", "window_open", var_1 );
                return 1;
            case "damage":
                return 1;
            default:
        }
    }

    return 0;
}

go_to_node_wait_investigate( var_0, var_1, var_2 )
{
    self endon( "death" );

    if ( !isdefined( var_2 ) )
        var_2 = 1;

    var_3 = !var_2;

    while ( scripts\stealth\utility::stealth_behavior_active() || !var_3 )
    {
        scripts\stealth\utility::stealth_behavior_wait();
        self [[ var_0 ]]( var_1 );
        var_3 = 1;
        self waittill( "goal" );
    }
}

go_to_node_wait( var_0, var_1 )
{
    self endon( "death" );
    self._blackboard.idlenode = undefined;
    go_to_node_wait_investigate( var_0, var_1 );
}

go_to_node_post_wait( var_0, var_1 )
{
    self endon( "death" );
    self notify( "gotonode_post_wait" );

    if ( isdefined( self.stealth.idle ) && isdefined( var_1.target ) )
    {

    }

    if ( isdefined( var_1.target ) )
        self._blackboard.idlenode = undefined;
}

go_to_node_arrived( var_0, var_1 )
{
    go_to_node_wait_investigate( var_0, var_1, 0 );

    if ( isdefined( var_1.script_moveplaybackrate ) )
        self.moveplaybackrate = var_1.script_moveplaybackrate;

    if ( ( istrue( var_1.script_delay ) || istrue( var_1.script_delay_min ) || istrue( var_1.script_wait ) || isdefined( var_1.script_idle ) || istrue( var_1.patrol_stop ) || !isdefined( var_1.target ) ) && isdefined( var_1.angles ) )
    {
        self._blackboard.idlenode = var_1;

        if ( !istrue( var_1.script_delay ) && !istrue( var_1.script_wait ) )
            waitframe();
    }

    if ( isdefined( var_1.script_animation ) )
    {
        var_2 = var_1.script_animation;
        scripts\stealth\utility::animgenericcustomanimmode( self, "gravity", var_2 );
    }
    else if ( isdefined( var_1.script_idle ) )
        self._blackboard.idlenode = var_1;

    if ( isdefined( var_1.script_animation_exit ) )
        scripts\stealth\utility::animgenericcustomanimmode( self, "gravity", var_1.script_animation_exit );
}

setpatrolstyle_base()
{
    var_0 = scripts\stealth\utility::get_patrol_style_default();
    var_1 = isdefined( var_0 ) && var_0 != "unaware";
    var_2 = scripts\stealth\group::getgroup( self.script_stealthgroup );

    if ( var_1 || isdefined( self.stealth.bcoverhasbeenblown ) || isdefined( var_2.bcoverhasbeenblown ) )
    {
        var_3 = isdefined( self.stealth.bdocoverblownreaction ) && self.stealth.bdocoverblownreaction;
        var_4 = scripts\asm\asm::asm_getdemeanor() == "patrol" && var_3;
        scripts\stealth\utility::set_patrol_style( "alert", var_4, undefined, "small" );
    }
    else
        scripts\stealth\utility::set_patrol_style( "unaware" );
}

bt_set_stealth_state( var_0, var_1 )
{
    self [[ self.fnsetstealthstate ]]( var_0, var_1 );
}

bt_event_handler_severity( var_0 )
{
    var_0.investigate_pos = var_0.origin;

    if ( isdefined( self.enemy ) && isdefined( var_0.entity ) && var_0.entity == self.enemy )
        var_0.investigate_pos = self lastknownpos( self.enemy );
    else if ( isdefined( var_0.entity ) && var_0.typeorig == "bulletwhizby" )
        var_0.investigate_pos = var_0.entity.origin;

    event_handler_translate_severity( var_0 );

    if ( event_handler_should_ignore( var_0 ) )
        return 0;

    self.stealth.last_severity_time = gettime();

    if ( !scripts\stealth\utility::bcisincombat() )
    {
        if ( !react_announce_specific( var_0 ) )
            react_announce( var_0 );
    }

    switch ( var_0.type )
    {
        case "investigate":
            thread bt_event_investigate( var_0 );
            break;
        case "cover_blown":
            thread bt_event_cover_blown( var_0 );
            break;
        case "combat":
            thread bt_event_combat( var_0 );
            break;
    }

    level notify( "stealth_event", var_0, self );
    var_1 = scripts\stealth\callbacks::stealth_get_func( var_0.typeorig );

    if ( isdefined( var_1 ) && var_1 != ::bt_event_handler_severity )
        self thread [[ var_1 ]]( var_0 );

    return 1;
}

bt_event_investigate( var_0 )
{
    set_alert_level( "warning1" );
    bt_set_stealth_state( "investigate", var_0 );
}

bt_event_cover_blown( var_0 )
{
    set_alert_level( "warning2" );

    if ( isdefined( var_0.entity ) && isdefined( var_0.entity.classname ) && var_0.entity.classname == "script_vehicle_blackhornet" )
        return;

    if ( istrue( level.stealth.disguised ) )
    {
        switch ( var_0.typeorig )
        {
            case "gunshot":
            case "silenced_shot":
            case "explode":
                scripts\stealth\utility::set_disguised( 0 );
                level scripts\engine\utility::delaythread( 20, scripts\stealth\utility::set_disguised, 1 );
                break;
        }
    }

    if ( var_0.typeorig == "light_killed" )
    {
        var_0.look_pos = var_0.investigate_pos;
        var_0.investigate_pos = scripts\engine\utility::drop_to_ground( var_0.investigate_pos, 24, -256 );
    }

    if ( !self [[ self.fnisinstealthcombat ]]() )
    {
        if ( self [[ self.fnisinstealthhunt ]]() )
        {
            var_1 = scripts\stealth\group::group_updatepodhuntorigin( self, var_0.investigate_pos );

            if ( !isdefined( self.pathgoalpos ) || distancesquared( var_1, self.pathgoalpos ) > 576 )
            {
                scripts\asm\asm::asm_fireephemeralevent( "hunt", "knownpos", var_0.investigate_pos );
                scripts\stealth\utility::set_patrol_react( var_0.investigate_pos, "small" );
                return;
            }
        }
        else
            bt_set_stealth_state( "investigate", var_0 );
    }
}

bt_event_combat( var_0 )
{
    self notify( "investigate_behavior" );
    self notify( "stop_going_to_node" );
    set_alert_level( "attack" );
    bt_set_stealth_state( "combat", var_0 );

    if ( isdefined( var_0 ) && issentient( var_0.entity ) )
    {
        if ( !isdefined( self.enemy ) )
            self resetthreatupdate();

        thread set_provide_cover_fire();
    }

    scripts\engine\utility::ent_flag_set( "stealth_attack" );
}

set_provide_cover_fire()
{
    self.providecoveringfire = 1;
    self endon( "death" );
    self endon( "stealth_investigate" );
    self endon( "stealth_hunt" );
    self endon( "stealth_combat" );
    wait 5;
    self.providecoveringfire = 0;
}
